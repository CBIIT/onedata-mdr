DROP PACKAGE ONEDATA_WA.DQ;

CREATE OR REPLACE PACKAGE ONEDATA_WA.dq
AS
   FUNCTION getdqconfiguration (dqconfigsettinglist IN xmldom.domnodelist)
      RETURN t_dqconfig;
   FUNCTION getdqattributemappings (v_attributemappings IN xmldom.domnodelist)
      RETURN t_dqattributemappings;
   FUNCTION getdqinput (v_inputdatarowset IN t_rowset, v_dqinputxml IN CLOB)
      RETURN t_dqinput;
   FUNCTION cleanse (dqinput IN t_dqinput)
      RETURN t_rowset;
   FUNCTION match (
      inputrowset         IN   t_rowset,
      dqinput             IN   t_dqinput,
      matchwindowrowset   IN   t_rowset
   )
      RETURN t_rowset;
   FUNCTION generatematchwindowandmatch (
      inputrowset   IN   t_rowset,
      dqinput       IN   t_dqinput
   )
      RETURN t_rowset;
   FUNCTION generatematchwindowandmatch (
      inputrowset           IN   t_rowset,
      dqinput               IN   t_dqinput,
      enableresultsorting   IN   VARCHAR2
   )
      RETURN t_rowset;
   FUNCTION manualmatch (
      dqinput         IN   t_dqinput,
      objectid        IN   NUMBER,
      inputrowset     IN   t_rowset,
      actionpattern   IN   VARCHAR2,
      goldobjectid    IN   NUMBER,
      goldrowset      IN   t_rowset
   )
      RETURN t_dqcdiresult;
   FUNCTION automatch (cleansedrowset IN t_rowset, dqinput IN t_dqinput)
      RETURN VARCHAR2;
   FUNCTION unmerge (cleansedrowset IN t_rowset, dqinput IN t_dqinput)
      RETURN VARCHAR2;
   PROCEDURE adddqattributemapping (
      attributemappings   IN OUT   t_dqattributemappings,
      attributemapping             t_dqattributemapping
   );
   PROCEDURE match (
      v_data_in       IN       CLOB,
      v_match_input   IN       CLOB,
      v_data_out      OUT      CLOB,
      v_match_mode    IN       NUMBER
   );
   PROCEDURE cleanse (
      v_data_in         IN       CLOB,
      v_cleanse_input   IN       CLOB,
      v_data_out        OUT      CLOB
   );
   FUNCTION getdqinputforcleanserasxml (
      v_user_id           IN   VARCHAR2,
      v_repository_id     IN   VARCHAR2,
      v_database_type     IN   VARCHAR2,
      v_client_id         IN   NUMBER,
      v_project_id        IN   NUMBER,
      v_schema_id         IN   NUMBER,
      v_rmiregistryhost   IN   VARCHAR2,
      v_rmiregistryport   IN   VARCHAR2,
      v_object_name       IN   VARCHAR2
   )
      RETURN VARCHAR2;
   FUNCTION getdqinputformatcherasxml (
      v_user_id           IN   VARCHAR2,
      v_repository_id     IN   VARCHAR2,
      v_database_type     IN   VARCHAR2,
      v_client_id         IN   NUMBER,
      v_project_id        IN   NUMBER,
      v_schema_id         IN   NUMBER,
      v_rmiregistryhost   IN   VARCHAR2,
      v_rmiregistryport   IN   VARCHAR2,
      v_object_name       IN   VARCHAR2
   )
      RETURN VARCHAR2;
   FUNCTION getdqinputforcleanser (
      v_user_id           IN   VARCHAR2,
      v_repository_id     IN   VARCHAR2,
      v_database_type     IN   VARCHAR2,
      v_client_id         IN   NUMBER,
      v_project_id        IN   NUMBER,
      v_schema_id         IN   NUMBER,
      v_rmiregistryhost   IN   VARCHAR2,
      v_rmiregistryport   IN   VARCHAR2,
      v_object_name       IN   VARCHAR2
   )
      RETURN t_dqinput;
   FUNCTION getdqinputformatcher (
      v_user_id           IN   VARCHAR2,
      v_repository_id     IN   VARCHAR2,
      v_database_type     IN   VARCHAR2,
      v_client_id         IN   NUMBER,
      v_project_id        IN   NUMBER,
      v_schema_id         IN   NUMBER,
      v_rmiregistryhost   IN   VARCHAR2,
      v_rmiregistryport   IN   VARCHAR2,
      v_object_name       IN   VARCHAR2
   )
      RETURN t_dqinput;
END;
/


DROP PACKAGE ONEDATA_WA.HIER;

CREATE OR REPLACE PACKAGE ONEDATA_WA.hier
AS
   PROCEDURE createversion (
      metadata      IN   CLOB,
      fromversion   IN   NUMBER,
      toversion     IN   NUMBER
   );
   PROCEDURE deleteversion (
      metadata     IN   CLOB,
      VERSION      IN   NUMBER,
      schemaname   IN   VARCHAR2
   );
   PROCEDURE printversion (metadata IN CLOB, VERSION IN NUMBER);
   PROCEDURE copyversion (
      metadata       IN   CLOB,
      fromversion    IN   NUMBER,
      toschemaname   IN   VARCHAR2
   );
   PROCEDURE mergeversions (
      metadata      IN   CLOB,
      fromversion   IN   NUMBER,
      toversion     IN   NUMBER
   );
END;
/


DROP PACKAGE ONEDATA_WA.HOOK;

CREATE OR REPLACE PACKAGE ONEDATA_WA.hook
AS
   TYPE t_row IS TABLE OF VARCHAR2 (32767)
      INDEX BY VARCHAR2 (30);
   TYPE t_rows IS TABLE OF t_row;
   FUNCTION geteventhookrow (DATA IN RAW)
      RETURN t_row;
   FUNCTION geteventhooktablename (DATA IN RAW)
      RETURN VARCHAR2;
   FUNCTION getcommandhookrows (DATA IN RAW)
      RETURN t_rows;
   FUNCTION getmultiselectcolumnrows (DATA IN VARCHAR2)
      RETURN t_rows;
   PROCEDURE TEST;
END;
/


DROP PACKAGE ONEDATA_WA.IHOOK;

CREATE OR REPLACE PACKAGE ONEDATA_WA.ihook
AS
   FUNCTION getcolumn (ROW IN t_row, columnname IN VARCHAR2)
      RETURN t_column;
   FUNCTION getcolumnvalue (ROW IN t_row, columnname IN VARCHAR2)
      RETURN VARCHAR2;
   FUNCTION getcolumnoldvalue (ROW IN t_row, columnname IN VARCHAR2)
      RETURN VARCHAR2;
   PROCEDURE setcolumnvalue (
      ROW           IN OUT   t_row,
      columnname    IN       VARCHAR2,
      columnvalue   IN       VARCHAR2
   );
   PROCEDURE setcolumnvalue (
      ROW           IN OUT   t_row,
      columnname    IN       VARCHAR2,
      columnvalue   IN       BLOB
   );
   PROCEDURE setcolumnvalue (
      ROW           IN OUT   t_row,
      columnname    IN       VARCHAR2,
      columnvalue   IN       CLOB
   );
   FUNCTION gethookinput (DATA IN CLOB)
      RETURN t_hookinput;
   FUNCTION gethookoutput (hookoutput IN t_hookoutput)
      RETURN CLOB;
   FUNCTION getmscolumnvalue (ROW IN t_row, columnname IN VARCHAR2)
      RETURN t_ms_values;
   FUNCTION getmscolumnoldvalue (ROW IN t_row, columnname IN VARCHAR2)
      RETURN t_ms_values;
   PROCEDURE setmscolumnvalue (
      ROW             IN OUT   t_row,
      columnname      IN       VARCHAR2,
      mscolumnvalue   IN       t_ms_values
   );
   PROCEDURE setmscolumnoldvalue (
      ROW             IN OUT   t_row,
      columnname      IN       VARCHAR2,
      mscolumnvalue   IN       t_ms_values
   );
END;
/


DROP PACKAGE ONEDATA_WA.LOGGING;

CREATE OR REPLACE PACKAGE ONEDATA_WA.LOGGING
AS
   PROCEDURE LOG (v_message_buffer IN OUT VARCHAR2, v_message IN VARCHAR2);
END;
/


DROP PACKAGE ONEDATA_WA.ME;

CREATE OR REPLACE PACKAGE ONEDATA_WA.me
AS
   FUNCTION getmatchingengineinput (
      v_hookinputxml             IN   CLOB,
      v_matchingengineinputxml   IN   CLOB
   )
      RETURN t_matchingengineinput;
   FUNCTION getmatchingengineinput (
      v_inputdatarow             IN   t_row,
      v_matchingengineinputxml   IN   CLOB
   )
      RETURN t_matchingengineinput;
   FUNCTION getquerylets (
      inputdatarow         IN   t_row,
      matchingenginerows   IN   xmldom.domnodelist
   )
      RETURN t_querylets;
   FUNCTION getsearchoptions (rootnode IN xmldom.domnode)
      RETURN t_searchoptions;
   FUNCTION getmatches (v_data_in IN t_matchingengineinput)
      RETURN t_matchingengineoutput;
   PROCEDURE addquerylet (querylets IN OUT t_querylets, querylet t_querylet);
END;
/


DROP PACKAGE ONEDATA_WA.METAMAP;

CREATE OR REPLACE PACKAGE ONEDATA_WA.MetaMap wrapped 
a000000
b2
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
9
6ea 1ca
x3aFok9d/cbR1g+/ZkGAVDzVQmwwg1W3Lq5qfHRAviUP7u+3nwZFtx5FTKJOa9tYj47N3ZAd
tQ+RLjkFBIS2trenhI2SEIaSUicH0kYd1j8QDx6ButZr3qbdQgxo6XKmr94h84Dw5gzCC3dA
gDx+NhzfPFz8aXw+HQUqed6gzc+AxMwYe3nLXJDHKPTXcErJfMywKfh25ezvYvitZ382wkG3
NFdAEIT3JnKBs3UsVReS4KZ1Yt9BXlCUnNion8SEVXYvC44S1wz5AmDYDI5sMbwkDiZAPPI5
tAjPY1fXEjv4c1twfYyozDzd3ayoVAkWX2zDNdkyST1VwY1eirWE6SFFGNXSoKK1VAFs2KpX
raHVM/rO7yc+qHfWwhBPNxf0P0mbpIRY3YfRxrhgPgGl3NKgC0UCYYfnhtj/uShJJNqNTLRK
5MY3R9bd6LpoEKZC0mOO


/


DROP PACKAGE ONEDATA_WA.MISC;

CREATE OR REPLACE PACKAGE ONEDATA_WA.misc
AS
/*
The following variables control debugging options of OneData packages.
Change the value to TRUE to enable debugging for the respective package.
*/
   debug_re   BOOLEAN := FALSE;
END;
/


DROP PACKAGE ONEDATA_WA.MMAP;

CREATE OR REPLACE PACKAGE ONEDATA_WA.mmap
AS
   FUNCTION callloaddata (
      v_user_id         IN   VARCHAR2,
      v_repository_id   IN   VARCHAR2,
      v_database_type   IN   VARCHAR2,
      v_client_id       IN   NUMBER,
      v_project_id      IN   NUMBER,
      v_schema_id       IN   NUMBER,
      rowset            IN   t_rowset,
      rmiregistryhost   IN   VARCHAR2,
      rmiregistryport   IN   VARCHAR2
   )
      RETURN VARCHAR2;
   PROCEDURE loaddata (
      v_data_in         IN       CLOB,
      rmiregistryhost   IN       VARCHAR2,
      rmiregistryport   IN       VARCHAR2,
      v_data_out        OUT      CLOB
   );
END;
/


DROP PACKAGE ONEDATA_WA.NCI_11179;

CREATE OR REPLACE PACKAGE ONEDATA_WA."NCI_11179" AS
function getWordCount(v_nm in varchar2) return integer;
function getWord(v_nm in varchar2, v_idx in integer, v_max in integer) return varchar2;
FUNCTION get_concepts(v_item_id in number, v_ver_nr in number) return varchar2;
 Function get_concept_order(v_item_id in number, v_ver_nr in number) return varchar2 ;
 function cmr_guid return varchar2;
 procedure spGetCartPin  ( hookoutput in out t_hookoutput,v_typ in char);

FUNCTION getPrimaryConceptName(v_nm in varchar2) return varchar2;
procedure spAddToCart ( v_data_in in clob, v_data_out out clob, v_user_id varchar2, v_src varchar2);
procedure spAddToCartGuest ( v_data_in in clob, v_data_out out clob);
procedure spRemoveFromCart (v_data_in in clob, v_data_out out clob, v_user_id varchar2);
procedure spNCIChangeLatestVer (v_data_in in clob, v_data_out out clob, v_usr_id  IN varchar2);
procedure spCreateCommonChildrenNCI (actions in out t_actions, v_from_item_id in number, v_from_ver_nr in number, v_to_item_id in number, v_to_ver_nr in number);
procedure spAddConceptRel (v_data_in in clob, v_data_out out clob);
procedure spCreateVerNCI (v_data_in in clob, v_data_out out clob, v_user_id varchar2);
procedure getConcatNmDef(v_item_id in number, v_ver_nr in number, v_nm out varchar2, v_long_nm out varchar2,v_def out varchar2);
procedure spCopyModuleNCI (actions in out t_actions, v_from_module_id in number,v_from_module_ver in number,  v_from_form_id in number, v_from_form_ver number, v_to_form_id number, v_to_form_ver number, v_disp_ord number, v_src in varchar2);
procedure spReturnSubtypeRow (v_item_id in number, v_ver_nr in number, v_type in number, row in out t_row);
procedure spReturnAIRow (v_item_id in number, v_ver_nr in number,  row in out t_row);
procedure spReturnAIExtRow (v_item_id in number, v_ver_nr in number,  row in out t_row);
procedure spReturnRow (v_item_id in number, v_ver_nr in number,  v_table_name in varchar2, row in out t_row);
procedure spReturnConceptRow (v_item_id in number, v_ver_nr in number, v_item_typ_id in integer, v_idx in integer, row in out t_row);
procedure spReturnRTConceptRow (v_item_id in number, v_ver_nr in number, v_item_typ_id in integer, v_idx in integer, row in out t_row);
function getItemId return integer;
procedure CncptCombExists (v_nm in varchar2, v_item_typ in integer, v_item_id out number, v_item_ver_nr out number, v_long_nm in out varchar2, v_def in out varchar2);
function replaceChar(v_str in varchar2) return varchar2;
procedure CopyPermVal (actions in out t_actions, v_from_id in number, v_from_ver_nr in number, v_to_id in number, v_to_ver_nr in number);
procedure ReturnRow (v_sql varchar2,  v_table_name in varchar2, row in out t_row);
/*  This package includes generic functions as well as versioning related procedures for NCI

geWordCOunt - gets the word count of a string separated by spaces. Used to parse the string the user provides in DEC creation
getWord - get the specific word in v_idx position from a string
cmr_guid - generatest he NCI_IDSEQ
spAddToCart , spRemoveFromCart - add selected administered Items to user cart - called from command hook
spAddToCartGuest - Add to cart for Guest user.
spNCIChangeLatestVer - Change latest version for a selected AI
spCreateVerNCI - Create new version customized

*/
END;
/


DROP PACKAGE ONEDATA_WA.NCI_11179_2;

CREATE OR REPLACE PACKAGE ONEDATA_WA.nci_11179_2 AS
procedure spNCICompareDE (v_data_in in clob, v_data_out out clob);
procedure spNCICompareVD (v_data_in in clob, v_data_out out clob);
procedure spNCIShowVMDependency (v_data_in in clob, v_data_out out clob);
procedure spNCIShowVMDependencyDS (v_data_in in clob, v_data_out out clob);
procedure spNCIShowVMDependencyComb (v_data_in in clob, v_data_out out clob);
function isUserAuth(v_item_id in number, v_ver_nr in number,v_user_id in varchar2) return boolean;
procedure spCheckUserAuth (v_data_in in clob, v_data_out out clob, v_user_id in varchar2);
procedure setStdAttr(row in out t_row);
procedure setItemLongNm(row in out t_row, v_id in number);
procedure stdAIValidation(rowai in t_row,  v_item_typ_id in number, v_valid in out boolean, v_err_str out varchar2);
procedure stdCncptRowValidation(rowcncpt in t_row, v_idx in number, v_valid in out boolean, v_err_str in out varchar2);
function getStdShortName (v_item_id in number, v_ver_nr in number) return varchar2;
function getStdDataType (v_data_typ_id in number) return number;
procedure copyDDEComponents (v_src_item_id in number, v_src_ver_nr in number, v_tgt_item_id in number, v_tgt_ver_nr in number, actions in out t_actions);
function getCollectionId return integer;
procedure spBulkUpdateContext (v_data_in in clob, v_data_out out clob, v_user_id in varchar2);
procedure spBulkUpdateCSI (v_data_in in clob, v_data_out out clob, v_user_id in varchar2);
function isCSParentCSIValid(row in t_row) return boolean;
procedure spAddAIToCartID (v_data_in in clob, v_data_out out clob, v_usr_id  IN varchar2);
END;
/


DROP PACKAGE ONEDATA_WA.NCI_CADSR_PULL;

CREATE OR REPLACE PACKAGE ONEDATA_WA.nci_caDSR_PULL AS
procedure sp_create_ai_1;
procedure sp_create_ai_2;
procedure sp_create_ai_3;
procedure sp_create_ai_4;
procedure sp_create_ai_children;
PROCEDURE            sp_create_ai_cncpt;
PROCEDURE            sp_create_csi;
procedure sp_create_csi_2;
procedure sp_migrate_lov ;
PROCEDURE            sp_create_form_ext;
PROCEDURE            sp_create_form_question_rel;
PROCEDURE            sp_create_form_rel;
PROCEDURE            sp_create_form_ta;
PROCEDURE            sp_create_form_vv_inst;
procedure            sp_create_form_vv_inst_2;
procedure            sp_create_form_vv_inst_new;
PROCEDURE            sp_create_pv;
PROCEDURE            sp_create_pv_2;
procedure            sp_migrate_change_log;
PROCEDURE spCreateNewNode;
procedure sp_quest_rep;
procedure sp_reorder_mod;
procedure sp_org_contact;
procedure sp_post_upd;
procedure sp_load_status;
function get_stus_mstr_id (STATUS_NAME VARCHAR2, STATUS_TYPE_ID number) return number;
function is_stus_mstr_exist (STATUS_NAME VARCHAR2, STATUS_TYPE_ID number) return varchar2;
procedure SP_SOURCE_TYPE;
  --    procedure sp_append_quest_pv;
END;
/


DROP PACKAGE ONEDATA_WA.NCI_CADSR_PUSH;

CREATE OR REPLACE PACKAGE ONEDATA_WA.nci_caDSR_push AS
 procedure spPushLov (vDays in Integer);
  procedure spPushAIChildren (vDays in integer);
  procedure spPushAISpecific (vDays in integer);
  procedure sp_create_csi (vDays in integer);
  function getShortDef(v_def in varchar2) return varchar;
END;
/


DROP PACKAGE ONEDATA_WA.NCI_CADSR_PUSH_CORE;

CREATE OR REPLACE PACKAGE ONEDATA_WA.nci_caDSR_push_core AS

procedure pushOC (vIdseq in char, vItemId in number, vVerNr in number, vActionType in char);
procedure pushProp (vIdseq in char, vItemId in number, vVerNr in number, vActionType in char);
procedure pushDE (vIdseq in char, vItemId in number, vVerNr in number, vActionType in char);
procedure pushDEC (vIdseq in char, vItemId in number, vVerNr in number, vActionType in char);
procedure pushConcept (vIdseq in char, vItemId in number, vVerNr in number, vActionType in char);
procedure pushVD (vIdseq in char, vItemId in number, vVerNr in number, vActionType in char);
procedure pushRC (vIdseq in char, vItemId in number, vVerNr in number, vActionType in char);
procedure pushCD (vIdseq in char, vItemId in number, vVerNr in number, vActionType in char);
procedure pushForm (vIdseq in char, vItemId in number, vVerNr in number, vActionType in char);
procedure pushProt (vIdseq in char, vItemId in number, vVerNr in number, vActionType in char);
procedure pushVM (vIdseq in char, vItemId in number, vVerNr in number, vActionType in char);
procedure pushOCRecs (vIdseq in char, vItemId in number, vVerNr in number, vActionType in char);
procedure pushCS (vIdseq in char, vItemId in number, vVerNr in number, vActionType in char);
procedure pushContext (vIdseq in char, vItemId in number, vVerNr in number, vActionType in char);
procedure pushCSI (vIdseq in char, vItemId in number, vVerNr in number, vActionType in char);
procedure pushCondr (vCondrIdseq in char, vItemId in number, vVerNr in number, vActionType in char);
procedure spPushAI (vDays in integer);
procedure spPushAIType (vDays in integer, v_typ in integer);
procedure spPushAIID (vItemId in number, vVerNr in number);
procedure pushAC (vIdseq in char, vItemId in number, vVerNr in number, vActionType in char);

END;
/


DROP PACKAGE ONEDATA_WA.NCI_CADSR_PUSH_FORM;

CREATE OR REPLACE PACKAGE ONEDATA_WA.nci_caDSR_push_form AS
procedure sp_create_form_vv (    vDays   IN INTEGER);
procedure PushModule (vDays in integer);
procedure PushQuestion(vDays in integer);
PROCEDURE            PushQuestValidValue (vDays in integer);

END;
/


DROP PACKAGE ONEDATA_WA.NCI_CHNG_MGMT;

CREATE OR REPLACE PACKAGE ONEDATA_WA.nci_chng_mgmt AS
v_temp_rep_ver_nr varchar2(10);
v_temp_rep_id VARCHAR2(10);

function getCSICreateQuestion(v_from in number) return t_question;
function getCSCreateQuestion return t_question;
procedure createAIWithConcept(rowform in out t_row, idx in integer,v_item_typ_id in integer, actions in out t_actions);
PROCEDURE spDEPrefQuestPost (v_data_in in clob, v_data_out out clob);
PROCEDURE spCreateDE (v_data_in in clob, v_data_out out clob, v_usr_id  IN varchar2, v_src in varchar2);
PROCEDURE spCreateCS (v_data_in in clob, v_data_out out clob, v_usr_id  IN varchar2);
PROCEDURE spDEValCreateImport (rowform in out t_row, v_op in varchar2, actions in out t_actions, v_val_ind in out boolean);
PROCEDURE spDECreateFrom ( v_data_in IN CLOB, v_data_out OUT CLOB, v_usr_id  IN varchar2);
--PROCEDURE spDECommon ( v_init_ai in t_rowset, v_init_st in t_rowset, v_op  in varchar2,  v_ori_rep_cls in number, hookInput in t_hookInput, hookOutput in out t_hookOutput);
PROCEDURE spClassification ( v_data_in IN CLOB, v_data_out OUT CLOB, v_usr_id  IN varchar2);
PROCEDURE spClassificationNMDef ( v_data_in IN CLOB, v_data_out OUT CLOB, v_usr_id  IN varchar2, v_typ in varchar2);
PROCEDURE spDesignateNew   ( v_data_in IN CLOB, v_data_out OUT CLOB, v_usr_id  IN varchar2);
PROCEDURE spUndesignate   ( v_data_in IN CLOB, v_data_out OUT CLOB, v_usr_id  IN varchar2);
PROCEDURE spClassifyUnclassify   ( v_data_in IN CLOB, v_data_out OUT CLOB, v_usr_id  IN varchar2);
PROCEDURE spShowClassificationNmDef   ( v_data_in IN CLOB, v_data_out OUT CLOB, v_usr_id  IN varchar2);
function getDECreateQuestion(v_from in number,v_first in boolean) return t_question;
function getDECreateForm (v_rowset1 in t_rowset, v_rowset2 in t_rowset) return t_forms;
function getCSICreateForm (v_rowset1 in t_rowset, v_rowset2 in t_rowset) return t_forms;
function getCSCreateForm (v_rowset1 in t_rowset, v_rowset2 in t_rowset) return t_forms;
procedure createDE (rowform in t_row, actions in out t_actions, v_id out number);
procedure spAddCSI ( v_data_in IN CLOB, v_data_out OUT CLOB, v_usr_id  IN varchar2);
procedure spEditCSI ( v_data_in IN CLOB, v_data_out OUT CLOB, v_usr_id  IN varchar2);
procedure spDeleteCSI ( v_data_in IN CLOB, v_data_out OUT CLOB, v_usr_id  IN varchar2);

function get_AI_id(P_ID NUMBER,P_VER in number) RETURN VARCHAR2;
END;
/


DROP PACKAGE ONEDATA_WA.NCI_DEC_MGMT;

CREATE OR REPLACE PACKAGE ONEDATA_WA.nci_DEC_MGMT AS

procedure valUsingStr (rowform in out t_row, k in integer, v_item_typ in integer) ;

-- Common procedure for all AI with concept.

procedure createValAIWithConcept(rowform in out t_row, idx in integer,v_item_typ_id in integer, v_mode in varchar2,v_cncpt_src in varchar2,  actions in out t_actions);
procedure createAIWithoutConcept(rowform in out t_row, idx in integer, v_item_typ_id in integer, v_long_nm in varchar2, v_desc in varchar2, actions in out t_actions);

-- New procedures for DEC Create, Create from Existing and Edit.

PROCEDURE spDECCreateNew (v_data_in in clob, v_data_out out clob);
PROCEDURE spDECCreateFrom (v_data_in in clob, v_data_out out clob);
PROCEDURE spDECEdit (v_data_in in clob, v_data_out out clob, v_usr_id  IN varchar2);

-- Common procedure called by new, create from existing or edit

procedure spDECCommon ( v_init in t_rowset, v_init_cncpt in t_rowset, v_op  in varchar2, v_src in integer, hookInput in t_hookInput, hookOutput in out t_hookOutput);

--Used in Import  v_op - 'V'  validate, 'C' create
procedure spDECValCreateImport ( rowform in out t_row,  v_op  in varchar2, actions in out t_actions, v_val_ind in out boolean);

procedure CncptCombExistsNew (rowform in out t_row, v_item_nm in varchar2, v_item_typ in integer, v_idx in number, v_item_id out number, v_item_ver_nr out number);
-- use getDECQUestion with INSERT or UPDATE as the v_op
function getDECCreateQuestion (v_src in integer) return t_question;
function getDECEditQuestion return t_question;
function getDECQuestion (v_op in varchar2, v_src in integer) return t_question;


procedure createDEC (rowai in t_row, rowform in t_row, actions in out t_actions, v_id out number);

procedure createDECImport (rowform in out t_row, actions in out t_actions);

-- Get the form for DEC Create
function getDECCreateForm (v_rowset1 in t_rowset, v_rowset2 in t_rowset) return t_forms;

procedure spBulkUpdateDEC ( v_data_in IN CLOB,    v_data_out OUT CLOB,    v_usr_id  IN varchar2);

END;
/


DROP PACKAGE ONEDATA_WA.NCI_DLOAD;

CREATE OR REPLACE PACKAGE ONEDATA_WA.nci_dload AS
  procedure spCreateDloadProfile (v_data_in in clob, v_data_out out clob, v_usr_id  IN varchar2);
  procedure spCreateDloadProfileGuest (v_data_in in clob, v_data_out out clob, v_usr_id  IN varchar2);
  procedure spEditDloadProfileGuest (v_data_in in clob, v_data_out out clob, v_usr_id  IN varchar2);
  procedure spTriggerDload (v_data_in in clob, v_data_out out clob, v_usr_id  IN varchar2);
  procedure spAddComponentToDload (v_data_in in clob, v_data_out out clob, v_usr_id  IN varchar2);
   procedure spAddComponentToDloadID (v_data_in in clob, v_data_out out clob, v_usr_id  IN varchar2);
   procedure spAddComponentToDloadIDGuest (v_data_in in clob, v_data_out out clob, v_usr_id  IN varchar2);
   function getAddComponentCreateQuestion return t_question;
function getALSCreateQuestion (v_typ in integer) return t_question;
function getALSCreateForm (v_rowset1 in t_rowset, v_rowset2 in t_rowset, v_dload_typ in integer) return t_forms;
function getCollectionCreateFormGuest (v_rowset1 in t_rowset, v_rowset2 in t_rowset, v_dload_typ in integer) return t_forms;
procedure spDeleteDloadItem  ( v_data_in IN CLOB, v_data_out OUT CLOB, v_usr_id  IN varchar2);
procedure spDeleteDloadItemGuest  ( v_data_in IN CLOB, v_data_out OUT CLOB, v_usr_id  IN varchar2);
function validatePin(v_hdr_id in number, v_pin in number) return boolean;
END;
/


DROP PACKAGE ONEDATA_WA.NCI_DS;

CREATE OR REPLACE PACKAGE ONEDATA_WA.nci_ds AS
  PROCEDURE            spDSRuleEnum;
  PROCEDURE            spDSRuleNonEnum;
  procedure spDSRun ( v_data_in in clob, v_data_out out clob);
END;
/


DROP PACKAGE ONEDATA_WA.NCI_FORM_MGMT;

CREATE OR REPLACE PACKAGE ONEDATA_WA.nci_form_mgmt AS
procedure spAddForm (v_data_in in clob, v_data_out out clob);
procedure spAddFormFromExisting (v_data_in in clob, v_data_out out clob);
procedure spAddModule (v_data_in in clob, v_data_out out clob, v_user_id in varchar2);
procedure spAddSAModule (v_data_in in clob, v_data_out out clob, v_user_id in varchar2);
procedure spEditModule (v_data_in in clob, v_data_out out clob, v_user_id in varchar2);
procedure spAddQuestion (v_data_in in clob, v_data_out out clob,  v_user_id in varchar2);
procedure spCopyModule (v_data_in in clob, v_data_out out clob,  v_user_id in varchar2);
function isUserAuth(v_frm_item_id in number, v_frm_ver_nr in number,v_user_id in varchar2) return boolean  ;
procedure spSetModRep (v_data_in in clob, v_data_out out clob,  v_user_id in varchar2);
procedure spChngQuestText (v_data_in in clob, v_data_out out clob,  v_user_id in varchar2);
procedure spChngQuestShortText (v_data_in in clob, v_data_out out clob,  v_user_id in varchar2);
procedure spSetDefltVal (v_data_in in clob, v_data_out out clob,  v_user_id in varchar2);
procedure spAddQuestionNoDE (v_data_in in clob, v_data_out out clob,  v_user_id in varchar2);
procedure spChngQuestTextVV (v_data_in in clob, v_data_out out clob,  v_user_id in varchar2);
procedure spChngQuestDefVV (v_data_in in clob, v_data_out out clob,  v_user_id in varchar2);
procedure spAddQuestionRep (rep in integer, row_ori in t_row, rows in out t_rows);
procedure spAddQuestionID (v_data_in in clob, v_data_out out clob, v_usr_id  IN varchar2);
procedure spAddQuestionRepNew (rep in integer, v_quest_id in integer, rows in out t_rows);
PROCEDURE spQuestRemoveDE ( v_data_in IN CLOB, v_data_out OUT CLOB, v_usr_id  IN varchar2);
procedure spDelModRep  ( v_data_in IN CLOB, v_data_out OUT CLOB, v_usr_id  IN varchar2);
procedure spDeleteQuestVV  ( v_data_in IN CLOB, v_data_out OUT CLOB, v_usr_id  IN varchar2);
procedure spAddQuestVV  ( v_data_in IN CLOB, v_data_out OUT CLOB, v_usr_id  IN varchar2);
procedure spDelDefltVal (v_data_in in clob, v_data_out out clob,  v_user_id in varchar2);
procedure spReorderModule (v_data_in in clob, v_data_out out clob,  v_user_id in varchar2);
procedure spResetOrderModule (v_data_in in clob, v_data_out out clob,  v_user_id in varchar2);
procedure spReorderQuest (v_data_in in clob, v_data_out out clob,  v_user_id in varchar2);
procedure spResetOrderQuest (v_data_in in clob, v_data_out out clob,  v_user_id in varchar2);
procedure spReorderQuestVV (v_data_in in clob, v_data_out out clob,  v_user_id in varchar2);
procedure spResetOrderQuestVV (v_data_in in clob, v_data_out out clob,  v_user_id in varchar2);
function getReorderForm  return t_forms ;
function getReorderQuestion (v_cur_disp_ord in integer) return t_question;
END;
/


DROP PACKAGE ONEDATA_WA.NCI_IMPORT;

CREATE OR REPLACE PACKAGE ONEDATA_WA.nci_import AS
procedure spValCDEImport (v_data_in in clob, v_data_out out clob, v_usr_id in varchar2);
procedure spCreateCDEImport (v_data_in in clob, v_data_out out clob, v_usr_id in varchar2);
procedure spPostCDEImport (v_data_in in clob, v_data_out out clob, v_usr_id in varchar2);
procedure spValPVVMImport (v_data_in in clob, v_data_out out clob, v_usr_id in varchar2);
procedure spCreatePVVMImport (v_data_in in clob, v_data_out out clob, v_usr_id in varchar2);
procedure spPostPVVMImport (v_data_in in clob, v_data_out out clob, v_usr_id in varchar2);
procedure spPVVMValidate (row_ori in out t_row);

END;

/


DROP PACKAGE ONEDATA_WA.NCI_POST_HOOK;

CREATE OR REPLACE PACKAGE ONEDATA_WA.nci_post_hook AS

procedure spRefDocInsUpd ( v_data_in in clob, v_data_out out clob, v_user_id varchar2);
procedure spAISTUpd ( v_data_in in clob, v_data_out out clob, v_usr_id varchar2);
procedure spAISTIns ( v_data_in in clob, v_data_out out clob);
procedure spDervCompIns ( v_data_in in clob, v_data_out out clob, v_user_id varchar2);
procedure spModRestore ( v_data_in in clob, v_data_out out clob, v_user_id varchar2, v_mode in varchar2);
procedure spQuestRestore ( v_data_in in clob, v_data_out out clob, v_user_id varchar2, v_mode in varchar2);
procedure spQuestVVRestore ( v_data_in in clob, v_data_out out clob, v_user_id varchar2, v_mode in varchar2);
procedure spAIIns ( v_data_in in clob, v_data_out out clob);
procedure spPVUpd ( v_data_in in clob, v_data_out out clob, v_user_id varchar2);
procedure spCSIUpd ( v_data_in in clob, v_data_out out clob, v_user_id varchar2);


END;
/


DROP PACKAGE ONEDATA_WA.NCI_PV_VM;

CREATE OR REPLACE PACKAGE ONEDATA_WA.nci_PV_VM AS

PROCEDURE spPVVMCreateNew (v_data_in in clob, v_data_out out clob, v_usr_id  IN varchar2);
PROCEDURE spPVVMCreateNew2 (v_data_in in clob, v_data_out out clob, v_usr_id  IN varchar2);
PROCEDURE spPVVMCreateNewBulk (v_data_in in clob, v_data_out out clob, v_usr_id  IN varchar2);
PROCEDURE spVMEdit (v_data_in in clob, v_data_out out clob, v_usr_id  IN varchar2);
PROCEDURE spVMCreateEdit (v_data_in in clob, v_data_out out clob, v_usr_id  IN varchar2);

procedure spPVVMCommon ( v_init in t_rowset,  v_op  in varchar2, hookInput in t_hookInput, hookOutput in out t_hookOutput);
procedure spPVVMCommon2 ( v_init_rows in t_rows,  v_op  in varchar2, hookInput in t_hookInput, hookOutput in out t_hookOutput);
procedure spPVVMImport ( row_ori in out t_row,actions in out t_actions);
procedure createPVVMBulk ( rowform in t_row,  hookInput in t_hookInput, hookOutput in out t_hookOutput);

procedure setDefaultParamPVVM (row_ori in t_row, row in out t_row);
procedure setDefaultParamPVVM2 (row_ori in t_row, row in out t_row);
procedure chkPVVMActionValid ( row_ori in t_row, v_usr_id in varchar2);


function getPVVMQuestion return t_question;
function getVMEditQuestion (v_src_tbl_nm in varchar2, v_dup in boolean) return t_question;
function getVMCreateEditQuestion (v_src_tbl_nm in varchar2) return t_question;
function getPVVMQuestionBulk return t_question;
function getPVVMCreateFormBulk (v_rowset in t_rowset) return t_forms;


function getPVVMCreateForm (v_rowset in t_rowset) return t_forms;
function getPVVMCreateForm2 (v_init_rows in t_rows) return t_forms;
function getVMEditForm (v_rowset in t_rowset) return t_forms;
function getVMCreateEditForm (v_rowset in t_rowset) return t_forms;
procedure VMEditCore ( v_init in t_rowset,  hookInput in t_hookInput, hookOutput in out t_hookOutput);
procedure VMCreateEditCore ( v_init in t_rowset,  hookInput in t_hookInput, hookOutput in out t_hookOutput);

procedure createVMConcept (rowform in out t_row, v_cncpt_src in varchar2, v_mode in varchar2,  actions in out t_actions);

END;
/


DROP PACKAGE ONEDATA_WA.NCI_UTIL;

CREATE OR REPLACE PACKAGE ONEDATA_WA.nci_util AS
procedure debugHook ( v_param_val in varchar2, v_data_out in clob);
END;
/


DROP PACKAGE ONEDATA_WA.NCI_VD;

CREATE OR REPLACE PACKAGE ONEDATA_WA.nci_vd AS
  function getVDCreateForm (v_rowset1 in t_rowset,v_rowset2 in t_rowset) return t_forms;
  function getVDcreateQuestion(v_first in Boolean,V_from in number) return t_question;
  procedure createVD(rowai in t_row, rowvd in t_row, actions in out t_actions, v_id out  number);
  procedure createSA(rowai in t_row, rowcncpt in t_row, v_item_typ_id in integer, actions in out t_actions, v_id out  number);
  procedure spVDCommon ( v_init_ai in t_rowset,v_init_vd in t_rowset,v_from in number,  v_op  in varchar2,  hookInput in t_hookInput, hookOutput in out t_hookOutput);
  PROCEDURE spVDCreateNew (v_data_in in clob, v_data_out out clob);
    procedure createValAIWithConcept(rowform in out t_row,   idx in integer,v_item_typ_id in integer, v_mode in varchar2,v_cncpt_src in varchar2,  actions in out t_actions);
  PROCEDURE spVDCreateFrom (v_data_in in clob, v_data_out out clob);
 PROCEDURE spVDEdit (v_data_in in clob, v_data_out out clob, v_usr_id in varchar2);
---  PROCEDURE spVDEdit (v_data_in in clob, v_data_out out clob, v_usr_id  IN varchar2);
 PROCEDURE spCreateRTSA (v_data_in in clob, v_data_out out clob, v_usr_id in varchar2);
 PROCEDURE spCreateVMSA (v_data_in in clob, v_data_out out clob, v_usr_id in varchar2);
 procedure SACommonRT ( v_init_ai in t_rowset,  v_item_typ_id in integer, hookInput in t_hookInput, hookOutput in out t_hookOutput);
 procedure SACommonVM ( v_init_ai in t_rowset,  v_item_typ_id in integer, hookInput in t_hookInput, hookOutput in out t_hookOutput);
  function getSACreateQuestion(v_first in Boolean,v_item_typ_id in integer) return t_question;
  function getSACreateForm (v_rowset1 in t_rowset,v_rowset2 in t_rowset,v_item_typ_id in integer) return t_forms;

procedure spVDValCreateImport ( rowform in out t_row , v_op  in varchar2, actions in out t_actions,  v_val_ind in out boolean);
  procedure createVDImport(rowform in out t_row, actions in out t_actions);

END;
/


DROP PACKAGE ONEDATA_WA.RE;

CREATE OR REPLACE PACKAGE ONEDATA_WA.re
AS
   eval   BOOLEAN;
   PROCEDURE firerulesengine (in_xml IN CLOB, out_xml OUT CLOB);
END;
/


DROP PACKAGE ONEDATA_WA.TEMPLATE_11179;

CREATE OR REPLACE PACKAGE ONEDATA_WA.template_11179 AS

procedure spChangeStatus (v_stus_typ_id number, v_to_stus_id number, v_data_in in clob, v_data_out out clob, v_user_id varchar2);
procedure spCreateVer (v_data_in in clob, v_data_out out clob, v_user_id varchar2, v_params in varchar2);
procedure spShowValueMeaningDependency (v_data_in in clob, v_data_out out clob);
procedure spShowVMDependencyLimit (v_data_in in clob, v_data_out out clob, v_Mode in number);
procedure spPreHookCheckDE (a_table_name in varchar2, a_transaction_type in varchar2, a_data in raw, a_user in varchar2);
function getParsedAdminItemsData (originalRowset in t_actionRowset) return tab_admin_item_pk;
function getColumnCount(v_table_name in varchar2) return number;
function getSelectSql(v_table_name in varchar2) return varchar2;


END;
/


GRANT EXECUTE ON ONEDATA_WA.NCI_11179 TO ONEDATA_RO;

DROP PACKAGE BODY ONEDATA_WA.DQ;

CREATE OR REPLACE PACKAGE BODY ONEDATA_WA.dq
AS
   FUNCTION getdqconfiguration (dqconfigsettinglist IN xmldom.domnodelist)
      RETURN t_dqconfig
   AS
      dqconfigsetting       t_dqconfigsetting;
      dqconfig              t_dqconfig;
      dqconfigsettingnode   xmldom.domnode;
   BEGIN
      dqconfig := t_dqconfig ();
      FOR settingcount IN 0 .. xmldom.getlength (dqconfigsettinglist) - 1
      LOOP
         dqconfigsettingnode :=
                              xmldom.item (dqconfigsettinglist, settingcount);
         dqconfigsetting :=
            t_dqconfigsetting (xslprocessor.valueof (dqconfigsettingnode,
                                                     '@id'
                                                    ),
                               xslprocessor.valueof (dqconfigsettingnode, '.')
                              );
         dqconfig.EXTEND;
         dqconfig (dqconfig.LAST) := dqconfigsetting;
      END LOOP;
      RETURN dqconfig;
   END;
   FUNCTION getdqattributemappings (v_attributemappings IN xmldom.domnodelist)
      RETURN t_dqattributemappings
   AS
      attributemapping     t_dqattributemapping;
      attributemappings    t_dqattributemappings;
      v_attributemapping   xmldom.domnode;
      attributetype        NUMBER;
      dqattribute          VARCHAR2 (256);
      objectattribute      VARCHAR2 (256);
      objectid             NUMBER;
      goldobjectid         NUMBER;
      goldattribute        VARCHAR2 (256);
      iswindowkey          NUMBER;
   BEGIN
      attributemappings := t_dqattributemappings ();
      FOR ROWCOUNT IN 0 .. xmldom.getlength (v_attributemappings) - 1
      LOOP
         v_attributemapping := xmldom.item (v_attributemappings, ROWCOUNT);
         attributetype :=
            xslprocessor.valueof (v_attributemapping,
                                  'DataQualityAttributeType'
                                 );
         dqattribute :=
             xslprocessor.valueof (v_attributemapping, 'DataQualityAttribute');
         objectattribute :=
                  xslprocessor.valueof (v_attributemapping, 'ObjectAttribute');
         objectid := xslprocessor.valueof (v_attributemapping, 'ObjectId');
         goldobjectid :=
                     xslprocessor.valueof (v_attributemapping, 'GoldObjectId');
         goldattribute :=
                    xslprocessor.valueof (v_attributemapping, 'GoldAttribute');
         iswindowkey := xslprocessor.valueof (v_attributemapping, 'WindowKey');
         attributemapping :=
            t_dqattributemapping (attributetype,
                                  dqattribute,
                                  objectattribute,
                                  objectid,
                                  goldattribute,
                                  goldobjectid,
                                  iswindowkey
                                 );
         adddqattributemapping (attributemappings, attributemapping);
      END LOOP;
      RETURN attributemappings;
   END;
   FUNCTION getdqinput (v_inputdatarowset IN t_rowset, v_dqinputxml IN CLOB)
      RETURN t_dqinput
   AS
      dqinput            t_dqinput;
      dqconfig           t_dqconfig;
      inputattributes    t_dqattributemappings;
      outputattributes   t_dqattributemappings;
      parser             xmlparser.parser;
      xmldoc             xmldom.domdocument;
      rootnode           xmldom.domnode;
   BEGIN
      parser := xmlparser.newparser;
      xmlparser.parseclob (parser, v_dqinputxml);
      xmldoc := xmlparser.getdocument (parser);
      xmlparser.freeparser (parser);
      rootnode := xmldom.makenode (xmldoc);
      dqconfig :=
         getdqconfiguration
            (xslprocessor.selectnodes
                (rootnode,
                 '/OnedataDataQualityHookInput/DataQualityConfiguration/ConfigurationSetting'
                )
            );
      inputattributes :=
         getdqattributemappings
            (xslprocessor.selectnodes
                (rootnode,
                 '/OnedataDataQualityHookInput/DataQualityInputAttributes/DataQualityAttributeMapping'
                )
            );
      outputattributes :=
         getdqattributemappings
            (xslprocessor.selectnodes
                (rootnode,
                 '/OnedataDataQualityHookInput/DataQualityOutputAttributes/DataQualityAttributeMapping'
                )
            );
      dqinput :=
         t_dqinput (dqconfig,
                    inputattributes,
                    outputattributes,
                    v_inputdatarowset
                   );
      xmldom.freedocument (xmldoc);
      RETURN dqinput;
   END;
   PROCEDURE adddqattributemapping (
      attributemappings   IN OUT   t_dqattributemappings,
      attributemapping             t_dqattributemapping
   )
   AS
   BEGIN
      attributemappings.EXTEND;
      attributemappings (attributemappings.LAST) := attributemapping;
   END;
   FUNCTION cleanse (dqinput IN t_dqinput)
      RETURN t_rowset
   AS
      LANGUAGE JAVA
      NAME 'com.datafoundations.onedata.dataquality.DataQualityServiceHandler.cleanse(oracle.sql.STRUCT) return oracle.sql.STRUCT';
   FUNCTION match (
      inputrowset         IN   t_rowset,
      dqinput             IN   t_dqinput,
      matchwindowrowset   IN   t_rowset
   )
      RETURN t_rowset
   AS
      LANGUAGE JAVA
      NAME 'com.datafoundations.onedata.dataquality.DataQualityServiceHandler.match(oracle.sql.STRUCT,oracle.sql.STRUCT,oracle.sql.STRUCT) return oracle.sql.STRUCT';
   FUNCTION generatematchwindowandmatch (
      inputrowset   IN   t_rowset,
      dqinput       IN   t_dqinput
   )
      RETURN t_rowset
   AS
      LANGUAGE JAVA
      NAME 'com.datafoundations.onedata.dataquality.DataQualityServiceHandler.generateMatchWindowAndMatch(oracle.sql.STRUCT,oracle.sql.STRUCT) return oracle.sql.STRUCT';
   FUNCTION generatematchwindowandmatch (
      inputrowset           IN   t_rowset,
      dqinput               IN   t_dqinput,
      enableresultsorting   IN   VARCHAR2
   )
      RETURN t_rowset
   AS
      LANGUAGE JAVA
      NAME 'com.datafoundations.onedata.dataquality.DataQualityServiceHandler.generateMatchWindowAndMatch(oracle.sql.STRUCT,oracle.sql.STRUCT,java.lang.String) return oracle.sql.STRUCT';
   FUNCTION manualmatch (
      dqinput         IN   t_dqinput,
      objectid        IN   NUMBER,
      inputrowset     IN   t_rowset,
      actionpattern   IN   VARCHAR2,
      goldobjectid    IN   NUMBER,
      goldrowset      IN   t_rowset
   )
      RETURN t_dqcdiresult
   AS
      LANGUAGE JAVA
      NAME 'com.datafoundations.onedata.dataquality.DataQualityServiceHandler.manualMatch(oracle.sql.STRUCT,java.lang.Integer,oracle.sql.STRUCT,java.lang.String,java.lang.Integer,oracle.sql.STRUCT) return oracle.sql.ARRAY';
   FUNCTION automatch (cleansedrowset IN t_rowset, dqinput IN t_dqinput)
      RETURN VARCHAR2
   AS
      LANGUAGE JAVA
      NAME 'com.datafoundations.onedata.dataquality.DataQualityServiceHandler.autoMatch(oracle.sql.STRUCT,oracle.sql.STRUCT) return java.lang.String';
   FUNCTION unmerge (cleansedrowset IN t_rowset, dqinput IN t_dqinput)
      RETURN VARCHAR2
   AS
      LANGUAGE JAVA
      NAME 'com.datafoundations.onedata.dataquality.DataQualityServiceHandler.unmergeGoldRecord(oracle.sql.STRUCT,oracle.sql.STRUCT) return java.lang.String';
   FUNCTION getdqinputforcleanserasxml (
      v_user_id           IN   VARCHAR2,
      v_repository_id     IN   VARCHAR2,
      v_database_type     IN   VARCHAR2,
      v_client_id         IN   NUMBER,
      v_project_id        IN   NUMBER,
      v_schema_id         IN   NUMBER,
      v_rmiregistryhost   IN   VARCHAR2,
      v_rmiregistryport   IN   VARCHAR2,
      v_object_name       IN   VARCHAR2
   )
      RETURN VARCHAR2
   AS
      LANGUAGE JAVA
      NAME 'com.datafoundations.onedata.dataquality.DataQualityServiceHandler.getDataQualityInputAsXMLForCleanser(java.lang.String,java.lang.String,java.lang.String,oracle.sql.NUMBER,oracle.sql.NUMBER,oracle.sql.NUMBER,java.lang.String,java.lang.String,java.lang.String) return java.lang.String';
   FUNCTION getdqinputformatcherasxml (
      v_user_id           IN   VARCHAR2,
      v_repository_id     IN   VARCHAR2,
      v_database_type     IN   VARCHAR2,
      v_client_id         IN   NUMBER,
      v_project_id        IN   NUMBER,
      v_schema_id         IN   NUMBER,
      v_rmiregistryhost   IN   VARCHAR2,
      v_rmiregistryport   IN   VARCHAR2,
      v_object_name       IN   VARCHAR2
   )
      RETURN VARCHAR2
   AS
      LANGUAGE JAVA
      NAME 'com.datafoundations.onedata.dataquality.DataQualityServiceHandler.getDataQualityInputAsXMLForMatcher(java.lang.String,java.lang.String,java.lang.String,oracle.sql.NUMBER,oracle.sql.NUMBER,oracle.sql.NUMBER,java.lang.String,java.lang.String,java.lang.String) return java.lang.String';
   FUNCTION getdqinputforcleanser (
      v_user_id           IN   VARCHAR2,
      v_repository_id     IN   VARCHAR2,
      v_database_type     IN   VARCHAR2,
      v_client_id         IN   NUMBER,
      v_project_id        IN   NUMBER,
      v_schema_id         IN   NUMBER,
      v_rmiregistryhost   IN   VARCHAR2,
      v_rmiregistryport   IN   VARCHAR2,
      v_object_name       IN   VARCHAR2
   )
      RETURN t_dqinput
   AS
      dqinput   t_dqinput;
   BEGIN
      dqinput :=
         getdqinput (NULL,
                     getdqinputforcleanserasxml (v_user_id,
                                                 v_repository_id,
                                                 v_database_type,
                                                 v_client_id,
                                                 v_project_id,
                                                 v_schema_id,
                                                 v_rmiregistryhost,
                                                 v_rmiregistryport,
                                                 v_object_name
                                                )
                    );
      RETURN dqinput;
   END;
   FUNCTION getdqinputformatcher (
      v_user_id           IN   VARCHAR2,
      v_repository_id     IN   VARCHAR2,
      v_database_type     IN   VARCHAR2,
      v_client_id         IN   NUMBER,
      v_project_id        IN   NUMBER,
      v_schema_id         IN   NUMBER,
      v_rmiregistryhost   IN   VARCHAR2,
      v_rmiregistryport   IN   VARCHAR2,
      v_object_name       IN   VARCHAR2
   )
      RETURN t_dqinput
   AS
      dqinput   t_dqinput;
   BEGIN
      dqinput :=
         getdqinput (NULL,
                     getdqinputformatcherasxml (v_user_id,
                                                v_repository_id,
                                                v_database_type,
                                                v_client_id,
                                                v_project_id,
                                                v_schema_id,
                                                v_rmiregistryhost,
                                                v_rmiregistryport,
                                                v_object_name
                                               )
                    );
      RETURN dqinput;
   END;
   PROCEDURE match (
      v_data_in       IN       CLOB,
      v_match_input   IN       CLOB,
      v_data_out      OUT      CLOB,
      v_match_mode    IN       NUMBER
   )
   AS
      hookinput               t_hookinput;
      hookoutput              t_hookoutput     := t_hookoutput ();
      row_ori                 t_row;
      dqmatcherinput          t_dqinput;
      matchededrowset         t_rowset;
      matchedshowablerowset   t_showablerowset;
      answers                 t_answers;
      ans_create              t_answer;
      ans_associate           t_answer;
      question                t_question;
      cdiresult               t_dqcdiresult;
      actionpattern           VARCHAR2 (100);
   BEGIN
      hookinput := ihook.gethookinput (v_data_in);
      hookoutput.invocationnumber := hookinput.invocationnumber;
      row_ori := hookinput.originalrowset.rowset (1);
      IF hookinput.invocationnumber = 0
      THEN
         dqmatcherinput :=
                         getdqinput (hookinput.originalrowset, v_match_input);
      END IF;
      IF v_match_mode = 4
      THEN
         hookoutput.originalrowset := hookinput.originalrowset;
         hookoutput.MESSAGE :=
                      dq.automatch (hookinput.originalrowset, dqmatcherinput);
      ELSIF v_match_mode = 5
      THEN
         IF hookinput.invocationnumber = 0
         THEN
            hookoutput.originalrowset := hookinput.originalrowset;
            matchededrowset :=
               generatematchwindowandmatch (hookinput.originalrowset,
                                            dqmatcherinput,
                                            'true'
                                           );
            matchedshowablerowset :=
                   t_showablerowset (matchededrowset.rowset, ' ', 4, 'single');
            hookoutput.showrowset := matchedshowablerowset;
            answers := t_answers ();
            ans_create := t_answer (1, 1, 'Create');
            answers.EXTEND;
            answers (answers.LAST) := ans_create;
            ans_associate := t_answer (2, 2, 'Associate');
            answers.EXTEND;
            answers (answers.LAST) := ans_associate;
            question :=
               t_question
                  ('Click on "Create" to create an entry in gold table else click on "Associate" by selecting one record to link',
                   answers
                  );
            hookoutput.question := question;
         ELSIF hookinput.invocationnumber = 1
         THEN
            IF hookinput.answerid = 1
            THEN
               actionpattern := 'create';
            ELSIF hookinput.answerid = 2
            THEN
               actionpattern := 'associate';
            END IF;
            dqmatcherinput :=
                          getdqinput (hookinput.originalrowset, v_match_input);
            cdiresult :=
               manualmatch
                          (dqmatcherinput,
                           dqmatcherinput.inputattribute (1).onedata_object_id,
                           hookinput.originalrowset,
                           actionpattern,
                           dqmatcherinput.inputattribute (1).gold_object_id,
                           hookinput.selectedrowset
                          );
            hookoutput.originalrowset := hookinput.originalrowset;
            hookoutput.MESSAGE := cdiresult (2);
         END IF;
      ELSIF v_match_mode = 6
      THEN
         hookoutput.originalrowset := hookinput.originalrowset;
         hookoutput.MESSAGE :=
                        dq.unmerge (hookinput.originalrowset, dqmatcherinput);
      END IF;
      v_data_out := ihook.gethookoutput (hookoutput);
   END;
   PROCEDURE cleanse (
      v_data_in         IN       CLOB,
      v_cleanse_input   IN       CLOB,
      v_data_out        OUT      CLOB
   )
   AS
      hookinput                t_hookinput;
      hookoutput               t_hookoutput     := t_hookoutput ();
      dqcleanserinput          t_dqinput;
      cleansedrowset           t_rowset;
      cleansedshowablerowset   t_showablerowset;
      answers                  t_answers;
      ans_update               t_answer;
      question                 t_question;
      actions                  t_actions        := t_actions ();
      action                   t_actionrowset;
   BEGIN
      hookinput := ihook.gethookinput (v_data_in);
      hookoutput.invocationnumber := hookinput.invocationnumber;
      hookoutput.originalrowset := hookinput.originalrowset;
      IF hookinput.invocationnumber = 0
      THEN
         dqcleanserinput :=
                       getdqinput (hookinput.originalrowset, v_cleanse_input);
         cleansedrowset := dq.cleanse (dqcleanserinput);
         cleansedshowablerowset :=
                    t_showablerowset (cleansedrowset.rowset, ' ', 4, 'multi');
         hookoutput.showrowset := cleansedshowablerowset;
         answers := t_answers ();
         ans_update := t_answer (1, 1, 'Update');
         answers.EXTEND;
         answers (answers.LAST) := ans_update;
         question :=
             t_question ('Select the records and click ''Update''.', answers);
         hookoutput.question := question;
      ELSIF hookinput.invocationnumber = 1
      THEN
         IF hookinput.answerid = 1
         THEN
            action :=
               t_actionrowset (hookinput.selectedrowset.rowset,
                               hookinput.originalrowset.objectname,
                               hookinput.originalrowset.objecttype,
                               0,
                               'update'
                              );
            actions.EXTEND;
            actions (actions.LAST) := action;
            hookoutput.actions := actions;
            hookoutput.MESSAGE := 'Update Completed Successfully';
         END IF;
      END IF;
      v_data_out := ihook.gethookoutput (hookoutput);
   END;
END;
/


DROP PACKAGE BODY ONEDATA_WA.HIER;

CREATE OR REPLACE PACKAGE BODY ONEDATA_WA.hier
AS
/*
ASSUMPTIONS
- main table: has a two-column PK
- main table: first column in PK(FK) is ID, second is version
- link table: has a three-column PK
- link table: first column in PK is ID(main table), second is version(main table), third is ID(child table)
FOR self-recursive
- main table -(0..n)> link table -(1)> child table
FOR network-recursive
- main table -(0..n)> link table -(1)> child table
                          > nr relation table
- nr table: single-column surrogate PK
- nr table: first column in nr1(nr2) is ID, second is version
*/
   structure_type_sr   NUMBER   := 1;
   structure_type_nr   NUMBER   := 2;
   structuretype       NUMBER;
   TYPE t_columns IS TABLE OF VARCHAR2 (30);
   TYPE t_tablenr IS RECORD (
      NAME         VARCHAR2 (30),
      pkcolumn     VARCHAR2 (30),
      nr1columns   t_columns     := t_columns (),
      nr2columns   t_columns     := t_columns ()
   );
   TYPE t_table3 IS RECORD (
      NAME                VARCHAR2 (30),
      descriptioncolumn   VARCHAR2 (30),
      pkcolumns           t_columns     := t_columns ()
   );
   TYPE t_table2 IS RECORD (
      NAME         VARCHAR2 (30),
      pkcolumns    t_columns     := t_columns (),
      childtable   t_table3
   );
   TYPE t_tables2 IS TABLE OF t_table2;
   TYPE t_table1 IS RECORD (
      NAME                VARCHAR2 (30),
      descriptioncolumn   VARCHAR2 (30),
      pkcolumns           t_columns     := t_columns (),
      fkcolumns           t_columns     := t_columns (),    -- self-recursive
      nrrelationtable     t_tablenr,                     -- network-recursive
      childtables         t_tables2     := t_tables2 ()
   );
   maintable           t_table1;
   maintablenull       t_table1;
   PROCEDURE initmetadata (metadata IN CLOB)
   AS
      parser            xmlparser.parser;
      xmldoc            xmldom.domdocument;
      rootnode          xmldom.domnode;
      node              xmldom.domnode;
      linktables        xmldom.domnodelist;
      nrrelationtable   t_tablenr;
      linktable         t_table2;
      childtable        t_table3;
   BEGIN
      parser := xmlparser.newparser;
      xmlparser.parseclob (parser, metadata);
      xmldoc := xmlparser.getdocument (parser);
      xmlparser.freeparser (parser);
      rootnode := xmldom.makenode (xmldoc);
      maintable := maintablenull;
      node :=
           xslprocessor.selectsinglenode (rootnode, 'HierMetadata/MainTable');
      maintable.NAME := xslprocessor.valueof (node, '@Name');
      maintable.descriptioncolumn :=
                            xslprocessor.valueof (node, '@DescriptionColumn');
      maintable.pkcolumns.EXTEND (2);
      maintable.pkcolumns (1) :=
                          xslprocessor.valueof (node, 'PrimaryKey/@IdColumn');
      maintable.pkcolumns (2) :=
                     xslprocessor.valueof (node, 'PrimaryKey/@VersionColumn');
      IF xmldom.isnull
            (xslprocessor.selectsinglenode
                       (rootnode,
                        'HierMetadata/MainTable/NetworkRecursiveRelationTable'
                       )
            )
      THEN
         structuretype := structure_type_sr;
         maintable.fkcolumns.EXTEND (2);
         maintable.fkcolumns (1) :=
                      xslprocessor.valueof (node, 'SelfForeignKey/@IdColumn');
         maintable.fkcolumns (2) :=
                 xslprocessor.valueof (node, 'SelfForeignKey/@VersionColumn');
      ELSE
         structuretype := structure_type_nr;
         node :=
            xslprocessor.selectsinglenode
                      (rootnode,
                       'HierMetadata/MainTable/NetworkRecursiveRelationTable'
                      );
         nrrelationtable.NAME := xslprocessor.valueof (node, '@Name');
         nrrelationtable.pkcolumn :=
                             xslprocessor.valueof (node, '@DescriptionColumn');
         nrrelationtable.nr1columns.EXTEND (2);
         nrrelationtable.nr1columns (1) :=
            xslprocessor.valueof (node,
                                  'PrimaryNetworkRecursiveKey/@IdColumn');
         nrrelationtable.nr1columns (2) :=
            xslprocessor.valueof (node,
                                  'PrimaryNetworkRecursiveKey/@VersionColumn'
                                 );
         nrrelationtable.nr2columns.EXTEND (2);
         nrrelationtable.nr2columns (1) :=
            xslprocessor.valueof (node,
                                  'SecondaryNetworkRecursiveKey/@IdColumn'
                                 );
         nrrelationtable.nr2columns (2) :=
            xslprocessor.valueof
                                (node,
                                 'SecondaryNetworkRecursiveKey/@VersionColumn'
                                );
         maintable.nrrelationtable := nrrelationtable;
      END IF;
      linktables :=
         xslprocessor.selectnodes (rootnode,
                                   'HierMetadata/MainTable/LinkTable'
                                  );
      maintable.childtables.EXTEND (xmldom.getlength (linktables));
      FOR i IN 0 .. xmldom.getlength (linktables) - 1
      LOOP
         node := xmldom.item (linktables, i);
         linktable.NAME := xslprocessor.valueof (node, '@Name');
         linktable.pkcolumns.EXTEND (3);
         linktable.pkcolumns (1) :=
                      xslprocessor.valueof (node, 'PrimaryKey/@MainIdColumn');
         linktable.pkcolumns (2) :=
                 xslprocessor.valueof (node, 'PrimaryKey/@MainVersionColumn');
         linktable.pkcolumns (3) :=
                     xslprocessor.valueof (node, 'PrimaryKey/@ChildIdColumn');
         node := xslprocessor.selectsinglenode (node, 'ChildTable');
         childtable.NAME := xslprocessor.valueof (node, '@Name');
         childtable.descriptioncolumn :=
                            xslprocessor.valueof (node, '@DescriptionColumn');
         childtable.pkcolumns.EXTEND (1);
         childtable.pkcolumns (1) :=
                          xslprocessor.valueof (node, 'PrimaryKey/@IdColumn');
         linktable.childtable := childtable;
         maintable.childtables (i + 1) := linktable;
      END LOOP;
      xmldom.freedocument (xmldoc);
   END;
   FUNCTION getcolumnlistsql (
      tablename        IN   VARCHAR2,
      versioncolumns   IN   t_columns DEFAULT t_columns (),
      newversion       IN   NUMBER DEFAULT NULL
   )
      RETURN VARCHAR2
   AS
      listsql           VARCHAR2 (4000);
      isversioncolumn   BOOLEAN;
   BEGIN
      FOR rec IN (SELECT column_name
                    FROM cols
                   WHERE table_name = UPPER (tablename))
      LOOP
         isversioncolumn := FALSE;
         FOR i IN 1 .. versioncolumns.COUNT
         LOOP
            isversioncolumn :=
               isversioncolumn
               OR rec.column_name = UPPER (versioncolumns (i));
         END LOOP;
         IF isversioncolumn
         THEN
            listsql :=
                  listsql
               || ' nvl2('
               || rec.column_name
               || ', '
               || newversion
               || ', null), ';
         ELSE
            listsql := listsql || rec.column_name || ', ';
         END IF;
      END LOOP;
      listsql := SUBSTR (listsql, 1, LENGTH (listsql) - 2);
      RETURN listsql;
   END;
   PROCEDURE copyhierarchy (
      metadata       IN   CLOB,
      fromversion    IN   NUMBER,
      toversion      IN   NUMBER,
      toschemaname   IN   VARCHAR2
   )
   AS
      columnlist       VARCHAR2 (32767);
      versioncolumns   t_columns        := t_columns ();
      linktable        t_table2;
      sqltext          VARCHAR2 (32767) := '';
      toschemaprefix   VARCHAR2 (50)
                := CASE
         WHEN toschemaname IS NULL
            THEN ''
         ELSE toschemaname || '.'
      END;
   BEGIN
      IF structuretype = structure_type_sr
      THEN
         versioncolumns.EXTEND (2);
         versioncolumns (1) := maintable.pkcolumns (2);
         versioncolumns (2) := maintable.fkcolumns (2);
      ELSIF structuretype = structure_type_nr
      THEN
         versioncolumns.EXTEND (1);
         versioncolumns (1) := maintable.pkcolumns (2);
      END IF;
      sqltext :=
            'insert into '
         || toschemaprefix
         || maintable.NAME
         || ' ('
         || getcolumnlistsql (maintable.NAME)
         || ')'
         || ' select '
         || getcolumnlistsql (maintable.NAME, versioncolumns, toversion)
         || ' from '
         || maintable.NAME
         || ' where '
         || maintable.pkcolumns (2)
         || '='
         || fromversion;
      IF fromversion != toversion
      THEN
         sqltext :=
               sqltext
            || ' and ('
            || maintable.pkcolumns (1)
            || ') in ('
            || ' select '
            || maintable.pkcolumns (1)
            || ' from '
            || maintable.NAME
            || ' where '
            || maintable.pkcolumns (2)
            || '='
            || fromversion
            || ' minus'
            || ' select '
            || maintable.pkcolumns (1)
            || ' from '
            || maintable.NAME
            || ' where '
            || maintable.pkcolumns (2)
            || '='
            || toversion
            || ')';
      END IF;
      EXECUTE IMMEDIATE sqltext;
      IF structuretype = structure_type_nr
      THEN
         versioncolumns := t_columns ();
         versioncolumns.EXTEND (2);
         versioncolumns (1) := maintable.nrrelationtable.nr1columns (2);
         versioncolumns (2) := maintable.nrrelationtable.nr2columns (2);
         sqltext :=
               'insert into '
            || toschemaprefix
            || maintable.nrrelationtable.NAME
            || ' ('
            || getcolumnlistsql (maintable.nrrelationtable.NAME)
            || ')'
            || ' select '
            || getcolumnlistsql (maintable.nrrelationtable.NAME,
                                 versioncolumns,
                                 toversion
                                )
            || ' from '
            || maintable.nrrelationtable.NAME
            || ' where '
            || maintable.nrrelationtable.nr1columns (2)
            || '='
            || fromversion;
         IF fromversion != toversion
         THEN
            sqltext :=
                  sqltext
               || ' and ('
               || maintable.nrrelationtable.nr1columns (1)
               || ', '
               || maintable.nrrelationtable.nr2columns (1)
               || ') in ('
               || ' select '
               || maintable.nrrelationtable.nr1columns (1)
               || ', '
               || maintable.nrrelationtable.nr2columns (1)
               || ' from '
               || maintable.nrrelationtable.NAME
               || ' where '
               || maintable.nrrelationtable.nr1columns (2)
               || '='
               || fromversion
               || ' minus'
               || ' select '
               || maintable.nrrelationtable.nr1columns (1)
               || ', '
               || maintable.nrrelationtable.nr2columns (1)
               || ' from '
               || maintable.nrrelationtable.NAME
               || ' where '
               || maintable.nrrelationtable.nr1columns (2)
               || '='
               || toversion
               || ')';
         END IF;
         EXECUTE IMMEDIATE sqltext;
      END IF;
      FOR i IN 1 .. maintable.childtables.COUNT
      LOOP
         linktable := maintable.childtables (i);
         versioncolumns := t_columns ();
         versioncolumns.EXTEND (1);
         versioncolumns (1) := linktable.pkcolumns (2);
         sqltext :=
               'insert into '
            || toschemaprefix
            || linktable.NAME
            || ' ('
            || getcolumnlistsql (linktable.NAME)
            || ')'
            || ' select '
            || getcolumnlistsql (linktable.NAME, versioncolumns, toversion)
            || ' from '
            || linktable.NAME
            || ' where '
            || linktable.pkcolumns (2)
            || '='
            || fromversion;
         IF fromversion != toversion
         THEN
            sqltext :=
                  sqltext
               || ' and ('
               || linktable.pkcolumns (1)
               || ') in ('
               || ' select '
               || linktable.pkcolumns (1)
               || ' from '
               || linktable.NAME
               || ' where '
               || linktable.pkcolumns (2)
               || '='
               || fromversion
               || ' minus'
               || ' select '
               || linktable.pkcolumns (1)
               || ' from '
               || linktable.NAME
               || ' where '
               || linktable.pkcolumns (2)
               || '='
               || toversion
               || ')';
         END IF;
         EXECUTE IMMEDIATE sqltext;
      END LOOP;
   END;
   PROCEDURE createversion (
      metadata      IN   CLOB,
      fromversion   IN   NUMBER,
      toversion     IN   NUMBER
   )
   AS
      sqltext   VARCHAR2 (32767) := '';
   BEGIN
      initmetadata (metadata);
      copyhierarchy (metadata, fromversion, toversion, NULL);
      COMMIT;
   END;
   PROCEDURE deleteversion (
      metadata     IN   CLOB,
      VERSION      IN   NUMBER,
      schemaname   IN   VARCHAR2
   )
   AS
      linktable      t_table2;
      sqltext        VARCHAR2 (32767) := '';
      schemaprefix   VARCHAR2 (50)
                    := CASE
         WHEN schemaname IS NULL
            THEN ''
         ELSE schemaname || '.'
      END;
   BEGIN
      initmetadata (metadata);
      FOR i IN 1 .. maintable.childtables.COUNT
      LOOP
         linktable := maintable.childtables (i);
         sqltext :=
               'delete from '
            || schemaprefix
            || linktable.NAME
            || ' where '
            || linktable.pkcolumns (2)
            || '='
            || VERSION;
         EXECUTE IMMEDIATE sqltext;
      END LOOP;
      IF structuretype = structure_type_nr
      THEN
         sqltext :=
               'delete from '
            || schemaprefix
            || maintable.nrrelationtable.NAME
            || ' where '
            || maintable.nrrelationtable.nr1columns (2)
            || '='
            || VERSION;
         EXECUTE IMMEDIATE sqltext;
      END IF;
      sqltext :=
            'delete from '
         || schemaprefix
         || maintable.NAME
         || ' where '
         || maintable.pkcolumns (2)
         || '='
         || VERSION;
      EXECUTE IMMEDIATE sqltext;
      COMMIT;
   END;
   PROCEDURE printversion (metadata IN CLOB, VERSION IN NUMBER)
   AS
      TYPE t_cursor IS REF CURSOR;
      cur          t_cursor;
      temp         VARCHAR2 (4000);
      linktable    t_table2;
      childtable   t_table3;
      sqltext      VARCHAR2 (32767) := '';
   BEGIN
      initmetadata (metadata);
      IF structuretype = structure_type_sr
      THEN
         raise_application_error (-20000, 'Not implemented.');
      ELSIF structuretype = structure_type_nr
      THEN
         sqltext :=
               'select '
            || maintable.pkcolumns (1)
            || ' id, '
            || maintable.pkcolumns (2)
            || ' ver, '
            || maintable.descriptioncolumn
            || ' description, '
            || maintable.fkcolumns (1)
            || ' parent_id, '
            || maintable.fkcolumns (2)
            || ' parent_ver'
            || ' from '
            || maintable.NAME
            || ' where '
            || maintable.pkcolumns (2)
            || '='
            || VERSION;
         FOR i IN 1 .. maintable.childtables.COUNT
         LOOP
            linktable := maintable.childtables (i);
            childtable := linktable.childtable;
            sqltext :=
                  sqltext
               || ' union all'
               || ' select'
               || ' a.'
               || linktable.pkcolumns (3)
               || ','
               || ' a.'
               || linktable.pkcolumns (2)
               || ','
               || ' b.'
               || childtable.descriptioncolumn
               || ','
               || ' a.'
               || linktable.pkcolumns (1)
               || ','
               || ' a.'
               || linktable.pkcolumns (2)
               || ' from '
               || linktable.NAME
               || ' a, '
               || childtable.NAME
               || ' b'
               || ' where a.'
               || linktable.pkcolumns (2)
               || '='
               || VERSION
               || ' and a.'
               || linktable.pkcolumns (3)
               || '=b.'
               || childtable.pkcolumns (1);
         END LOOP;
         sqltext :=
               'select lpad('' '', (level-1)*5) || description from ('
            || sqltext
            || ') start with parent_id is null and parent_ver is null'
            || ' connect by prior id=parent_id and prior ver=parent_ver';
         OPEN cur FOR sqltext;
         LOOP
            FETCH cur
             INTO temp;
            EXIT WHEN cur%NOTFOUND;
            DBMS_OUTPUT.put_line (temp);
         END LOOP;
         CLOSE cur;
      END IF;
   END;
   PROCEDURE copyversion (
      metadata       IN   CLOB,
      fromversion    IN   NUMBER,
      toschemaname   IN   VARCHAR2
   )
   AS
   BEGIN
      initmetadata (metadata);
      copyhierarchy (metadata, fromversion, fromversion, toschemaname);
   END;
   PROCEDURE mergeversions (
      metadata      IN   CLOB,
      fromversion   IN   NUMBER,
      toversion     IN   NUMBER
   )
   AS
   BEGIN
      initmetadata (metadata);
      copyhierarchy (metadata, fromversion, toversion, NULL);
      COMMIT;
   END;
END;
/


DROP PACKAGE BODY ONEDATA_WA.HOOK;

CREATE OR REPLACE PACKAGE BODY ONEDATA_WA.hook
AS
   PROCEDURE addcolumntorow (ROW IN OUT t_row, columnnode IN xmldom.domnode)
   AS
      columnname        VARCHAR2 (30);
      columnvaluenode   xmldom.domnode;
      columnvalue       VARCHAR2 (32767);
   BEGIN
      columnname := xmldom.getnodename (columnnode);
      columnvaluenode := xmldom.getfirstchild (columnnode);
      IF xmldom.isnull (columnvaluenode)
      THEN
         columnvalue := '';
      ELSIF xmldom.getnodetype (columnvaluenode) = xmldom.text_node
      THEN
         columnvalue := xmldom.getnodevalue (columnvaluenode);
      ELSE
         xmldom.writetobuffer (columnvaluenode, columnvalue);
      END IF;
      ROW (columnname) := columnvalue;
   END;
   FUNCTION getrowsfrommultirowxml (DATA IN RAW)
      RETURN t_rows
   AS
      parser           xmlparser.parser;
      xmldoc           xmldom.domdocument;
      rownodelist      xmldom.domnodelist;
      rownode          xmldom.domnode;
      columnnodelist   xmldom.domnodelist;
      columnnode       xmldom.domnode;
      ROW              t_row;
      ROWS             t_rows             := t_rows ();
   BEGIN
      parser := xmlparser.newparser;
      xmlparser.parsebuffer (parser, UTL_RAW.cast_to_varchar2 (DATA));
      xmldoc := xmlparser.getdocument (parser);
      xmlparser.freeparser (parser);
      rownodelist :=
                  xslprocessor.selectnodes (xmldom.makenode (xmldoc), '/*/*');
      ROWS.EXTEND (xmldom.getlength (rownodelist));
      FOR i IN 0 .. xmldom.getlength (rownodelist) - 1
      LOOP
         rownode := xmldom.item (rownodelist, i);
         columnnodelist := xmldom.getchildnodes (rownode);
         FOR j IN 0 .. xmldom.getlength (columnnodelist) - 1
         LOOP
            columnnode := xmldom.item (columnnodelist, j);
            addcolumntorow (ROW, columnnode);
         END LOOP;
         ROWS (i + 1) := ROW;
      END LOOP;
      xmldom.freedocument (xmldoc);
      RETURN ROWS;
   END;
   FUNCTION geteventhookrow (DATA IN RAW)
      RETURN t_row
   AS
      parser           xmlparser.parser;
      xmldoc           xmldom.domdocument;
      columnnodelist   xmldom.domnodelist;
      columnnode       xmldom.domnode;
      columnname       VARCHAR2 (30);
      columnvalue      VARCHAR2 (32767);
      ROW              t_row;
   BEGIN
      parser := xmlparser.newparser;
      xmlparser.parsebuffer (parser, UTL_RAW.cast_to_varchar2 (DATA));
      xmldoc := xmlparser.getdocument (parser);
      xmlparser.freeparser (parser);
      columnnodelist :=
                  xslprocessor.selectnodes (xmldom.makenode (xmldoc), '/*/*');
      FOR i IN 0 .. xmldom.getlength (columnnodelist) - 1
      LOOP
         columnnode := xmldom.item (columnnodelist, i);
         addcolumntorow (ROW, columnnode);
      END LOOP;
      xmldom.freedocument (xmldoc);
      RETURN ROW;
   END;
   FUNCTION geteventhooktablename (DATA IN RAW)
      RETURN VARCHAR2
   AS
      parser      xmlparser.parser;
      xmldoc      xmldom.domdocument;
      tablename   VARCHAR2 (30);
   BEGIN
      parser := xmlparser.newparser;
      xmlparser.parsebuffer (parser, UTL_RAW.cast_to_varchar2 (DATA));
      xmldoc := xmlparser.getdocument (parser);
      xmlparser.freeparser (parser);
      tablename :=
         xmldom.getnodename
                     (xslprocessor.selectsinglenode (xmldom.makenode (xmldoc),
                                                     '/*'
                                                    )
                     );
      xmldom.freedocument (xmldoc);
      RETURN tablename;
   END;
   FUNCTION getcommandhookrows (DATA IN RAW)
      RETURN t_rows
   AS
   BEGIN
      RETURN getrowsfrommultirowxml (DATA);
   END;
   FUNCTION getmultiselectcolumnrows (DATA IN VARCHAR2)
      RETURN t_rows
   AS
   BEGIN
      IF DATA IS NULL
      THEN
         RETURN t_rows ();
      ELSE
         RETURN getrowsfrommultirowxml (UTL_RAW.cast_to_raw (DATA));
      END IF;
   END;
   /*
Usage from SQL*Plus:
set serveroutput on format wrapped
exec hook.test
*/
   PROCEDURE TEST
   AS
      DATA   RAW (32767);
      ROW    t_row;
      ROWS   t_rows;
   BEGIN
      DATA :=
         UTL_RAW.cast_to_raw (   '<?xml version="1.0" encoding="UTF-8"?>'
                              || '<TABLE_NAME>'
                              || '<A>1</A>'
                              || '<B>2</B>'
                              || '</TABLE_NAME>'
                             );
      ROW := geteventhookrow (DATA);
      DBMS_OUTPUT.put_line ('Event Hook:');
      DBMS_OUTPUT.put_line ('    A: ' || ROW ('A'));
      DBMS_OUTPUT.put_line ('    B: ' || ROW ('B'));
      DBMS_OUTPUT.put_line ('    tableName: ' || geteventhooktablename (DATA));
      DATA :=
         UTL_RAW.cast_to_raw (   '<?xml version="1.0" encoding="UTF-8"?>'
                              || '<wrapper>'
                              || '<TABLE_NAME>'
                              || '<A>1</A>'
                              || '<B>2</B>'
                              || '</TABLE_NAME>'
                              || '<TABLE_NAME>'
                              || '<A>3</A>'
                              || '<B>4</B>'
                              || '</TABLE_NAME>'
                              || '</wrapper>'
                             );
      ROWS := getcommandhookrows (DATA);
      DBMS_OUTPUT.put_line ('Command Hook:');
      DBMS_OUTPUT.put_line ('    Row 1:');
      DBMS_OUTPUT.put_line ('        A: ' || ROWS (1) ('A'));
      DBMS_OUTPUT.put_line ('        B: ' || ROWS (1) ('B'));
      DBMS_OUTPUT.put_line ('    Row 2:');
      DBMS_OUTPUT.put_line ('        A: ' || ROWS (2) ('A'));
      DBMS_OUTPUT.put_line ('        B: ' || ROWS (2) ('B'));
      DATA :=
         UTL_RAW.cast_to_raw (   '<?xml version="1.0" encoding="UTF-8"?>'
                              || '<TABLE_NAME>'
                              || '    <A>1</A>'
                              || '    <B>'
                              || '        <wrapper>'
                              || '            <MULTISELECT_TABLE_NAME>'
                              || '                <C>10</C>'
                              || '                <D>11</D>'
                              || '            </MULTISELECT_TABLE_NAME>'
                              || '            <MULTISELECT_TABLE_NAME>'
                              || '                <C>12</C>'
                              || '                <D>13</D>'
                              || '            </MULTISELECT_TABLE_NAME>'
                              || '        </wrapper>'
                              || '    </B>'
                              || '</TABLE_NAME>'
                             );
      ROW := geteventhookrow (DATA);
      DBMS_OUTPUT.put_line ('Event Hook With MultiSelect Column:');
      DBMS_OUTPUT.put_line ('    A: ' || ROW ('A'));
      DBMS_OUTPUT.put_line ('    B: ' || ROW ('B'));
      ROWS := getmultiselectcolumnrows (ROW ('B'));
      DBMS_OUTPUT.put_line ('MultiSelect Column B:');
      DBMS_OUTPUT.put_line ('    Row 1:');
      DBMS_OUTPUT.put_line ('        C: ' || ROWS (1) ('C'));
      DBMS_OUTPUT.put_line ('        D: ' || ROWS (1) ('D'));
      DBMS_OUTPUT.put_line ('    Row 2:');
      DBMS_OUTPUT.put_line ('        C: ' || ROWS (2) ('C'));
      DBMS_OUTPUT.put_line ('        D: ' || ROWS (2) ('D'));
   END;
END;
/


DROP PACKAGE BODY ONEDATA_WA.IHOOK;

CREATE OR REPLACE PACKAGE BODY ONEDATA_WA.ihook
AS
   FUNCTION blobtobase64 (b IN BLOB)
      RETURN CLOB
   AS
      sizeb    PLS_INTEGER := 4080;
      buffer   RAW (4080);
      offset   PLS_INTEGER DEFAULT 1;
      RESULT   CLOB;
   BEGIN
      DBMS_LOB.createtemporary (RESULT, FALSE, DBMS_LOB.CALL);
      LOOP
         BEGIN
            DBMS_LOB.READ (b, sizeb, offset, buffer);
         EXCEPTION
            WHEN NO_DATA_FOUND
            THEN
               EXIT;
         END;
         offset := offset + sizeb;
         DBMS_LOB.append
            (RESULT,
             TO_CLOB
                   (UTL_RAW.cast_to_varchar2 (UTL_ENCODE.base64_encode (buffer)
                                             )
                   )
            );
      END LOOP;
      RETURN RESULT;
   END;
   FUNCTION getcolumn (ROW IN t_row, columnname IN VARCHAR2)
      RETURN t_column
   AS
   BEGIN
      FOR i IN 1 .. ROW.COUNT
      LOOP
         IF (ROW (i).NAME = columnname)
         THEN
            RETURN ROW (i);
         END IF;
      END LOOP;
      RETURN NULL;
   END;
   FUNCTION getcolumnvalue (ROW IN t_row, columnname IN VARCHAR2)
      RETURN VARCHAR2
   AS
      COLUMN   t_column;
   BEGIN
      COLUMN := getcolumn (ROW, columnname);
      IF COLUMN IS NOT NULL
      THEN
         RETURN COLUMN.VALUE;
      END IF;
      RETURN NULL;
   END;
   FUNCTION getmscolumnvalue (ROW IN t_row, columnname IN VARCHAR2)
      RETURN t_ms_values
   AS
      COLUMN   t_column;
   BEGIN
      COLUMN := getcolumn (ROW, columnname);
      IF COLUMN IS NOT NULL
      THEN
         RETURN COLUMN.msvalues;
      END IF;
      RETURN NULL;
   END;
   FUNCTION getmscolumnoldvalue (ROW IN t_row, columnname IN VARCHAR2)
      RETURN t_ms_values
   AS
      COLUMN   t_column;
   BEGIN
      COLUMN := getcolumn (ROW, columnname);
      IF COLUMN IS NOT NULL
      THEN
         RETURN COLUMN.msoldvalues;
      END IF;
      RETURN NULL;
   END;
   FUNCTION getcolumnoldvalue (ROW IN t_row, columnname IN VARCHAR2)
      RETURN VARCHAR2
   AS
      COLUMN   t_column;
   BEGIN
      COLUMN := getcolumn (ROW, columnname);
      IF COLUMN IS NOT NULL
      THEN
         RETURN COLUMN.oldvalue;
      END IF;
      RETURN NULL;
   END;
   PROCEDURE setmscolumnvalue (
      ROW             IN OUT   t_row,
      columnname      IN       VARCHAR2,
      mscolumnvalue   IN       t_ms_values
   )
   AS
      COLUMN   t_column;
   BEGIN
      FOR i IN 1 .. ROW.COUNT
      LOOP
         IF (ROW (i).NAME = columnname)
         THEN
            ROW (i).msvalues := mscolumnvalue;
            ROW (i).columntype := 4;
            RETURN;
         END IF;
      END LOOP;
      COLUMN := t_column (columnname, 1, mscolumnvalue);
      ROW.EXTEND;
      ROW (ROW.LAST) := COLUMN;
   END;
   PROCEDURE setmscolumnoldvalue (
      ROW             IN OUT   t_row,
      columnname      IN       VARCHAR2,
      mscolumnvalue   IN       t_ms_values
   )
   AS
   BEGIN
      FOR i IN 1 .. ROW.COUNT
      LOOP
         IF (ROW (i).NAME = columnname)
         THEN
            ROW (i).msoldvalues := mscolumnvalue;
            ROW (i).columntype := 4;
            RETURN;
         END IF;
      END LOOP;
   END;
   PROCEDURE setcolumnvalue (
      ROW           IN OUT   t_row,
      columnname    IN       VARCHAR2,
      columnvalue   IN       VARCHAR2
   )
   AS
      COLUMN   t_column;
   BEGIN
      FOR i IN 1 .. ROW.COUNT
      LOOP
         IF (ROW (i).NAME = columnname)
         THEN
            ROW (i).VALUE := columnvalue;
            ROW (i).columntype := 1;
            RETURN;
         END IF;
      END LOOP;
      COLUMN := t_column (columnname, columnvalue);
      ROW.EXTEND;
      ROW (ROW.LAST) := COLUMN;
   END;
   PROCEDURE setcolumnvalue (
      ROW           IN OUT   t_row,
      columnname    IN       VARCHAR2,
      columnvalue   IN       BLOB
   )
   AS
      COLUMN   t_column;
   BEGIN
      FOR i IN 1 .. ROW.COUNT
      LOOP
         IF (ROW (i).NAME = columnname)
         THEN
            ROW (i).blobvalue := columnvalue;
            ROW (i).columntype := 2;
            RETURN;
         END IF;
      END LOOP;
      COLUMN := t_column (columnname, columnvalue);
      ROW.EXTEND;
      ROW (ROW.LAST) := COLUMN;
   END;
   PROCEDURE setcolumnvalue (
      ROW           IN OUT   t_row,
      columnname    IN       VARCHAR2,
      columnvalue   IN       CLOB
   )
   AS
      COLUMN   t_column;
   BEGIN
      FOR i IN 1 .. ROW.COUNT
      LOOP
         IF (ROW (i).NAME = columnname)
         THEN
            ROW (i).clobvalue := columnvalue;
            ROW (i).columntype := 3;
            RETURN;
         END IF;
      END LOOP;
      COLUMN := t_column (columnname, columnvalue);
      ROW.EXTEND;
      ROW (ROW.LAST) := COLUMN;
   END;
   FUNCTION getmsvalues (msvaluesnodelist IN xmldom.domnodelist)
      RETURN t_ms_values
   AS
      msvalues      t_ms_values;
      msvaluenode   xmldom.domnode;
   BEGIN
      msvalues := t_ms_values ();
      FOR j IN 0 .. xmldom.getlength (msvaluesnodelist) - 1
      LOOP
         msvaluenode := xmldom.item (msvaluesnodelist, j);
         msvalues.EXTEND;
         msvalues (msvalues.LAST) := xslprocessor.valueof (msvaluenode, '.');
      END LOOP;
      RETURN msvalues;
   END;
   FUNCTION getrows (rownodelist IN xmldom.domnodelist)
      RETURN t_rows
   AS
      COLUMN                t_column;
      ROW                   t_row;
      ROWS                  t_rows;
      msvalues              t_ms_values;
      msoldvalues           t_ms_values;
      msvaluesnodelist      xmldom.domnodelist;
      msoldvaluesnodelist   xmldom.domnodelist;
      columnnodelist        xmldom.domnodelist;
      rownode               xmldom.domnode;
      columnnode            xmldom.domnode;
   BEGIN
      ROWS := t_rows ();
      FOR i IN 0 .. xmldom.getlength (rownodelist) - 1
      LOOP
         rownode := xmldom.item (rownodelist, i);
         columnnodelist := xslprocessor.selectnodes (rownode, 'Column');
         ROW := t_row ();
         FOR j IN 0 .. xmldom.getlength (columnnodelist) - 1
         LOOP
            columnnode := xmldom.item (columnnodelist, j);
            IF     xslprocessor.valueof (columnnode, '@MultiSelect') IS NOT NULL
               AND xslprocessor.valueof (columnnode, '@MultiSelect') = 'true'
            THEN
               msvaluesnodelist :=
                              xslprocessor.selectnodes (columnnode, 'values');
               msoldvaluesnodelist :=
                           xslprocessor.selectnodes (columnnode, 'oldValues');
               msvalues := getmsvalues (msvaluesnodelist);
               msoldvalues := getmsvalues (msoldvaluesnodelist);
               COLUMN :=
                  t_column (xslprocessor.valueof (columnnode, '@Name'),
                            1,
                            msvalues
                           );
               IF msoldvalues IS NOT NULL AND msoldvalues.COUNT > 0
               THEN
                  COLUMN.msoldvalues := msoldvalues;
               END IF;
               IF     xslprocessor.valueof (columnnode, '@PrimaryKey') IS NOT NULL
                  AND xslprocessor.valueof (columnnode, '@PrimaryKey') = 'yes'
               THEN
                  COLUMN.primarykey := 1;
               END IF;
            ELSE
               COLUMN :=
                  t_column (xslprocessor.valueof (columnnode, '@Name'),
                            xslprocessor.valueof (columnnode, '.'),
                            xslprocessor.valueof (columnnode, '@OldValue')
                           );
               IF     xslprocessor.valueof (columnnode, '@PrimaryKey') IS NOT NULL
                  AND xslprocessor.valueof (columnnode, '@PrimaryKey') = 'yes'
               THEN
                  COLUMN.primarykey := 1;
               END IF;
            END IF;
            ROW.EXTEND;
            ROW (ROW.LAST) := COLUMN;
         END LOOP;
         ROWS.EXTEND;
         ROWS (ROWS.LAST) := ROW;
      END LOOP;
      RETURN ROWS;
   END;
   PROCEDURE setrows (
      xmldoc            xmldom.domdocument,
      parentnode        xmldom.domnode,
      ROWS         IN   t_rows
   )
   AS
      COLUMN              t_column;
      ROW                 t_row;
      rowelement          xmldom.domelement;
      rownode             xmldom.domnode;
      columnelement       xmldom.domelement;
      columnnode          xmldom.domnode;
      msvalueelement      xmldom.domelement;
      msvaluenode         xmldom.domnode;
      msvalues            t_ms_values;
      msoldvalueelement   xmldom.domelement;
      msoldvaluenode      xmldom.domnode;
      msoldvalues         t_ms_values;
   BEGIN
      IF ROWS IS NULL
      THEN
         RETURN;
      END IF;
      FOR i IN 1 .. ROWS.COUNT
      LOOP
         ROW := ROWS (i);
         rowelement := xmldom.createelement (xmldoc, 'Row');
         rownode :=
                xmldom.appendchild (parentnode, xmldom.makenode (rowelement));
         FOR j IN 1 .. ROW.COUNT
         LOOP
            COLUMN := ROW (j);
            columnelement := xmldom.createelement (xmldoc, 'Column');
            xmldom.setattribute (columnelement, 'Name', COLUMN.NAME);
            IF COLUMN.oldvalue IS NOT NULL
            THEN
               xmldom.setattribute (columnelement,
                                    'OldValue',
                                    COLUMN.oldvalue
                                   );
            END IF;
            IF COLUMN.primarykey = 1
            THEN
               xmldom.setattribute (columnelement, 'PrimaryKey', 'yes');
            END IF;
            IF COLUMN.multiselect = 1
            THEN
               xmldom.setattribute (columnelement, 'MultiSelect', 'true');
            END IF;
            columnnode :=
                 xmldom.appendchild (rownode, xmldom.makenode (columnelement));
            IF COLUMN.columntype = 1
            THEN
               columnnode :=
                  xmldom.appendchild
                        (columnnode,
                         xmldom.makenode (xmldom.createtextnode (xmldoc,
                                                                 COLUMN.VALUE
                                                                )
                                         )
                        );
            ELSIF COLUMN.columntype = 2
            THEN
               columnnode :=
                  xmldom.appendchild
                     (columnnode,
                      xmldom.makenode
                         (xmldom.createtextnode
                                               (xmldoc,
                                                blobtobase64 (COLUMN.blobvalue)
                                               )
                         )
                     );
            ELSIF COLUMN.columntype = 3
            THEN
               columnnode :=
                  xmldom.appendchild
                     (columnnode,
                      xmldom.makenode (xmldom.createtextnode (xmldoc,
                                                              COLUMN.clobvalue
                                                             )
                                      )
                     );
            ELSIF COLUMN.columntype = 4
            THEN
               msvalues := COLUMN.msvalues;
               FOR mscount IN 1 .. msvalues.COUNT
               LOOP
                  msvalueelement := xmldom.createelement (xmldoc, 'values');
                  msvaluenode :=
                     xmldom.appendchild (columnnode,
                                         xmldom.makenode (msvalueelement)
                                        );
                  msvaluenode :=
                     xmldom.appendchild
                        (msvaluenode,
                         xmldom.makenode
                                     (xmldom.createtextnode (xmldoc,
                                                             msvalues (mscount)
                                                            )
                                     )
                        );
               END LOOP;
               msoldvalues := COLUMN.msoldvalues;
               IF msoldvalues IS NOT NULL
               THEN
                  FOR mscount IN 1 .. msoldvalues.COUNT
                  LOOP
                     msoldvalueelement :=
                                   xmldom.createelement (xmldoc, 'oldValues');
                     msoldvaluenode :=
                        xmldom.appendchild
                                          (columnnode,
                                           xmldom.makenode (msoldvalueelement)
                                          );
                     msoldvaluenode :=
                        xmldom.appendchild
                           (msoldvaluenode,
                            xmldom.makenode
                                  (xmldom.createtextnode (xmldoc,
                                                          msoldvalues (mscount)
                                                         )
                                  )
                           );
                  END LOOP;
               END IF;
            END IF;
         END LOOP;
      END LOOP;
   END;
   PROCEDURE setelement (
      xmldoc            xmldom.domdocument,
      parentnode        xmldom.domnode,
      NAME         IN   VARCHAR2,
      VALUE        IN   VARCHAR2
   )
   AS
      ELEMENT   xmldom.domelement;
      node      xmldom.domnode;
   BEGIN
      IF VALUE IS NOT NULL
      THEN
         ELEMENT := xmldom.createelement (xmldoc, NAME);
         node := xmldom.appendchild (parentnode, xmldom.makenode (ELEMENT));
         node :=
            xmldom.appendchild
                             (node,
                              xmldom.makenode (xmldom.createtextnode (xmldoc,
                                                                      VALUE
                                                                     )
                                              )
                             );
      END IF;
   END;
   FUNCTION gethookinput (DATA IN CLOB)
      RETURN t_hookinput
   AS
      hookinput        t_hookinput        := t_hookinput ();
      originalrowset   t_actionrowset;
      selectedrowset   t_rowset;
      parser           xmlparser.parser;
      xmldoc           xmldom.domdocument;
      rootnode         xmldom.domnode;
      formsnodelist    xmldom.domnodelist;
      formnode         xmldom.domnode;
      forms            t_forms;
      formrowset       t_rowset;
      form1            t_form;
   BEGIN
      parser := xmlparser.newparser;
      xmlparser.parseclob (parser, DATA);
      xmldoc := xmlparser.getdocument (parser);
      xmlparser.freeparser (parser);
      rootnode := xmldom.makenode (xmldoc);
      hookinput.invocationnumber :=
         TO_NUMBER
            (xslprocessor.valueof
                             (rootnode,
                              '/OnedataInteractiveHookInput/@InvocationNumber'
                             )
            );
      hookinput.userid :=
         xslprocessor.valueof (rootnode,
                               '/OnedataInteractiveHookInput/@UserId'
                              );
      hookinput.clientid :=
         xslprocessor.valueof (rootnode,
                               '/OnedataInteractiveHookInput/@ClientId'
                              );
      hookinput.projectid :=
         xslprocessor.valueof (rootnode,
                               '/OnedataInteractiveHookInput/@ProjectId'
                              );
      hookinput.schemaid :=
         xslprocessor.valueof (rootnode,
                               '/OnedataInteractiveHookInput/@SchemaId'
                              );
      hookinput.repositoryid :=
         xslprocessor.valueof (rootnode,
                               '/OnedataInteractiveHookInput/@RepositoryId'
                              );
      hookinput.databasetype :=
         xslprocessor.valueof (rootnode,
                               '/OnedataInteractiveHookInput/@DatabaseType'
                              );
      hookinput.invokedfromworkflow :=
         xslprocessor.valueof
                          (rootnode,
                           '/OnedataInteractiveHookInput/@InvokedFromWorkflow'
                          );
      hookinput.approverid :=
         xslprocessor.valueof (rootnode,
                               '/OnedataInteractiveHookInput/@ApproverID'
                              );
      hookinput.updatedcolname :=
         xslprocessor.valueof (rootnode,
                               '/OnedataInteractiveHookInput/@UpdColName'
                              );
      hookinput.workflowpassphrase :=
         xslprocessor.valueof
                           (rootnode,
                            '/OnedataInteractiveHookInput/@WorkflowPassPhrase'
                           );
      hookinput.refreshtransaction :=
         xslprocessor.valueof
                           (rootnode,
                            '/OnedataInteractiveHookInput/@RefreshTransaction'
                           );
      originalrowset :=
         t_actionrowset
            (t_rows (),
             xslprocessor.valueof
                    (rootnode,
                     '/OnedataInteractiveHookInput/OriginalRowset/@ObjectName'
                    ),
             xslprocessor.valueof
                    (rootnode,
                     '/OnedataInteractiveHookInput/OriginalRowset/@ObjectType'
                    ),
             xslprocessor.valueof
                     (rootnode,
                      '/OnedataInteractiveHookInput/OriginalRowset/@TableName'
                     ),
             0,
             xslprocessor.valueof
                          (rootnode,
                           '/OnedataInteractiveHookInput/OriginalRowset/@Type'
                          ),
             xslprocessor.valueof
                (rootnode,
                 '/OnedataInteractiveHookInput/OriginalRowset/@ConceptualObjectName'
                )
            );
      originalrowset.rowset :=
         getrows
            (xslprocessor.selectnodes
                            (rootnode,
                             '/OnedataInteractiveHookInput/OriginalRowset/Row'
                            )
            );
      hookinput.originalrowset := originalrowset;
      IF xmldom.getlength
            (xslprocessor.selectnodes
                            (rootnode,
                             '/OnedataInteractiveHookInput/SelectedRowset/Row'
                            )
            ) > 0
      THEN
         selectedrowset :=
            t_rowset
               (t_rows (),
                xslprocessor.valueof
                    (rootnode,
                     '/OnedataInteractiveHookInput/SelectedRowset/@ObjectName'
                    ),
                xslprocessor.valueof
                    (rootnode,
                     '/OnedataInteractiveHookInput/SelectedRowset/@ObjectType'
                    ),
                NULL
               );
         selectedrowset.rowset :=
            getrows
               (xslprocessor.selectnodes
                            (rootnode,
                             '/OnedataInteractiveHookInput/SelectedRowset/Row'
                            )
               );
         hookinput.selectedrowset := selectedrowset;
      END IF;
      hookinput.answerid :=
         TO_NUMBER
              (xslprocessor.valueof (rootnode,
                                     '/OnedataInteractiveHookInput/Answer/@Id'
                                    )
              );
      IF xmldom.getlength
            (xslprocessor.selectnodes
                                    (rootnode,
                                     '/OnedataInteractiveHookInput/Forms/Form'
                                    )
            ) > 0
      THEN
         formsnodelist :=
            xslprocessor.selectnodes
                                   (rootnode,
                                    '/OnedataInteractiveHookInput/Forms/Form'
                                   );
         forms := t_forms ();
         forms.EXTEND (xmldom.getlength (formsnodelist));
         FOR i IN 0 .. xmldom.getlength (formsnodelist) - 1
         LOOP
            formnode := xmldom.item (formsnodelist, i);
            formrowset :=
               t_rowset (getrows (xslprocessor.selectnodes (formnode,
                                                            'Rowset/Row'
                                                           )
                                 ),
                         xslprocessor.valueof (rootnode, 'Rowset/@TableName')
                        );
            form1 :=
               t_form (xslprocessor.valueof (formnode, '@ObjectName'),
                       xslprocessor.valueof (formnode, '@ObjectType'),
                       xslprocessor.valueof (formnode, '@Cardinality'),
                       formrowset
                      );
            forms (i + 1) := form1;
         END LOOP;
         hookinput.forms := forms;
      END IF;
      xmldom.freedocument (xmldoc);
      RETURN hookinput;
   END;
   FUNCTION gethookoutput (hookoutput IN t_hookoutput)
      RETURN CLOB
   AS
      xmldoc           xmldom.domdocument;
      mainnode         xmldom.domnode;
      rootnode         xmldom.domnode;
      rootelement      xmldom.domelement;
      element1         xmldom.domelement;
      node1            xmldom.domnode;
      element2         xmldom.domelement;
      node2            xmldom.domnode;
      element3         xmldom.domelement;
      node3            xmldom.domnode;
      question         t_question;
      answer           t_answer;
      showrowset       t_showablerowset;
      originalrowset   t_actionrowset;
      action           t_actionrowset;
      form1            t_form;
      xmlheader        VARCHAR2 (32767)
                      := '<?xml version="1.0" encoding="UTF-8"?>' || CHR (10);
      xmlclob          CLOB;
      tempclob         CLOB;
   BEGIN
      xmldoc := xmldom.newdomdocument;
      mainnode := xmldom.makenode (xmldoc);
      rootelement :=
                xmldom.createelement (xmldoc, 'OnedataInteractiveHookOutput');
      xmldom.setattribute (rootelement,
                           'InvocationNumber',
                           hookoutput.invocationnumber
                          );
      rootnode := xmldom.appendchild (mainnode, xmldom.makenode (rootelement));
      setelement (xmldoc, rootnode, 'Message', hookoutput.MESSAGE);
      setelement (xmldoc, rootnode, 'Status', hookoutput.status);
      IF hookoutput.forwardhookname IS NOT NULL
      THEN
         element1 := xmldom.createelement (xmldoc, 'Forward');
         node1 := xmldom.appendchild (rootnode, xmldom.makenode (element1));
         xmldom.setattribute (element1,
                              'HookName',
                              hookoutput.forwardhookname
                             );
      END IF;
      IF hookoutput.question IS NOT NULL
      THEN
         question := hookoutput.question;
         element1 := xmldom.createelement (xmldoc, 'Question');
         node1 := xmldom.appendchild (rootnode, xmldom.makenode (element1));
         setelement (xmldoc, node1, 'Text', question.text);
         FOR i IN question.answers.FIRST .. question.answers.LAST
         LOOP
            answer := question.answers (i);
            element2 := xmldom.createelement (xmldoc, 'Answer');
            xmldom.setattribute (element2, 'Id', answer.ID);
            xmldom.setattribute (element2, 'Order', answer.answerorder);
            node2 := xmldom.appendchild (node1, xmldom.makenode (element2));
            node2 :=
               xmldom.appendchild
                         (node2,
                          xmldom.makenode (xmldom.createtextnode (xmldoc,
                                                                  answer.text
                                                                 )
                                          )
                         );
         END LOOP;
      END IF;
      IF hookoutput.showrowset IS NOT NULL
      THEN
         showrowset := hookoutput.showrowset;
         element1 := xmldom.createelement (xmldoc, 'ShowRowset');
         node1 := xmldom.appendchild (rootnode, xmldom.makenode (element1));
         xmldom.setattribute (element1,
                              'SelectionType',
                              showrowset.selectiontype
                             );
         IF showrowset.objectname IS NOT NULL
         THEN
            xmldom.setattribute (element1,
                                 'ObjectName',
                                 showrowset.objectname
                                );
         END IF;
         IF showrowset.objecttype IS NOT NULL
         THEN
            xmldom.setattribute (element1,
                                 'ObjectType',
                                 showrowset.objecttype
                                );
         END IF;
         setrows (xmldoc, node1, showrowset.rowset);
      END IF;
      IF hookoutput.originalrowset IS NOT NULL
      THEN
         originalrowset := hookoutput.originalrowset;
         element1 := xmldom.createelement (xmldoc, 'OriginalRowset');
         node1 := xmldom.appendchild (rootnode, xmldom.makenode (element1));
         xmldom.setattribute (element1, 'TableName',
                              originalrowset.tablename);
         IF originalrowset.actiontype IS NOT NULL
         THEN
            xmldom.setattribute (element1, 'Type', originalrowset.actiontype);
         END IF;
         IF originalrowset.objectname IS NOT NULL
         THEN
            xmldom.setattribute (element1,
                                 'ObjectName',
                                 originalrowset.objectname
                                );
         END IF;
         IF originalrowset.objecttype IS NOT NULL
         THEN
            xmldom.setattribute (element1,
                                 'ObjectType',
                                 originalrowset.objecttype
                                );
         END IF;
         IF originalrowset.conceptualobjectname IS NOT NULL
         THEN
            xmldom.setattribute (element1,
                                 'ConceptualObjectName',
                                 originalrowset.conceptualobjectname
                                );
         END IF;
         setrows (xmldoc, node1, originalrowset.rowset);
      END IF;
      IF hookoutput.actions IS NOT NULL
      THEN
         element1 := xmldom.createelement (xmldoc, 'Actions');
         node1 := xmldom.appendchild (rootnode, xmldom.makenode (element1));
         FOR i IN hookoutput.actions.FIRST .. hookoutput.actions.LAST
         LOOP
            action := hookoutput.actions (i);
            element2 := xmldom.createelement (xmldoc, 'Action');
            xmldom.setattribute (element2, 'Type', action.actiontype);
            xmldom.setattribute (element2, 'TableName', action.tablename);
            xmldom.setattribute (element2, 'Order', action.actionorder);
            IF action.objectname IS NOT NULL
            THEN
               xmldom.setattribute (element2, 'ObjectName',
                                    action.objectname);
            END IF;
            IF action.objecttype IS NOT NULL
            THEN
               xmldom.setattribute (element2, 'ObjectType',
                                    action.objecttype);
            END IF;
            IF action.conceptualobjectname IS NOT NULL
            THEN
               xmldom.setattribute (element2,
                                    'ConceptualObjectName',
                                    action.conceptualobjectname
                                   );
            END IF;
            node2 := xmldom.appendchild (node1, xmldom.makenode (element2));
            setrows (xmldoc, node2, action.rowset);
         END LOOP;
      END IF;
      IF hookoutput.forms IS NOT NULL
      THEN
         element1 := xmldom.createelement (xmldoc, 'Forms');
         node1 := xmldom.appendchild (rootnode, xmldom.makenode (element1));
         FOR i IN hookoutput.forms.FIRST .. hookoutput.forms.LAST
         LOOP
            form1 := hookoutput.forms (i);
            element2 := xmldom.createelement (xmldoc, 'Form');
            xmldom.setattribute (element2, 'ObjectName', form1.objectname);
            xmldom.setattribute (element2, 'Cardinality', form1.CARDINALITY);
            IF form1.objecttype IS NOT NULL
            THEN
               xmldom.setattribute (element2, 'ObjectType', form1.objecttype);
            END IF;
            xmldom.setattribute (element2,
                                 'SkipReferenceValidation',
                                 form1.skipreferencevalidation
                                );
            node2 := xmldom.appendchild (node1, xmldom.makenode (element2));
            element3 := xmldom.createelement (xmldoc, 'Rowset');
            node3 := xmldom.appendchild (node2, xmldom.makenode (element3));
            setrows (xmldoc, node3, form1.rowset.rowset);
         END LOOP;
      END IF;
      DBMS_LOB.createtemporary (tempclob, TRUE, DBMS_LOB.CALL);
      DBMS_LOB.OPEN (tempclob, DBMS_LOB.lob_readwrite);
      xmldom.writetoclob (xmldoc, tempclob, 'UTF-8');
      xmldom.freedocument (xmldoc);
      DBMS_LOB.createtemporary (xmlclob, TRUE, DBMS_LOB.CALL);
      DBMS_LOB.OPEN (xmlclob, DBMS_LOB.lob_readwrite);
      DBMS_LOB.writeappend (xmlclob, LENGTH (xmlheader), xmlheader);
      DBMS_LOB.append (xmlclob, tempclob);
      DBMS_LOB.CLOSE (tempclob);
      DBMS_LOB.CLOSE (xmlclob);
      RETURN xmlclob;
   END;
END;
/


DROP PACKAGE BODY ONEDATA_WA.LOGGING;

CREATE OR REPLACE PACKAGE BODY ONEDATA_WA.LOGGING
AS
   PROCEDURE LOG (v_message_buffer IN OUT VARCHAR2, v_message IN VARCHAR2)
   AS
   BEGIN
      v_message_buffer := v_message_buffer || CHR (13) || v_message;
   END;
END;
/


DROP PACKAGE BODY ONEDATA_WA.ME;

CREATE OR REPLACE PACKAGE BODY ONEDATA_WA.me
AS
   FUNCTION getmatchingengineinput (
      v_hookinputxml             IN   CLOB,
      v_matchingengineinputxml   IN   CLOB
   )
      RETURN t_matchingengineinput
   AS
      v_hookinput             t_hookinput;
      v_inputdatarow          t_row;
      v_originalrowset        t_actionrowset;
      v_inputdatarows         t_rows;
      v_matchingengineinput   t_matchingengineinput;
   BEGIN
      v_hookinput := ihook.gethookinput (v_hookinputxml);
      v_originalrowset := v_hookinput.originalrowset;
      v_inputdatarows := v_originalrowset.rowset;
      v_inputdatarow := v_inputdatarows (1);
      v_matchingengineinput :=
            getmatchingengineinput (v_inputdatarow, v_matchingengineinputxml);
      RETURN v_matchingengineinput;
   END;
   FUNCTION getmatchingengineinput (
      v_inputdatarow             IN   t_row,
      v_matchingengineinputxml   IN   CLOB
   )
      RETURN t_matchingengineinput
   AS
      matchingengineinput   t_matchingengineinput;
      hookinput             t_hookinput;
      me_host               VARCHAR2 (2000);
      me_port               VARCHAR2 (1000);
      me_tablename          VARCHAR2 (200);
      me_repository         VARCHAR2 (200);
      me_predicate          VARCHAR2 (4000);
      me_searchoptions      t_searchoptions;
      me_querylets          t_querylets;
      parser                xmlparser.parser;
      xmldoc                xmldom.domdocument;
      rootnode              xmldom.domnode;
   BEGIN
      parser := xmlparser.newparser;
      xmlparser.parseclob (parser, v_matchingengineinputxml);
      xmldoc := xmlparser.getdocument (parser);
      xmlparser.freeparser (parser);
      rootnode := xmldom.makenode (xmldoc);
      me_host :=
         xslprocessor.valueof
                        (rootnode,
                         '/OnedataMatchingEngineHookInput/MatchingEngineHost'
                        );
      me_port :=
         xslprocessor.valueof
                         (rootnode,
                          '/OnedataMatchingEngineHookInput/MatchingEnginePort'
                         );
      me_tablename :=
         xslprocessor.valueof (rootnode,
                               '/OnedataMatchingEngineHookInput/TableName'
                              );
      me_repository :=
         xslprocessor.valueof (rootnode,
                               '/OnedataMatchingEngineHookInput/RepositoryId'
                              );
      me_predicate :=
         xslprocessor.valueof (rootnode,
                               '/OnedataMatchingEngineHookInput/Predicate'
                              );
      me_searchoptions := getsearchoptions (rootnode);
      me_querylets :=
         getquerylets
            (v_inputdatarow,
             xslprocessor.selectnodes
                         (rootnode,
                          '/OnedataMatchingEngineHookInput/OriginalRowset/Row'
                         )
            );
      matchingengineinput :=
         t_matchingengineinput (me_host,
                                me_port,
                                me_tablename,
                                me_repository,
                                me_predicate,
                                me_searchoptions,
                                me_querylets
                               );
      xmldom.freedocument (xmldoc);
      RETURN matchingengineinput;
   END;
   FUNCTION getquerylets (
      inputdatarow         IN   t_row,
      matchingenginerows   IN   xmldom.domnodelist
   )
      RETURN t_querylets
   AS
      querylet                 t_querylet;
      querylets                t_querylets;
      matchingenginenodelist   xmldom.domnodelist;
      queryletnode             xmldom.domnode;
      matchingenginenode       xmldom.domnode;
      destinationcolumn        VARCHAR2 (256);
      weightage                NUMBER;
      columnvalue              VARCHAR2 (4000);
      sourcecolumn             VARCHAR2 (256);
      v_originalrowset         t_actionrowset;
      v_rows                   t_rows;
      v_row                    t_row;
      matchingenginerow        xmldom.domnode;
      matchingenginecolumns    xmldom.domnodelist;
      matchingenginecolumn     xmldom.domnode;
   BEGIN
      querylets := t_querylets ();
      FOR ROWCOUNT IN 0 .. xmldom.getlength (matchingenginerows) - 1
      LOOP
         matchingenginerow := xmldom.item (matchingenginerows, ROWCOUNT);
         matchingenginecolumns :=
                       xslprocessor.selectnodes (matchingenginerow, 'Column');
         destinationcolumn := '';
         weightage := 0;
         columnvalue := '';
         FOR columncount IN 1 .. xmldom.getlength (matchingenginecolumns) - 1
         LOOP
            matchingenginecolumn :=
                             xmldom.item (matchingenginecolumns, columncount);
            IF xslprocessor.valueof (matchingenginecolumn, '@Name') =
                                                            'DESTINATION_COL'
            THEN
               destinationcolumn :=
                             xslprocessor.valueof (matchingenginecolumn, '.');
            ELSIF xslprocessor.valueof (matchingenginecolumn, '@Name') =
                                                                   'WEIGHTAGE'
            THEN
               weightage := xslprocessor.valueof (matchingenginecolumn, '.');
            ELSIF xslprocessor.valueof (matchingenginecolumn, '@Name') =
                                                                  'SOURCE_COL'
            THEN
               sourcecolumn :=
                             xslprocessor.valueof (matchingenginecolumn, '.');
            END IF;
         END LOOP;
         columnvalue := ihook.getcolumnvalue (inputdatarow, sourcecolumn);
         querylet := t_querylet (destinationcolumn, columnvalue, weightage);
         addquerylet (querylets, querylet);
      END LOOP;
      RETURN querylets;
   END;
   FUNCTION getsearchoptions (rootnode IN xmldom.domnode)
      RETURN t_searchoptions
   AS
      searchoptions     t_searchoptions;
      numberofmatches   NUMBER;
      scoretype         NUMBER;
      thesaurusweight   NUMBER;
      usethesaurus      NUMBER;
      cutofftype        NUMBER;
      cutoffvalue       NUMBER;
      startmatch        NUMBER;
      usepunctuation    NUMBER;
   BEGIN
      numberofmatches :=
         xslprocessor.valueof
            (rootnode,
             '/OnedataMatchingEngineHookInput/MatchingEngineSearchOptions/NumberOfMatches'
            );
      scoretype :=
         xslprocessor.valueof
            (rootnode,
             '/OnedataMatchingEngineHookInput/MatchingEngineSearchOptions/ScoreType'
            );
      thesaurusweight :=
         xslprocessor.valueof
            (rootnode,
             '/OnedataMatchingEngineHookInput/MatchingEngineSearchOptions/ThesaurusWeight'
            );
      usethesaurus :=
         xslprocessor.valueof
            (rootnode,
             '/OnedataMatchingEngineHookInput/MatchingEngineSearchOptions/UseThesaurus'
            );
      cutofftype :=
         xslprocessor.valueof
            (rootnode,
             '/OnedataMatchingEngineHookInput/MatchingEngineSearchOptions/CutOffType'
            );
      cutoffvalue :=
         xslprocessor.valueof
            (rootnode,
             '/OnedataMatchingEngineHookInput/MatchingEngineSearchOptions/CutOffValue'
            );
      startmatch :=
         xslprocessor.valueof
            (rootnode,
             '/OnedataMatchingEngineHookInput/MatchingEngineSearchOptions/StartMatch'
            );
      usepunctuation :=
         xslprocessor.valueof
            (rootnode,
             '/OnedataMatchingEngineHookInput/MatchingEngineSearchOptions/UsePunctuation'
            );
      searchoptions :=
         t_searchoptions (numberofmatches,
                          scoretype,
                          thesaurusweight,
                          usethesaurus,
                          cutofftype,
                          cutoffvalue,
                          startmatch,
                          usepunctuation
                         );
      RETURN searchoptions;
   END;
   FUNCTION getmatches (v_data_in IN t_matchingengineinput)
      RETURN t_matchingengineoutput
   AS
      LANGUAGE JAVA
      NAME 'com.datafoundations.onedata.matchingengine.MatchingEngineSearchHandler.getMatches(oracle.sql.STRUCT) return oracle.sql.STRUCT';
   PROCEDURE addquerylet (querylets IN OUT t_querylets, querylet t_querylet)
   AS
   BEGIN
      querylets.EXTEND;
      querylets (querylets.LAST) := querylet;
   END;
END;
/


DROP PACKAGE BODY ONEDATA_WA.METAMAP;

CREATE OR REPLACE PACKAGE BODY ONEDATA_WA.Metamap wrapped 
a000000
b2
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
abcd
b
6464 feb
hcJZd+7+X0VEAwqWeWFffgf3Q38wg81xeccGV9O8ZIvqTYuZuJXCoZ+5/CfAMcXGb/S/X9fg
t1kivlTUA9mkN8PKDXhc+IZkgSf6p/A3kad+Wc0MS6M7Kwo9VSN3yZHaLM3VX9GE/suy69fS
P5JQwoynbVsz29C3V/I57jARxucieDO0vmHGF5CqbvWzB5l3vNZyv2ruv+Jt4mRyGaoEIyxR
TRAZq/CEW5i3f2CzERFbtgVby/8qMwgvWy22OcsclU3rZnq2sUrN25nIzlSn6Z2tPzAxXloV
oVa9VpJsrn9Gf+LTdnFEbtFySXV0thuh2zovnjAj9Mbtb4z0brhft85IRsw+8IKmN6Qs+Ybl
04JRKwoMIeeaZGqljB9fRmgxNoai35CZ5nXMQQkvxS4OMs2TsAyIorHuzVc08Lj3+97ClhBH
7D4qOraUJEbsIb2rw9zvMRQLdjeQ4zxmtxR2ElxZP0GPFjMV3Wdm7BaQpKLEMH6JByo+w8yt
lLfZn+cPglgZooFiQVIBA2RNNMRR/Of49OXy2SWwqoTStzBIYGeDWKhSrMotjBb1etrU+jsf
D8cijSH6shxJ+1ycYB+G7hYFonvQNVe9cTIfo5w4fQvayvIEtD9GPqhVJIe4RAVHmbjJGZEr
QN+ET0dubRBU/c0hngu4bxz+pBXJKvgloX3/PQFr0M7k3W7UvyJK79/+VxLI74XET8TRf4U8
JcQhFpXvmpLqV/9BnxokHoufn5qZSObGGzOvd9xXhUoCPM8gfLbIrzM60bGS/HmD/woOHscr
kF4vjdLe3jkm/3K9c/p8Uy1zvbm4/wB3ya43YdeIMNYYvWuZ9awG9nagRvSzbGP9X/mVvx+T
Ij0DWqxKL7e2WHTz4wd1Wn4RR6fo6nQEbsQBBoPQfL3P7uMjNyINPqsscCEqh26xQ92O08ui
FlHPibTbkWsshv+zF/SMSjiF4nBRJrrM5fTHT3/1QznvtmV5wpf5z+v0+cgkyig1qXrN/pSI
ksvOEwQ6OFcnPtyJVwwtXVjpSygDxloDgKJ001+zHbFgWS0HBnw4nrmJMWQva4YyEsILxNmA
1nAiyvhUspsffaAK/SCkWE3fdTepcTkArKYxjq/BL1ytt3/MK1tmW5/g0r8hBAeE9ccTU7Q4
OW1IZH/Y+x92kQWq1EKBmczlyUPceF5GHykQRWjKFw1uYyj9jlm7XnXv55pJwCWorDhIcwS7
wQT/D2KqKkopB69cMd3a0Ob5JFUaDM7+xz8h8duDCCKEUrmu60TA6v7rOgkBzVONRQXwIIcM
rDq88p6qOq57HQ1W6B4Nl3g05N4gJipBQjdshhBsHADiHCXG1+qNPnbcYBJt1Yg8sTsBOKXK
kYw+upB6mzmSfZFPMwhJpdNILTeeL4EQ2hgpMQwUyJvv01cGesa2birJjNmAj482vgZ3VhnD
pRBJbLyurTJpnDssKnXbDgMTQpLaZUhL/5w976vceAOai9kPmM0ZiGlk7nLpg//x+5mE/L67
tIyUiprXdjNGBLfLnOIF7f6Lr3SZjBo4kksxeOm+RvBXB0uGHbXxmRduWmM3cdgHj09h7Ydk
ycel2hEDZeXikANxIkCzz13OrFqr91etiIUyLXA4/1OBZDw+o6dWfU7yYwnZC2aUDD8eoIz1
NeTGjhAbmxpxQYgPflAZw+XAReRfyW06ip0RDaK7GhiaqHwVir51C8j5+UrSqo+aF9Ap9YJb
GD0fBPAR3SHgLGj7T2nEd+N3+hEHcb4P9ETxW3CSBfH8XmF4uvLhjXLlARPUbfShtufUHd6b
GLcKn6xwob0ML0O9rBzKjpjfdpMMy7Yh2aHSNkj9llKgO6/xzNNKyLr0hHrS1hzxSRJ08+3v
3CLt/MfQVzM2ap/EF1cj/pfQhgD7ehb2CVTgAZP/aRm7o2MX6OabRyu8fFKW46VXIrg8MSHI
+icy9urUwapBH/RAVxjny6FplfoditjSEiC+QFqZ4kP5OPfxdFYj7NclgZLZ6+AIDS5CFv+j
+71OScf7jQGqttdpB8NAw8IxwDTC+8X9DsL7xf0OwvvF0PtNfmeXORp+Z5d7jAjSv8GvooPP
5Kl9CO5rq/JTeJeik0VOiK0g3CydUTD5S29xAEno69zgII5sCLDOfNgD4xoigsgnOWko3a4o
lU+ajrSKBrs3NT7HBf7wR/1HwqmTPwzYmzILicYCLhyyGzpRVBQsGjcsD2zkzjktxnjLeslT
7xhgMxTLvxbIaOF7UXnIC7yqy1qinqKFPga4iVe3V71b1lnh8AZlXzjLiPfmN2lsR1SZ4Hrn
h9goYkjWlMQONzLI3c0WDkqm8RCm0ZXnoauzr3P3NR3FTVE/PJ9TZBt3F6KS8sy8Zc+7G8xK
t77/s0zbrtatNvFNx3Cqjsi+QPMf84/YOiqs9GSysn5Y7t+bVAIXYd1GxZHrBklGTGdglpnI
mIy/07/PrYq5QvN4DAXpKsqCORWeWlrN+IYCHD5FegrveL1DSQAD1T5qMsTuN8pMk9EHn/9D
J0ro6EIYXtHtF+KNuS8pncxlWig7lUPkv6jlF5knlKfHHgDHEHX5UEalUNLc2g/2fOde05BC
QNHIKsRhF5BbkV86EycqC9gyzFUUXy4VtBRfLhW0FF8uFbQUX2TFOM/WMeC3xRzsxcsb+5mx
6RKsjggb96td6dZmf7dir8jE43i8of2aFAIi0q0Dic+2T5S7ZrcY0eG/KojVrlq8gNMWh1Ci
1hYxfDG/addBMQw7dwLpIpk2UB2X38i6xJGtC82D5ZI7pN7XkVuXIJJLgSfyXdM9u1YMoqAB
Vkcx9brJjRmlyfLMH++/MYgQTCAlErSjbbD4bD5IV+/EGM1JRQjAxHxxJhuoXeaZ7IrU/zhC
Dc8DjW9Wq57yGJSU2BXblQIV0yY4WttMb5BiHNPRwMV3xaFWBn30DKYkH9Dai3vLAXPWOMQG
nhNZY+RlQEhYrJCLnmcowk3NdmF1lJQtwidrDm4l/B/SxixNEBlAtT6DhDlCDNWUooY8J0TD
xuINChfgPV1Ig5E9xZ3Ar2EFxAlLCjbLDDuPyraRy+pFsDs3rMPwIS1R9JTGH9Xdf9qWHJbA
T6PaWi7gKLTaZBfvfFZAXxvzq0rKkTfQWzFQLmbkx+CYhJYOi+socDLdvMrTxmtnMlRokLQi
TpMCVY1tfkDFHQHqzYeJ2Rq0C4BuUaT+ym5aoLid9qqHQudZM13xYjb7nn3SmrG7smswdtt3
HTD7s3YRpqR9vZ4ToBWotE+7wdmtVwKAV7dCj/1GJGfNrQDCDRLp7Cr8aMtFcs3F8u0QzRVY
78IuXhlcSA+WRdsCehhvOnMNK/6Thjq8iwiysXf1i/ioDNAu/fhEpz0v2Tv8cD9U0WjbThtB
tYgI5Nj0wSAAQbfmJduylZPXU0sNkhfAjAMs+TLCmSib/SJKLM3VrH3iWrgjwJtyTFSRJM7v
F8gfaznWNOSq8hsUqhFj+uP5rIjMQH52XisalBzuru8ofVp5R689YC6NcgrYm+5cV6JSVpTR
K+51qrc3SbdkJkVGaDHDtaOpn4ADgZBF5f4ppbUci9CriZMz5aNzsXfyD8z9YiU+Qvd+DeRl
qjSAPoi6vAlhOmLpEymWbaADueyaFgpO34hClPFvx34SzdngeKMSp4pQhhioBuPBKicwEb0o
Y3KKReRElm/RNkwTT5NW2/n2U3CJOF+QBzAmiBKrCNpgrYoCxdakZyyaLnFwjguSho5d8wSE
BtR9gBWeM725xezIxzy5pNhM4ZZzrYTHfTu8YQvALSx2ysaay5xkB54kSZrXTmKZA5S/x9Jx
ccxJ2yDbzhLbw5k6nONYyTOV0Ze5LOXigSdVKcyTQ215GDKNMb5RRO5+2Tv3aDUFuFmWoxoR
rRwKw5GNpyZ69tiCF5DZgYtSew9IPAZGuFZvJ4e15YHxHGGwBA9Iq32IH2jgMqtjDPDFln+T
cOK+3H+94tOmYpNmww2iTTzTPmymTWDNWIfmuIXa4tjamBRzBbX7VHB8Uw==


/


DROP PACKAGE BODY ONEDATA_WA.MMAP;

CREATE OR REPLACE PACKAGE BODY ONEDATA_WA.mmap
AS
   FUNCTION callloaddata (
      v_user_id         IN   VARCHAR2,
      v_repository_id   IN   VARCHAR2,
      v_database_type   IN   VARCHAR2,
      v_client_id       IN   NUMBER,
      v_project_id      IN   NUMBER,
      v_schema_id       IN   NUMBER,
      rowset            IN   t_rowset,
      rmiregistryhost   IN   VARCHAR2,
      rmiregistryport   IN   VARCHAR2
   )
      RETURN VARCHAR2
   AS
      LANGUAGE JAVA
      NAME 'com.datafoundations.onedata.metamap.MetaMapServiceHandler.loadData(java.lang.String,java.lang.String, java.lang.String, oracle.sql.NUMBER, oracle.sql.NUMBER, oracle.sql.NUMBER, oracle.sql.STRUCT,java.lang.String,java.lang.String) return java.lang.String';
   PROCEDURE loaddata (
      v_data_in         IN       CLOB,
      rmiregistryhost   IN       VARCHAR2,
      rmiregistryport   IN       VARCHAR2,
      v_data_out        OUT      CLOB
   )
   AS
      hookinput     t_hookinput;
      hookoutput    t_hookoutput := t_hookoutput ();
      inputrowset   t_rowset;
   BEGIN
      hookinput := ihook.gethookinput (v_data_in);
      hookoutput.invocationnumber := hookinput.invocationnumber;
      inputrowset := hookinput.originalrowset;
      hookoutput.MESSAGE :=
         callloaddata (hookinput.userid,
                       hookinput.repositoryid,
                       hookinput.databasetype,
                       hookinput.clientid,
                       hookinput.projectid,
                       hookinput.schemaid,
                       inputrowset,
                       rmiregistryhost,
                       rmiregistryport
                      );
      hookoutput.originalrowset := hookinput.originalrowset;
      v_data_out := ihook.gethookoutput (hookoutput);
   END;
END;
/


DROP PACKAGE BODY ONEDATA_WA.NCI_11179;

CREATE OR REPLACE PACKAGE BODY ONEDATA_WA.NCI_11179 AS

v_err_str      varchar2(1000) := '';
DEFAULT_TS_FORMAT    varchar2(50) := 'YYYY-MM-DD HH24:MI:SS';
type       t_orgs is table of org_cntct.org_id%type;
v_int_cncpt_id  number := 2433736;

/*  This package includes generic functions as well as versioning related procedures for NCI */
/***********************************************/
FUNCTION CMR_GUID RETURN VARCHAR2 IS
  /*
  ** generate NCI_IDSEQ for reverse caDSR functionality.
  */
    V_GUID  CHAR(32);
    V_OUT   VARCHAR2(36);
  BEGIN
    V_GUID := RAWTOHEX(SYS.STANDARD.SYS_GUID);
    V_OUT := SUBSTR(V_GUID,1,8)||'-';
    V_OUT := V_OUT||SUBSTR(V_GUID,9,4)||'-';
    V_OUT := V_OUT||SUBSTR(V_GUID,13,4)||'-';
    V_OUT := V_OUT||SUBSTR(V_GUID,17,4)||'-';
    V_OUT := V_OUT||SUBSTR(V_GUID,21);
    RETURN V_OUT;
  END CMR_GUID;

/*  This function usage is on hold */
FUNCTION getPrimaryConceptName(v_nm in varchar2) return varchar2 is
v_out number;
v_temp varchar2(255);
i integer;
begin
i := getWordCount(v_nm);
v_temp := getWord(v_nm, i+1,i+1);
return v_temp;
end;


procedure spGetCartPin  ( hookoutput in out t_hookoutput, v_typ in char)  -- v_typ C - Cart only, P - Pin only, B - Both, I - Initial
as
 question t_question;
  answer t_answer;
  answers t_answers;
   forms t_forms;
  form1 t_form;
begin
    ANSWERS                    := T_ANSWERS();

    ANSWER                     := T_ANSWER(1, 1, 'Next');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
    forms                  := t_forms();

    if (v_typ = 'C') then -- cart
        QUESTION               := T_QUESTION('Specify Cart Name.', ANSWERS);
        form1                  := t_form('User Cart (Hook)', 2,1);
    elsif (v_typ = 'P') then
       QUESTION               := T_QUESTION('Specify Pin.', ANSWERS);
        form1                  := t_form('Pin Only (hook)', 2,1);
    elsif     (v_typ = 'B') then
          QUESTION               := T_QUESTION('Specify Cart Name and Pin.', ANSWERS);
        form1                  := t_form('Cart Name And Pin (hook)', 2,1);
     elsif     (v_typ = 'I') then
            form1                  := t_form('Guest User Create Collection Initial (hook)', 2,1);
            QUESTION               := T_QUESTION('Specify Your Name, 6 digit Pin and Collection Type.', ANSWERS);
    end if;
 --   form1.rowset :=v_rowset1;
    forms.extend;    forms(forms.last) := form1;
    hookoutput.forms := forms;
    hookoutput.question := question;

end;


procedure ReturnRow (v_sql varchar2,  v_table_name in varchar2, row in out t_row) as
    action           t_actionRowset;
    action_rows              t_rows := t_rows();

   -- v_sql        varchar2(4000);
    v_cur        number;
    v_temp        number;
    v_col_val       varchar2(4000);

    v_meta_col_cnt      integer;
    v_meta_desc_tab      dbms_sql.desc_tab;
begin


    v_meta_col_cnt := TEMPLATE_11179.getColumnCount(v_table_name);

  --  v_sql := TEMPLATE_11179.getSelectSql(v_table_name) || ' where rel_typ_id = 61 and p_item_id=:p_item_id and p_item_ver_nr=:p_item_ver_nr and disp_ord=:disp_ord';

    v_cur := dbms_sql.open_cursor;
    dbms_sql.parse(v_cur, v_sql, dbms_sql.native);


    for i in 1..v_meta_col_cnt loop
        dbms_sql.define_column(v_cur, i, '', 4000);
    end loop;

    v_temp := dbms_sql.execute_and_fetch(v_cur);
    dbms_sql.describe_columns(v_cur, v_meta_col_cnt, v_meta_desc_tab);


    for i in 1..v_meta_col_cnt loop
        dbms_sql.column_value(v_cur, i, v_col_val);
        ihook.setColumnValue(row, v_meta_desc_tab(i).col_name, v_col_val);
    end loop;

    dbms_sql.close_cursor(v_cur);
end;


/*  Generate Public ID for Asminiteres Item */
function getItemId return integer is
v_out integer;
begin
select od_seq_ADMIN_ITEM.nextval  into v_out from dual;
return v_out;
end;

/* Used when parsing user input during creation of concept-related AI entities like DEC, Rep Term, VM */
FUNCTION getWordCount (v_nm IN varchar2) RETURN integer IS
    V_OUT   Integer;
  BEGIN
  v_out := REGEXP_COUNT( v_nm, '\s');

    RETURN V_OUT+1;
  END;

/*  This function is used in Compare PV. Due to the old OD mode not showing some characters correctly, we call this procedure before displaying the result */
function replaceChar(v_str in varchar2) return varchar2 IS
    V_OUT  varchar2(255);
  BEGIN
  v_out := replace(v_str, '''','`');
  v_out := replace(v_out, '"','`');
    RETURN V_OUT;
  END;


/* Function returns the Item ID and associated inforamtion if the concept combination found. */
procedure CncptCombExists (v_nm in varchar2, v_item_typ in integer, v_item_id out number, v_item_ver_nr out number, v_long_nm in out varchar2, v_def in out varchar2)
as
v_out integer;
begin

    for cur in (select ext.* from nci_admin_item_ext ext,admin_item a
    where nvl(a.fld_delete,0) = 0 and a.item_id = ext.item_id and a.ver_nr = ext.ver_nr and cncpt_concat = v_nm and a.admin_item_typ_id = v_item_typ) loop
            v_item_id := cur.item_id;
            v_item_ver_nr := cur.ver_nr;
            v_long_nm := cur.cncpt_concat;
            v_def := cur.cncpt_concat_def;
    end loop;
end;


/* Get the string in position v_idx within string v_nm */
function getWord(v_nm in varchar2, v_idx in integer, v_max in integer) return varchar2 is
   v_word  varchar2(100);
begin
  if (v_idx = 1 and v_idx = v_max)then
    v_word := v_nm;
  elsif  (v_idx = 1 and v_idx < v_max)then
    v_word := substr(v_nm, 1, instr(v_nm, ' ',1,1)-1);
  elsif (v_idx = v_max) then
     v_word := substr(v_nm, instr(v_nm, ' ',1,v_idx-1)+1);
  else
     v_word := substr(v_nm, instr(v_nm, ' ',1,v_idx-1)+1,instr(v_nm, ' ',1,v_idx)-instr(v_nm, ' ',1,v_idx-1));
  end if;
  return trim(upper(v_word));
end;


/* Usage on hold */
procedure getConcatNmDef(v_item_id in number, v_ver_nr in number, v_nm out varchar2, v_long_nm out varchar2,v_def out varchar2) as
begin
    for cur in (select cncpt_concat , cncpt_concat_nm , cncpt_concat_def  from nci_admin_item_ext where item_id = v_item_id and ver_nr = v_ver_nr and fld_delete = 0) loop
        v_nm := cur.cncpt_concat;
        v_long_nm := cur.cncpt_concat_nm;
        v_def := cur.cncpt_concat_def;
    end loop;
end;


/* Used in deployment view. Not in any hooks */
function get_concepts(v_item_id in number, v_ver_nr in number) return varchar2 is
cursor con is
select c.item_nm, cai.NCI_CNCPT_VAL
from cncpt_admin_item cai, admin_item c
where cai.item_id = v_item_id and cai.ver_nr = v_ver_nr
and cai.cncpt_item_id = c.item_id and cai.cncpt_ver_nr = c.ver_nr and c.admin_item_typ_id = 49
order by  nci_ord desc;

v_name varchar2(255);

begin
    for c_rec in con loop
        if v_name is null then
            v_name := c_rec.item_nm;

            /* Check if Integer Concept */
            if c_rec.item_nm = 'C45255' then
                v_name := v_name||'::'||c_rec.nci_cncpt_val;
            end if;
        else
            v_name := v_name||','||c_rec.item_nm;

            /* Check if Integer Concept */
            if c_rec.item_nm = 'C45255' then
                v_name := v_name||'::'||c_rec.nci_cncpt_val;
            end if;
        end if;

    end loop;
return v_name;
end;


/* Used in deployment view. Not in hooks */
function get_concept_order(v_item_id in number, v_ver_nr in number) return varchar2 is

cursor con is
select nci_ord
from cncpt_admin_item cai
where cai.item_id = v_item_id and cai.ver_nr = v_ver_nr
order by  nci_ord desc;

v_order_sq varchar2(4000):= null;

begin
    for c_rec in con loop
        if v_order_sq is null then
            v_order_sq := c_rec.nci_ord;
        else
            v_order_sq := v_order_sq||','||c_rec.nci_ord;
        end if;
    end loop;
    return v_order_sq;
end;

/*FUNCTION get_concept_origin(v_item_id in number, v_ver_nr in number) return varchar2 is
cursor con is
select origin,display_order
from sbrext.component_Concepts_ext m, sbrext.concepts_ext c
where condr_idseq = p_condr_idseq
and m.con_idseq = c.con_idseq
order by display_order desc;

v_origin varchar2(2000):=null;

begin


for c_rec in con loop

if c_rec.display_order>0 then
  v_origin := v_origin||c_rec.origin||',';
else
  v_origin := v_origin||c_rec.origin;
end if;

end loop;

return v_origin;
end;
*/

/* Change Latest version for select Item Id. Command hook */
procedure spNCIChangeLatestVer (v_data_in in clob, v_data_out out clob, v_usr_id  IN varchar2)
as
hookInput           t_hookInput;
hookOutput           t_hookOutput := t_hookOutput();
showRowset     t_showableRowset;

rows      t_rows;
row          t_row;
row_cur t_row;
row_sel t_row;
question    t_question;
answer     t_answer;
answers     t_answers;

actions           t_actions := t_actions();
action           t_actionRowset;
v_found      boolean;
v_item_id		 number;
v_ver_nr		 number;

begin
    hookInput := ihook.getHookInput(v_data_in);
    hookOutput.invocationNumber := hookInput.invocationNumber;
    hookOutput.originalRowset := hookInput.originalRowset;

    /*  Current row that the user selected. cardinality is always 1 for this hook */
    row_cur := hookInput.originalRowset.Rowset(1);
    rows := t_rows();

    if hookInput.invocationNumber = 0 then  -- First invocation - show all the versions for the select Item ID
        for cur in ( select item_id, ver_nr from admin_item where item_id = ihook.getColumnValue(row_cur,'ITEM_ID')) loop
            if (nci_11179_2.isUserAuth(cur.item_id, cur.ver_nr, v_usr_id) = false) then
                raise_application_error(-20000, 'You are not authorized to insert/update or delete in this context. ');
                return;
            end if;
            row := t_row();
            ihook.setColumnValue(row, 'ITEM_ID', cur.item_id);
            ihook.setColumnValue(row, 'VER_NR', cur.ver_nr);
            rows.extend; rows(rows.last) := row;
        end loop;

        showRowset := t_showableRowset(rows, 'Administered Item (Steward Assignment)',2, 'single');
        hookOutput.showRowset := showRowset;  -- Show rowset

        answers := t_answers();
  	   	answer := t_answer(1, 1, 'Select Latest Version');
  	   	answers.extend; answers(answers.last) := answer;
	   	question := t_question('Set Latest Version', answers);
       	hookOutput.question := question;  -- Ask the question

	elsif hookInput.invocationNumber = 1 then  -- Second invocation - set the actions
		  if hookInput.answerId = 1 then -- selected form
               row_sel := hookInput.selectedRowset.rowset(1);  -- Row selected to be the latest version
                rows :=         t_rows();
                hookOutput.message := 'Already latest version.';

                if (ihook.getColumnValue(row_sel,'CURRNT_VER_IND') = 0) then --- oproceed only if the selected row is not already latest
                    row := t_row();
                    ihook.setColumnValue(row, 'ITEM_ID', ihook.getColumnValue(row_sel, 'ITEM_ID'));
                    ihook.setColumnValue(row, 'VER_NR', ihook.getColumnValue(row_sel, 'VER_NR'));
                    ihook.setColumnValue(row, 'CURRNT_VER_IND', 1);   --- Set current version for selected row
                    rows.extend; rows(rows.last) := row;
                    for cur in (select item_id, ver_nr from admin_item where item_id = ihook.getColumnValue(row_sel, 'ITEM_ID') and currnt_ver_ind = 1) loop
                            row := t_row();
                            ihook.setColumnValue(row, 'ITEM_ID', cur.item_id);
                            ihook.setColumnValue(row, 'VER_NR', cur.ver_nr);
                            ihook.setColumnValue(row, 'CURRNT_VER_IND', 0);  -- unselect current version for the original latest version
                            rows.extend; rows(rows.last) := row;
                    end loop;
                    action := t_actionRowset(rows, 'Administered Item', 2, 1,'update');
                    actions.extend; actions(actions.last) := action;
                    hookOutput.actions := actions;
                    hookOutput.message := 'Successfully changed latest version.';
                end if;
        end if;
    end if;
    v_data_out := ihook.getHookOutput(hookOutput);
end;


/*  Command hook to add selected items to cart. Cardinality - 1 or more */
PROCEDURE spAddToCart (
    v_data_in IN CLOB,
    v_data_out OUT CLOB,
    v_user_id  varchar2,
    v_src varchar2)
AS
    hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();

    actions t_actions := t_actions();
    action t_actionRowset;
    row t_row;
    rows  t_rows;
    row_ori t_row;
    v_item_id  number;
    v_ver_nr number(4,2);
    v_temp integer;
    v_add integer :=0;
    v_already integer :=0;
    i integer := 0;

begin
    hookinput := ihook.gethookinput (v_data_in);
    hookoutput.invocationnumber  := hookinput.invocationnumber;
    hookoutput.originalrowset    := hookinput.originalrowset;
   -- raise_application_error(-20000,v_user_id);

    rows := t_rows();
    for i in 1..hookinput.originalrowset.rowset.count loop  --- Iterate through all the selected rows
        row_ori := hookInput.originalRowset.rowset(i);
        if (v_src = 'AI') then
        v_item_id := ihook.getColumnValue(row_ori, 'ITEM_ID');
        v_ver_nr := ihook.getColumnValue(row_ori, 'VER_NR');
        elsif (v_src ='MODULE') then
        v_item_id := ihook.getColumnValue(row_ori, 'C_ITEM_ID');
        v_ver_nr := ihook.getColumnValue(row_ori, 'C_ITEM_VER_NR');
        end if;
        select count(*) into v_temp from nci_usr_cart where item_id  = v_item_id and ver_nr = v_ver_nr and cntct_secu_id = v_user_id;
        /*  If not already in cart */
        if (v_temp = 0) then
            row := t_row();
            v_add := v_add + 1;
            ihook.setColumnValue(row,'ITEM_ID', v_item_id);
            ihook.setColumnValue(row,'VER_NR', v_ver_nr);
      --      ihook.setColumnValue(row,'CNTCT_SECU_ID', v_user_id);
             ihook.setColumnValue(row,'CNTCT_SECU_ID', v_user_id);

            ihook.setColumnValue(row,'GUEST_USR_NM', 'NONE');
            rows.extend;    rows(rows.last) := row;
        else
            v_already := v_already + 1;
        end if;
    end loop;
    if (v_add > 0) then   -- IF there are items to add to cart
        action := t_actionrowset(rows, 'User Cart', 2,1,'insert');
    --     action := t_actionrowset(rows, 'NCI_USR_CART', 1,1,'insert');
     actions.extend;
        actions(actions.last) := action;
        hookoutput.actions := actions;
        hookoutput.message := v_add || ' item(s) added successfully to cart. ' || v_already || ' item(s) selected already in your cart';
    else
        hookoutput.message := v_already || ' item(s) selected already in your cart';
    end if;
--raise_application_error(-20000,hookoutput.message);

    V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
       nci_util.debugHook('GENERAL',v_data_out);

END;


/*  Command hook for Guest Add to Cart functionality */
PROCEDURE spAddToCartGuest
  (
    v_data_in IN CLOB,
    v_data_out OUT CLOB)
AS
    hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();
    actions t_actions := t_actions();
    action t_actionRowset;
    row t_row;
    rows  t_rows;
    row_ori t_row;
    action_rows       t_rows := t_rows();
    action_row		    t_row;
    rowset            t_rowset;
    v_temp integer;
    v_item_id varchar2(50);
    v_ver_nr varchar2(50);
    v_user_nm varchar2(255);

    v_add integer :=0;
    v_already integer :=0;
    i integer := 0;
    question    t_question;
    answer     t_answer;
    answers     t_answers;
    showrowset	t_showablerowset;
    forms t_forms;
    form1 t_form;
    rowform t_row;
begin
    hookinput                    := Ihook.gethookinput (v_data_in);
    hookoutput.invocationnumber  := hookinput.invocationnumber;
    hookoutput.originalrowset    := hookinput.originalrowset;
    rows := t_rows();
    if hookInput.invocationNumber = 0 then  ---First invocation of the hook - prompt for user name
            ANSWERS                    := T_ANSWERS();
            ANSWER                     := T_ANSWER(1, 1, 'Add to cart.' );
            ANSWERS.EXTEND;
            ANSWERS(ANSWERS.LAST) := ANSWER;
            QUESTION               := T_QUESTION('Specify a name that will be used to store your selection in cart. Please use the same name everytime you add to cart. Your cart will be deleted end of day.' , ANSWERS);
            HOOKOUTPUT.QUESTION    := QUESTION;
            forms                  := t_forms();
            form1                  := t_form('User Cart (Hook)', 2,1);
            forms.extend;
            forms(forms.last) := form1;
            hookOutput.forms := forms;
	elsif hookInput.invocationNumber = 1 then  -- Second invocation - we now have the user name
		  if hookInput.answerId = 1 then
            forms              := hookInput.forms;
            form1              := forms(1);
            rowform := form1.rowset.rowset(1);
            v_user_nm := ihook.getColumnValue(rowform, 'GUEST_USR_NM');

            for i in 1..hookinput.originalrowset.rowset.count loop -- Iterate throu all selected rows.
                row_ori := hookInput.originalRowset.rowset(i);
                v_item_id := ihook.getColumnValue(row_ori, 'ITEM_ID');
                v_ver_nr := ihook.getColumnValue(row_ori, 'VER_NR');
                select count(*) into v_temp from nci_usr_cart where item_id  = v_item_id and ver_nr = v_ver_nr  and guest_usr_nm = v_user_nm;

                if (v_temp = 0) then  -- Add to cart only if it does not already exist
                    row := t_row();
                    v_add := v_add + 1;
                    ihook.setColumnValue(row,'ITEM_ID', v_item_id);
                    ihook.setColumnValue(row,'VER_NR', v_ver_nr);
                    ihook.setColumnValue(row,'CNTCT_SECU_ID', 'GUEST');
                    ihook.setColumnValue(row,'GUEST_USR_NM', v_user_nm);
                    rows.extend;    rows(rows.last) := row;
                else v_already := v_already + 1;
                end if;
            end loop;
            if (v_add > 0) then -- If items avaiable to add
                action := t_actionrowset(rows, 'User Cart', 2,0,'insert');
                actions.extend;
                actions(actions.last) := action;
                hookoutput.actions := actions;
                hookoutput.message := v_add || ' item(s) added successfully to cart. ' || v_already || ' item(s) selected already in your cart';
            else
                hookoutput.message := v_already || ' item(s) selected already in your cart';
            end if;
         end if;
    end if;
    V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
END;

PROCEDURE spRemoveFromCart  (
    v_data_in IN CLOB,
    v_data_out OUT CLOB,
    v_user_id  varchar2)
AS
    hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();
    actions t_actions := t_actions();
    action t_actionRowset;
    row t_row;
    rows  t_rows;
    row_ori t_row;
    action_rows       t_rows := t_rows();
    action_row		    t_row;
    rowset            t_rowset;
    v_temp integer;
    v_item_id varchar2(50);
    v_ver_nr varchar2(50);
    i integer := 0;
begin
    hookinput                    := Ihook.gethookinput (v_data_in);
    hookoutput.invocationnumber  := hookinput.invocationnumber;
    hookoutput.originalrowset    := hookinput.originalrowset;
    rows := t_rows();

    for i in 1..hookinput.originalrowset.rowset.count loop -- Iterate throu selected rows
        row_ori := hookInput.originalRowset.rowset(i);

        /* check to make sure the user is deleting from their cart */
        if (v_user_id <> ihook.getColumnValue(row_ori,'CNTCT_SECU_ID')) then
            raise_application_error(-20000, 'You are not authorized to delete from another user cart');
        end if;

        rows.extend;
        rows(rows.last) := row_ori;
    end loop;
    /* Logically delete row first */
    action := t_actionrowset(rows, 'User Cart', 2,0,'delete');
    actions.extend;
    actions(actions.last) := action;
    /* Physically delete row after logical delete */
    action := t_actionrowset(rows, 'User Cart', 2,1,'purge');
    actions.extend;
    actions(actions.last) := action;

    hookoutput.actions := actions;
    hookoutput.message := 'Item(s) successfully deleted from cart';

    V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
end;


/*  Not sure if used */
PROCEDURE spAddConceptRel  (
    v_data_in IN CLOB,
    v_data_out OUT CLOB)
AS
  hookInput t_hookInput;
  hookOutput t_hookOutput := t_hookOutput();
   actions t_actions := t_actions();
  action t_actionRowset;
  row t_row;
  rows  t_rows;
    row_ori t_row;
  action_rows       t_rows := t_rows();
  action_row		    t_row;
  rowset            t_rowset;
  rowde t_row;
  rowvd  t_row;
  rowdec  t_row;
  v_temp integer;
  v_item_id varchar2(50);
  v_ver_nr varchar2(50);
  v_add integer :=0;
  v_already integer :=0;
  i integer := 0;
  column  t_column;
BEGIN
  hookinput                    := Ihook.gethookinput (v_data_in);
  hookoutput.invocationnumber  := hookinput.invocationnumber;
  hookoutput.originalrowset    := hookinput.originalrowset;
    rows := t_rows();

   for i in 1..hookinput.originalrowset.rowset.count loop
    row_ori := hookInput.originalRowset.rowset(i);
    v_item_id := ihook.getColumnValue(row_ori, 'ITEM_ID');
    v_ver_nr := ihook.getColumnValue(row_ori, 'VER_NR');

    row := t_row();
    v_add := v_add + 1;
    ihook.setColumnValue(row,'ITEM_ID', v_item_id);
    ihook.setColumnValue(row,'VER_NR', v_ver_nr);
    rows.extend;
    rows(rows.last) := row;
 end loop;
  if (v_add > 0) then
    action := t_actionrowset(rows, 'NCI_USR_CART', 1,0,'insert');
    actions.extend;
    actions(actions.last) := action;
    hookoutput.actions := actions;
    hookoutput.message := v_add || ' item(s) added successfully to cart. ' || v_already || ' item(s) selected already in your cart';
    else
    hookoutput.message := v_already || ' item(s) selected already in your cart';
    end if;

  V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
END;


/* Work in Progress */
procedure spCopyQuestion (actions in out t_actions, v_from_module_id in integer, v_from_module_ver in integer, v_to_module_id in integer, v_to_module_ver in integer, v_disp_ord number, v_src in varchar2) as
v_id integer;
v_found boolean;
v_itemid integer;
row  t_row;
rows t_rows;
rowsvv t_rows;
rowsrep t_rows;
action t_actionRowset;
k integer;
rowx t_row;
rowq t_row;
begin

 rowsvv:= t_rows();

 rowsrep := t_rows();
 rows:= t_rows();
for cur in (select * from nci_admin_item_rel_alt_key where p_item_id = v_from_module_id and
        p_item_ver_nr = v_from_module_ver and rel_typ_id = 63 and nvl(fld_delete,0) = 0) loop
    rowq := t_row();

  v_id := nci_11179.getItemId;
ihook.setColumnValue (rowq, 'NCI_PUB_ID', v_id);
ihook.setColumnValue (rowq, 'NCI_VER_NR', v_to_module_ver);
ihook.setColumnValue (rowq, 'P_ITEM_ID', v_to_module_id);
ihook.setColumnValue (rowq, 'P_ITEM_VER_NR', v_to_module_ver);
ihook.setColumnValue (rowq, 'C_ITEM_ID', cur.c_item_id);
ihook.setColumnValue (rowq, 'C_ITEM_VER_NR', cur.c_item_ver_nr);
ihook.setColumnValue (rowq, 'CNTXT_CS_ITEM_ID', cur.cntxt_cs_item_id);
ihook.setColumnValue (rowq, 'CNTXT_CS_VER_NR', cur.cntxt_cs_ver_nr);
ihook.setColumnValue (rowq, 'ITEM_LONG_NM', cur.ITEM_LONG_NM );
ihook.setColumnValue (rowq, 'ITEM_NM', cur.ITEM_NM );
ihook.setColumnValue (rowq, 'REL_TYP_ID', 63);
ihook.setColumnValue (rowq, 'DISP_ORD', cur.disp_ord);
ihook.setColumnValue (rowq, 'EDIT_IND', cur.EDIT_IND);
ihook.setColumnValue (rowq, 'REQ_IND', cur.REQ_IND);
ihook.setColumnValue (rowq, 'INSTR', cur.INSTR);
ihook.setColumnValue (rowq, 'DEFLT_VAL', cur.DEFLT_VAL);



    for cur1 in (select * from  NCI_QUEST_VALID_VALUE where q_pub_id = cur.nci_pub_id and q_ver_nr = cur.nci_ver_nr) loop
      row := t_row();
    ihook.setColumnValue (row, 'Q_PUB_ID', v_id);
    ihook.setColumnValue (row, 'Q_VER_NR', v_to_module_ver);
    ihook.setColumnValue (row, 'VM_NM', cur1.vm_nm);
    ihook.setColumnValue (row, 'VM_LNM', cur1.vm_lnm);
    ihook.setColumnValue (row, 'VM_DEF', cur1.vm_def);
      ihook.setColumnValue (row, 'DESC_TXT', cur1.desc_txt);
  ihook.setColumnValue (row, 'VALUE', cur1.value);
    ihook.setColumnValue (row, 'MEAN_TXT', cur1.mean_txt);
     ihook.setColumnValue (row, 'VAL_MEAN_ITEM_ID', cur1.VAL_MEAN_ITEM_ID);
     ihook.setColumnValue (row, 'VAL_MEAN_VER_NR', cur1.VAL_MEAN_VER_NR);
    v_itemid := nci_11179.getItemId;
    ihook.setColumnValue (row, 'NCI_PUB_ID', v_itemid);
    ihook.setColumnValue (row, 'NCI_VER_NR', 1);
ihook.setColumnValue (row, 'INSTR', cur1.INSTR);
ihook.setColumnValue (row, 'DISP_ORD', cur1.disp_ord);
ihook.setColumnValue (row, 'OLD_NCI_PUB_ID', cur1.NCI_PUB_ID);  -- to set question and repetition default

     rowsvv.extend;
    rowsvv(rowsvv.last) := row;
    v_found := true;
    -- Question default value
    if (cur.DEFLT_VAL_ID is not null and cur.DEFLT_VAL_ID = cur1.NCI_PUB_ID) then  -- Set question default
        ihook.setColumnValue (rowq, 'DEFLT_VAL_ID', v_itemid);
    end if;
  --  raise_application_error(-20000, 'Inside');
    end loop;


     rows.extend;
    rows(rows.last) := rowq;


if (v_src = 'V') then
  -- Question Repetition

    for cur2 in (select * from  NCI_QUEST_vv_rep where quest_pub_id = cur.nci_pub_id and quest_ver_nr = cur.nci_ver_nr) loop
      row := t_row();
    ihook.setColumnValue (row, 'Quest_PUB_ID', v_id);
    ihook.setColumnValue (row, 'Quest_VER_NR', v_to_module_ver);
    ihook.setColumnValue (row, 'REP_SEQ', cur2.REP_SEQ);
    ihook.setColumnValue (row, 'EDIT_IND', cur2.EDIT_IND);
    ihook.setColumnValue (row, 'VAL', cur2.VAL);

    if (cur2.DEFLT_VAL_ID is not null) then  -- find the new val id
        for k in 1..rowsvv.count loop
        rowx := rowsvv(k);
        if (ihook.getColumnValue(rowx,'OLD_NCI_PUB_ID') = cur2.DEFLT_VAL_ID) then
            ihook.setColumnValue (row, 'DEFLT_VAL_ID', ihook.getColumnValue(rowx,'NCI_PUB_ID'));
        end if;
        end loop;
    end if;
    ihook.setColumnValue (row, 'QUEST_VV_REP_ID',-1);

     rowsrep.extend;
    rowsrep(rowsrep.last) := row;
  --  raise_application_error(-20000, 'Inside');
    end loop;
end if;


   end loop;
   if (rows.count > 0) then
    action := t_actionrowset(rows, 'Questions (Base Object)', 2,14,'insert');
    actions.extend;
    actions(actions.last) := action;
  end if;
    if (rowsvv.count > 0) then
    action := t_actionrowset(rowsvv, 'Question Valid Values (Hook)', 2,16,'insert');
    actions.extend;
    actions(actions.last) := action;
  end if;

  if (rowsrep.count > 0) then
    action := t_actionrowset(rowsrep, 'Question Repetition', 2,17,'insert');
    actions.extend;
    actions(actions.last) := action;
  end if;

end;

/* Work in Progress */
procedure spCopyModuleNCI (actions in out t_actions, v_from_module_id in number,v_from_module_ver in number,  v_from_form_id in number, v_from_form_ver number, v_to_form_id number, v_to_form_ver number, v_disp_ord number, v_src in varchar2) as


action           t_actionRowset;
action_rows              t_rows := t_rows();
action_rows_csi              t_rows := t_rows();
row          t_row;
v_table_name varchar2(30);
v_sql        varchar2(4000);
v_to_module_id number;

v_cur        number;
v_temp        number;

v_col_val       varchar2(4000);

v_meta_col_cnt      integer;
v_disp_ord1 integer;
v_meta_desc_tab      dbms_sql.desc_tab;

begin


-- Module
-- Module Rel
--Questions
-- Question VV
-- Question Repetition


v_table_name := 'ADMIN_ITEM';

 v_meta_col_cnt := TEMPLATE_11179.getColumnCount(v_table_name);
 v_to_module_id := nci_11179.getItemId;

    v_sql := TEMPLATE_11179.getSelectSql(v_table_name) || ' where item_id=:item_id and ver_nr=:ver_nr';

 v_cur := dbms_sql.open_cursor;
 dbms_sql.parse(v_cur, v_sql, dbms_sql.native);
 dbms_sql.bind_variable(v_cur, ':item_id', v_from_module_id);
 dbms_sql.bind_variable(v_cur, ':ver_nr', v_from_module_ver);


 for i in 1..v_meta_col_cnt loop
     dbms_sql.define_column(v_cur, i, '', 4000);
 end loop;

    v_temp := dbms_sql.execute_and_fetch(v_cur);
    dbms_sql.describe_columns(v_cur, v_meta_col_cnt, v_meta_desc_tab);

    row := t_row();

 for i in 1..v_meta_col_cnt loop
  dbms_sql.column_value(v_cur, i, v_col_val);
  ihook.setColumnValue(row, v_meta_desc_tab(i).col_name, v_col_val);
 end loop;

 dbms_sql.close_cursor(v_cur);

    ihook.setColumnValue(row, 'VER_NR',v_to_form_ver);
    ihook.setColumnValue(row, 'ITEM_ID',v_to_module_id);
    ihook.setColumnValue(row, 'ITEM_LONG_NM',v_to_module_id || 'v' ||  trim(to_char(v_to_form_ver, '9999.99')));
    action_rows := t_rows();

    action_rows.extend; action_rows(action_rows.last) := row;
    action := t_actionRowset(action_rows, 'Administered Item (No Sequence)',2, 10, 'insert');
    actions.extend; actions(actions.last) := action;
    action := t_actionRowset(action_rows, 'Module',2, 11, 'insert');
    actions.extend; actions(actions.last) := action;


    row := t_row();

    ihook.setColumnValue(row, 'P_ITEM_VER_NR',v_to_form_ver);
    ihook.setColumnValue(row, 'P_ITEM_ID',v_to_form_id);
    ihook.setColumnValue(row, 'C_ITEM_ID',v_to_module_id);
    ihook.setColumnValue(row, 'C_ITEM_VER_NR',v_to_form_ver);
    ihook.setColumnValue(row, 'REL_TYP_ID',61);
   --ihook.setColumnValue(row, 'REP_NO',61);
   --ihook.setColumnValue(row, 'INSTR',61);

if (v_disp_ord < 0) then  -- calling from Copy Hodule hook
     select nvl(max(disp_ord)+ 1,0) into v_disp_ord1 from nci_admin_item_rel where
     p_item_id = v_to_form_id and p_item_ver_nr = v_to_form_ver;
      --   raise_application_error(-2000
    ihook.setColumnValue(row, 'DISP_ORD',v_disp_ord1);
else -- called from version hook
    ihook.setColumnValue(row, 'DISP_ORD',v_disp_ord);
end if;
        --ise_application_error(-20000, v_from_module_id || 'A' || v_from_form_id || 'B' || v_from_module_ver || 'C' || v_from_form_ver);

for curmod in (select * from nci_admin_item_rel where c_item_id = v_from_module_id and c_item_ver_nr = v_from_module_ver and rel_typ_id = 61 ) loop
       ihook.setColumnValue(row, 'REP_NO', curmod.rep_no);
       if (v_src = 'C') then  -- on Copy, rep number is 0
        ihook.setColumnValue(row, 'REP_NO', 0);
       end if;

        ihook.setColumnValue(row, 'INSTR',curmod.instr);
    --    raise_application_error(-20000, curmod.instr);
   end loop;


     action_rows := t_rows();

    action_rows.extend; action_rows(action_rows.last) := row;
    action := t_actionRowset(action_rows, 'Generic AI Relationship', 2, 12, 'insert');
    actions.extend; actions(actions.last) := action;

--raise_application_error(-20000,'HErer');
-- Questions
  spCopyQuestion(actions, v_from_module_id, v_from_module_ver, v_to_module_id, v_to_form_ver,v_disp_ord, v_src);

--raise_application_error(-20000,'Here'|| v_from_module_id || '   ' || v_to_module_id || '  ' || actions.count);



end;



/*  Common children copy when creating a version */
procedure spCreateCommonChildrenNCI (actions in out t_actions, v_from_item_id in number, v_from_ver_nr in number, v_to_item_id in number, v_to_ver_nr in number) as
    action           t_actionRowset;
    action_rows              t_rows := t_rows();
    action_rows_csi              t_rows := t_rows();
    action_rows_blob    t_rows := t_rows();

    row          t_row;
    v_table_name varchar2(30);
    v_sql        varchar2(4000);

    v_cur        number;
    v_temp        number;
    v_col_val       varchar2(4000);

    v_meta_col_cnt      integer;
    v_meta_desc_tab      dbms_sql.desc_tab;

begin

/*  Copy Alternate Names */
    action_rows := t_rows();
    action_rows_csi := t_rows();
    v_table_name := 'ALT_NMS';
    v_meta_col_cnt := TEMPLATE_11179.getColumnCount(v_table_name);

    for an_cur in (select nm_id from alt_nms where
    item_id = v_from_item_id and ver_nr = v_from_ver_nr and nvl(fld_delete,0) = 0) loop
        v_sql := TEMPLATE_11179.getSelectSql(v_table_name) || ' where nm_id = :nm_id';
        v_cur := dbms_sql.open_cursor;
        dbms_sql.parse(v_cur, v_sql, dbms_sql.native);
        dbms_sql.bind_variable(v_cur, ':nm_id', an_cur.nm_id);

        for i in 1..v_meta_col_cnt loop
            dbms_sql.define_column(v_cur, i, '', 4000);
        end loop;

        v_temp := dbms_sql.execute_and_fetch(v_cur);
        dbms_sql.describe_columns(v_cur, v_meta_col_cnt, v_meta_desc_tab);

        row := t_row();
        for i in 1..v_meta_col_cnt loop
            dbms_sql.column_value(v_cur, i, v_col_val);
            ihook.setColumnValue(row, v_meta_desc_tab(i).col_name, v_col_val);
        end loop;
        dbms_sql.close_cursor(v_cur);

        select od_seq_ALT_NMS.nextval into v_temp from dual;
        ihook.setColumnValue(row, 'nm_ID',v_temp);
        ihook.setColumnValue(row, 'ITEM_ID', v_to_item_id);
        ihook.setColumnValue(row, 'VER_NR', v_to_ver_nr);
        ihook.setColumnValue(row, 'NCI_IDSEQ', '');

        action_rows.extend; action_rows(action_rows.last) := row;
        /*  Alternate Name - Classification */
        for csi_cur in (select nci_pub_id, nci_ver_nr, typ_nm from NCI_CSI_ALT_DEFNMS where nmdef_id = an_cur.nm_id and nvl(fld_delete,0)=0) loop
            row:= t_row();
            ihook.setColumnValue(row, 'nmdef_ID',v_temp);
            ihook.setColumnValue(row, 'NCI_PUB_ID', csi_cur.NCI_PUB_ID);
            ihook.setColumnValue(row, 'NCI_VER_NR', csi_cur.NCI_VER_NR);
            ihook.setColumnValue(row, 'TYP_NM', csi_cur.TYP_NM);
            action_rows_csi.extend; action_rows_csi(action_rows_Csi.last) := row;
         end loop;
    end loop;

   -- action := t_actionRowset(action_rows, v_table_name, 12, 'insert');
     action := t_actionRowset(action_rows, 'Alternate Names',2, 12, 'insert');


    actions.extend; actions(actions.last) := action;
---  End of Alternate Names

-- Alternate Definitions

    action_rows := t_rows();

    v_table_name := 'ALT_DEF';
    v_meta_col_cnt := TEMPLATE_11179.getColumnCount(v_table_name);

    for ad_cur in  (select def_id from alt_def where
    item_id = v_from_item_id and ver_nr = v_from_ver_nr and nvl(fld_delete,0) = 0) loop
        v_sql := TEMPLATE_11179.getSelectSql(v_table_name) || ' where def_id = :def_id';
        v_cur := dbms_sql.open_cursor;
        dbms_sql.parse(v_cur, v_sql, dbms_sql.native);
        dbms_sql.bind_variable(v_cur, ':def_id', ad_cur.def_id);

        for i in 1..v_meta_col_cnt loop
            dbms_sql.define_column(v_cur, i, '', 4000);
        end loop;

        v_temp := dbms_sql.execute_and_fetch(v_cur);
        dbms_sql.describe_columns(v_cur, v_meta_col_cnt, v_meta_desc_tab);

        row := t_row();
        for i in 1..v_meta_col_cnt loop
            dbms_sql.column_value(v_cur, i, v_col_val);
            ihook.setColumnValue(row, v_meta_desc_tab(i).col_name, v_col_val);
        end loop;

        dbms_sql.close_cursor(v_cur);
        select od_seq_ALT_DEF.nextval into v_temp from dual;
        ihook.setColumnValue(row, 'DEF_ID', v_temp);
        ihook.setColumnValue(row, 'ITEM_ID', v_to_item_id);
        ihook.setColumnValue(row, 'VER_NR', v_to_ver_nr);
        ihook.setColumnValue(row, 'NCI_IDSEQ', '');
        action_rows.extend; action_rows(action_rows.last) := row;

        for csi_cur in (select nci_pub_id, nci_ver_nr, typ_nm from NCI_CSI_ALT_DEFNMS where nmdef_id = ad_cur.def_id and nvl(fld_delete,0) = 0) loop
            row:= t_row();
            ihook.setColumnValue(row, 'NMDEF_ID',v_temp);
            ihook.setColumnValue(row, 'NCI_PUB_ID', csi_cur.NCI_PUB_ID);
            ihook.setColumnValue(row, 'NCI_VER_NR', csi_cur.NCI_VER_NR);
            ihook.setColumnValue(row, 'TYP_NM', csi_cur.TYP_NM);
            action_rows_csi.extend; action_rows_csi(action_rows_Csi.last) := row;
         end loop;
    end loop;

    action := t_actionRowset(action_rows, 'Alternate Definitions',2, 13, 'insert');
    actions.extend; actions(actions.last) := action;

    action := t_actionRowset(action_rows_csi, 'Classification level Name/Definition 2',2, 25, 'insert');
    actions.extend; actions(actions.last) := action;

-- End of Alternate Definition

--- Reference Documents

    action_rows := t_rows();

    v_table_name := 'REF';
    v_meta_col_cnt := TEMPLATE_11179.getColumnCount(v_table_name);

    for ref_cur in  (select ref_id from ref where
    item_id = v_from_item_id and ver_nr = v_from_ver_nr and nvl(fld_delete,0) = 0) loop

        v_sql := TEMPLATE_11179.getSelectSql(v_table_name) || ' where ref_id = :ref_id';
        v_cur := dbms_sql.open_cursor;
        dbms_sql.parse(v_cur, v_sql, dbms_sql.native);
        dbms_sql.bind_variable(v_cur, ':ref_id', ref_cur.ref_id);

        for i in 1..v_meta_col_cnt loop
            dbms_sql.define_column(v_cur, i, '', 4000);
        end loop;

        v_temp := dbms_sql.execute_and_fetch(v_cur);
        dbms_sql.describe_columns(v_cur, v_meta_col_cnt, v_meta_desc_tab);

        row := t_row();

        for i in 1..v_meta_col_cnt loop
            dbms_sql.column_value(v_cur, i, v_col_val);
            ihook.setColumnValue(row, v_meta_desc_tab(i).col_name, v_col_val);
        end loop;

        dbms_sql.close_cursor(v_cur);

        select od_seq_REF.nextval into v_temp from dual;
        ihook.setColumnValue(row, 'ref_ID', v_temp);
        ihook.setColumnValue(row, 'NCI_IDSEQ', '');
        ihook.setColumnValue(row, 'ITEM_ID', v_to_item_id);
        ihook.setColumnValue(row, 'VER_NR', v_to_ver_nr);
        action_rows.extend; action_rows(action_rows.last) := row;

        -- Blobs are not supported in iHooks. Copying blobs as direct sql. No other option

        insert into ref_doc (nci_ref_id, file_nm, blob_col, nci_mime_type, nci_doc_size, NCI_DOC_LST_UPD_DT, ref_doc_id)
        select v_temp, file_nm, blob_col, nci_mime_type, nci_doc_size, NCI_DOC_LST_UPD_DT,-1 from ref_doc where
        nci_ref_id = ref_cur.ref_id and  nvl(fld_delete,0)=0;
        commit;
        insert into onedata_ra.ref_doc select * from ref_doc where nci_ref_id = v_temp;
        commit;

        /* for blob_cur in (select * from ref_doc where nci_ref_id = ref_cur.ref_id and nvl(fld_delete,0)=0) loop
            row:= t_row();
            ihook.setColumnValue(row, 'nci_ref_id',v_temp);
            ihook.setColumnValue(row, 'FILE_NM', blob_cur.FILE_NM);
            ihook.setColumnValue(row, 'BLOB_COL', blob_cur.BLOB_COL);
            ihook.setColumnValue(row, 'NCI_MIME_TYPE', blob_cur.NCI_MIME_TYPE);
            ihook.setColumnValue(row, 'NCI_DOC_SIZE', blob_cur.NCI_DOC_SIZE);
            ihook.setColumnValue(row, 'NCI_DOC_LST_UPD_DT', blob_cur.NCI_DOC_LST_UPD_DT);
            ihook.setColumnValue(row, 'REF_DOC_ID', -1);
            action_rows_blob.extend; action_rows_blob(action_rows_blob.last) := row;
         end loop;

         */
    end loop;

    action := t_actionRowset(action_rows, 'References (for Edit)',2, 14, 'insert');
    actions.extend; actions(actions.last) := action;

  --  action := t_actionRowset(action_rows_blob,'Ref Documents',2 ,15, 'insert');
  --  actions.extend; actions(actions.last) := action;

   -- raise_application_error(-20000, 'herer');
-- End of Reference Documents
-- Concepts

    action_rows := t_rows();

    v_table_name := 'CNCPT_ADMIN_ITEM';
    v_meta_col_cnt := TEMPLATE_11179.getColumnCount(v_table_name);

    for ref_cur in  (select CNCPT_AI_ID from CNCPT_ADMIN_ITEM where
    item_id = v_from_item_id and ver_nr = v_from_ver_nr) loop
        v_sql := TEMPLATE_11179.getSelectSql(v_table_name) || ' where CNCPT_AI_ID = :CNCPT_AI_ID';
        v_cur := dbms_sql.open_cursor;
        dbms_sql.parse(v_cur, v_sql, dbms_sql.native);
        dbms_sql.bind_variable(v_cur, ':CNCPT_AI_ID', ref_cur.CNCPT_AI_ID);

        for i in 1..v_meta_col_cnt loop
            dbms_sql.define_column(v_cur, i, '', 4000);
        end loop;

        v_temp := dbms_sql.execute_and_fetch(v_cur);
        dbms_sql.describe_columns(v_cur, v_meta_col_cnt, v_meta_desc_tab);
        row := t_row();

        for i in 1..v_meta_col_cnt loop
            dbms_sql.column_value(v_cur, i, v_col_val);
            ihook.setColumnValue(row, v_meta_desc_tab(i).col_name, v_col_val);
        end loop;

        dbms_sql.close_cursor(v_cur);

        ihook.setColumnValue(row, 'CNCPT_AI_ID', -1);
        ihook.setColumnValue(row, 'ITEM_ID', v_to_item_id);
        ihook.setColumnValue(row, 'VER_NR', v_to_ver_nr);
        action_rows.extend; action_rows(action_rows.last) := row;
    end loop;

    action := t_actionRowset(action_rows, v_table_name, 14, 'insert');
    actions.extend; actions(actions.last) := action;

-- End of concepts

--- Begin of Classifications

    action_rows := t_rows();

    v_table_name := 'NCI_ADMIN_ITEM_REL';
    v_meta_col_cnt := TEMPLATE_11179.getColumnCount(v_table_name);

    for ref_cur in  (select P_ITEM_ID,P_ITEM_VER_NR, REL_TYP_ID from NCI_ADMIN_ITEM_REL where
    c_item_id = v_from_item_id and c_item_ver_nr = v_from_ver_nr and rel_typ_id = 65 and nvl(fld_Delete,0) = 0) loop

        v_sql := TEMPLATE_11179.getSelectSql(v_table_name) || ' where P_ITEM_ID = :P_ITEM_ID and P_ITEM_VER_NR = :P_ITEM_VER_NR and c_item_id = :c_item_id and c_item_ver_nr = :c_item_ver_nr and rel_typ_id = :rel_typ_id';
        v_cur := dbms_sql.open_cursor;
        dbms_sql.parse(v_cur, v_sql, dbms_sql.native);
        dbms_sql.bind_variable(v_cur, ':P_ITEM_ID', ref_cur.P_ITEM_ID);
        dbms_sql.bind_variable(v_cur, ':P_ITEM_VER_NR', ref_cur.P_ITEM_VER_NR);
        dbms_sql.bind_variable(v_cur, ':c_item_id', v_from_item_id);
        dbms_sql.bind_variable(v_cur, ':c_item_ver_nr', v_from_ver_nr);
        dbms_sql.bind_variable(v_cur, ':rel_typ_id', ref_cur.rel_typ_id);

        for i in 1..v_meta_col_cnt loop
            dbms_sql.define_column(v_cur, i, '', 4000);
        end loop;

        v_temp := dbms_sql.execute_and_fetch(v_cur);
        dbms_sql.describe_columns(v_cur, v_meta_col_cnt, v_meta_desc_tab);

        row := t_row();

        for i in 1..v_meta_col_cnt loop
            dbms_sql.column_value(v_cur, i, v_col_val);
            ihook.setColumnValue(row, v_meta_desc_tab(i).col_name, v_col_val);
        end loop;

        dbms_sql.close_cursor(v_cur);

       ihook.setColumnValue(row, 'C_ITEM_ID', v_to_item_id);
       ihook.setColumnValue(row, 'C_ITEM_VER_NR', v_to_ver_nr);
        ihook.setColumnValue(row, 'NCI_IDSEQ', '');
        action_rows.extend; action_rows(action_rows.last) := row;
    end loop;

    action := t_actionRowset(action_rows, 'NCI CSI - DE Relationship',2, 15, 'insert');
    actions.extend; actions(actions.last) := action;

end;


procedure spReturnConceptRow (v_item_id in number, v_ver_nr in number, v_item_typ_id in integer, v_idx in integer, row in out t_row) as
    i   integer;

begin
    i := 1;
     for cur in (select cai.cncpt_item_id item_id, cai.cncpt_ver_nr ver_nr, cai.NCI_CNCPT_VAL nci_cncpt_val from  cncpt_admin_item cai where
      cai.item_id = v_item_id and cai.ver_nr = v_ver_nr order by nci_ord desc ) loop
                                ihook.setColumnValue(row, 'CNCPT_' || v_idx  ||'_ITEM_ID_' || i,cur.item_id);
                                ihook.setColumnValue(row, 'CNCPT_' || v_idx || '_VER_NR_' || i, cur.ver_nr);
                                if (cur.item_id = v_int_cncpt_id) then
                                    ihook.setColumnValue(row, 'CNCPT_INT_' || v_idx || '_' || i, cur.nci_cncpt_val);
                                end if;
                                i := i+1;
                        end loop;
end;



procedure spReturnRTConceptRow (v_item_id in number, v_ver_nr in number, v_item_typ_id in integer, v_idx in integer, row in out t_row) as
    i   integer;

begin
    i := 1;
     for cur in (select cai.cncpt_item_id item_id, cai.cncpt_ver_nr ver_nr, nci_ord , cai.nci_cncpt_val from  cncpt_admin_item cai where
      cai.item_id = v_item_id and cai.ver_nr = v_ver_nr order by nci_ord desc ) loop

      if (cur.nci_ord = 0) then
                                ihook.setColumnValue(row, 'CNCPT_' || v_idx  ||'_ITEM_ID_1' ,cur.item_id);
                                ihook.setColumnValue(row, 'CNCPT_' || v_idx || '_VER_NR_1' , cur.ver_nr);
      else
                                i := i+1;
                                ihook.setColumnValue(row, 'CNCPT_' || v_idx  ||'_ITEM_ID_' || i,cur.item_id);
                                ihook.setColumnValue(row, 'CNCPT_' || v_idx || '_VER_NR_' || i, cur.ver_nr);
                                   if (cur.item_id = v_int_cncpt_id) then
                                    ihook.setColumnValue(row, 'CNCPT_INT_' || v_idx || '_' || i, cur.nci_cncpt_val);
                                end if;
      end if;

                        end loop;
end;


procedure spReturnSubtypeRow (v_item_id in number, v_ver_nr in number, v_type in number, row in out t_row) as
    action           t_actionRowset;
    action_rows              t_rows := t_rows();

    v_table_name      varchar2(30);
    v_sql        varchar2(4000);
    v_cur        number;
    v_temp        number;
    v_col_val       varchar2(4000);

    v_meta_col_cnt      integer;
    v_meta_desc_tab      dbms_sql.desc_tab;
begin
    if v_type= 1 then
        v_table_name := 'CONC_DOM';
    elsif v_type = 2 then
        v_table_name := 'DE_CONC';
    elsif v_type = 3 then
        v_table_name := 'VALUE_DOM';
    elsif v_type = 4 then
        v_table_name := 'DE';
    elsif v_type = 5 then
        v_table_name := 'OBJ_CLS';
    elsif v_type = 6 then
        v_table_name := 'PROP';
    elsif v_type = 7 then
        v_table_name := 'REP_CLS';
    elsif v_type = 8 then
        v_table_name := 'CNTXT';
    elsif v_type = 9 then
        v_table_name := 'CLSFCTN_SCHM';
    elsif v_type = 10 then
        v_table_name := 'DERV_RUL';
    elsif v_type = 49 then
        v_table_name := 'CNCPT';
    elsif v_type = 54 then
        v_table_name := 'NCI_FORM';
    elsif v_type = 51 then
        v_table_name := 'NCI_CLSFCTN_SCHM_ITEM';
    end if;

    v_meta_col_cnt := TEMPLATE_11179.getColumnCount(v_table_name);

    v_sql := TEMPLATE_11179.getSelectSql(v_table_name) || ' where item_id=:item_id and ver_nr=:ver_nr';

    v_cur := dbms_sql.open_cursor;
    dbms_sql.parse(v_cur, v_sql, dbms_sql.native);
    dbms_sql.bind_variable(v_cur, ':item_id',v_item_id);
    dbms_sql.bind_variable(v_cur, ':ver_nr', v_ver_nr);

    for i in 1..v_meta_col_cnt loop
        dbms_sql.define_column(v_cur, i, '', 4000);
    end loop;

    v_temp := dbms_sql.execute_and_fetch(v_cur);
    dbms_sql.describe_columns(v_cur, v_meta_col_cnt, v_meta_desc_tab);


    for i in 1..v_meta_col_cnt loop
        dbms_sql.column_value(v_cur, i, v_col_val);
        ihook.setColumnValue(row, v_meta_desc_tab(i).col_name, v_col_val);
    end loop;
    ihook.setColumnValue(row,'ITEM_ID', v_item_id);
    ihook.setColumnValue(row,'VER_NR', v_ver_nr);

    dbms_sql.close_cursor(v_cur);
end;


procedure spReturnAIRow (v_item_id in number, v_ver_nr in number,row in out t_row) as

    v_table_name      varchar2(30);

begin

    v_table_name := 'ADMIN_ITEM';
    spReturnRow (v_item_id, v_ver_nr, v_table_name, row);
end;


procedure spReturnAIExtRow (v_item_id in number, v_ver_nr in number,row in out t_row) as

    v_table_name      varchar2(30);

begin

    v_table_name := 'NCI_ADMIN_ITEM_EXT';
    spReturnRow (v_item_id, v_ver_nr, v_table_name, row);
end;

procedure spReturnRow (v_item_id in number, v_ver_nr in number,  v_table_name in varchar2, row in out t_row) as
    action           t_actionRowset;
    action_rows              t_rows := t_rows();

    v_sql        varchar2(4000);
    v_cur        number;
    v_temp        number;
    v_col_val       varchar2(4000);

    v_meta_col_cnt      integer;
    v_meta_desc_tab      dbms_sql.desc_tab;
begin


    v_meta_col_cnt := TEMPLATE_11179.getColumnCount(v_table_name);

    v_sql := TEMPLATE_11179.getSelectSql(v_table_name) || ' where item_id=:item_id and ver_nr=:ver_nr';

    v_cur := dbms_sql.open_cursor;
    dbms_sql.parse(v_cur, v_sql, dbms_sql.native);
    dbms_sql.bind_variable(v_cur, ':item_id',v_item_id);
    dbms_sql.bind_variable(v_cur, ':ver_nr', v_ver_nr);

    for i in 1..v_meta_col_cnt loop
        dbms_sql.define_column(v_cur, i, '', 4000);
    end loop;

    v_temp := dbms_sql.execute_and_fetch(v_cur);
    dbms_sql.describe_columns(v_cur, v_meta_col_cnt, v_meta_desc_tab);


    for i in 1..v_meta_col_cnt loop
        dbms_sql.column_value(v_cur, i, v_col_val);
        ihook.setColumnValue(row, v_meta_desc_tab(i).col_name, v_col_val);
    end loop;
    ihook.setColumnValue(row,'ITEM_ID', v_item_id);
    ihook.setColumnValue(row,'VER_NR', v_ver_nr);

    dbms_sql.close_cursor(v_cur);
end;


procedure CopyPermVal (actions in out t_actions, v_from_id in number, v_from_ver_nr in number, v_to_id in number, v_to_ver_nr in number)
as
 v_table_name      varchar2(30);
    v_sql        varchar2(4000);
    v_cur        number;
    v_temp        number;
    v_col_val       varchar2(4000);

    v_meta_col_cnt      integer;
    v_meta_desc_tab      dbms_sql.desc_tab;
    row t_row;
    action_rows t_rows;
    action  t_actionRowset;
begin

action_rows := t_rows();
   v_table_name := 'PERM_VAL';
        v_meta_col_cnt := TEMPLATE_11179.getColumnCount(v_table_name);
        for pv_cur in  (select val_id from perm_val where
        val_dom_item_id = v_from_id and val_dom_ver_nr = v_from_ver_nr) loop

            v_sql := TEMPLATE_11179.getSelectSql(v_table_name) || ' where val_id = :val_id';
            v_cur := dbms_sql.open_cursor;
            dbms_sql.parse(v_cur, v_sql, dbms_sql.native);
            dbms_sql.bind_variable(v_cur, ':val_id', pv_cur.val_id);

            for i in 1..v_meta_col_cnt loop
                dbms_sql.define_column(v_cur, i, '', 4000);
            end loop;

            v_temp := dbms_sql.execute_and_fetch(v_cur);
            dbms_sql.describe_columns(v_cur, v_meta_col_cnt, v_meta_desc_tab);

            row := t_row();

            for i in 1..v_meta_col_cnt loop
                dbms_sql.column_value(v_cur, i, v_col_val);
                ihook.setColumnValue(row, v_meta_desc_tab(i).col_name, v_col_val);
            end loop;

            dbms_sql.close_cursor(v_cur);

            ihook.setColumnValue(row, 'VAL_ID', -1);
            ihook.setColumnValue(row, 'VAL_DOM_VER_NR', v_to_ver_nr);
            ihook.setColumnValue(row, 'VAL_DOM_ITEM_ID', v_to_id);
            ihook.setColumnValue(row, 'NCI_IDSEQ', '');
            action_rows.extend; action_rows(action_rows.last) := row;

        end loop;

         action := t_actionRowset(action_rows, 'Permissible Values (Version)',2, 11, 'insert');
        actions.extend; actions(actions.last) := action;
end;

/*  Create sub-type row for version. Called from spCreateVer */

procedure spCreateSubtypeVerNCI (actions in out t_actions, v_admin_item admin_item%rowtype, v_version number) as
    action           t_actionRowset;
    action_rows              t_rows := t_rows();
    row          t_row;
    v_found boolean;
    v_table_name      varchar2(30);
    v_sql        varchar2(4000);
    v_cur        number;
    v_temp        number;
    v_col_val       varchar2(4000);

    v_meta_col_cnt      integer;
    v_meta_desc_tab      dbms_sql.desc_tab;
begin
    if v_admin_item.admin_item_typ_id = 1 then
        v_table_name := 'CONC_DOM';
    elsif v_admin_item.admin_item_typ_id = 2 then
        v_table_name := 'DE_CONC';
    elsif v_admin_item.admin_item_typ_id = 3 then
        v_table_name := 'VALUE_DOM';
    elsif v_admin_item.admin_item_typ_id = 4 then
        v_table_name := 'DE';
    elsif v_admin_item.admin_item_typ_id = 5 then
        v_table_name := 'OBJ_CLS';
    elsif v_admin_item.admin_item_typ_id = 6 then
        v_table_name := 'PROP';
    elsif v_admin_item.admin_item_typ_id = 7 then
        v_table_name := 'REP_CLS';
    elsif v_admin_item.admin_item_typ_id = 8 then
        v_table_name := 'CNTXT';
    elsif v_admin_item.admin_item_typ_id = 9 then
        v_table_name := 'CLSFCTN_SCHM';
    elsif v_admin_item.admin_item_typ_id = 10 then
        v_table_name := 'DERV_RUL';
    elsif v_admin_item.admin_item_typ_id = 49 then
        v_table_name := 'CNCPT';
    elsif v_admin_item.admin_item_typ_id = 54 then
        v_table_name := 'NCI_FORM';
    end if;

    v_meta_col_cnt := TEMPLATE_11179.getColumnCount(v_table_name);

    v_sql := TEMPLATE_11179.getSelectSql(v_table_name) || ' where item_id=:item_id and ver_nr=:ver_nr';

    v_cur := dbms_sql.open_cursor;
    dbms_sql.parse(v_cur, v_sql, dbms_sql.native);
    dbms_sql.bind_variable(v_cur, ':item_id', v_admin_item.item_id);
    dbms_sql.bind_variable(v_cur, ':ver_nr', v_admin_item.ver_nr);

    for i in 1..v_meta_col_cnt loop
        dbms_sql.define_column(v_cur, i, '', 4000);
    end loop;

    v_temp := dbms_sql.execute_and_fetch(v_cur);
    dbms_sql.describe_columns(v_cur, v_meta_col_cnt, v_meta_desc_tab);

    row := t_row();

    for i in 1..v_meta_col_cnt loop
        dbms_sql.column_value(v_cur, i, v_col_val);
        ihook.setColumnValue(row, v_meta_desc_tab(i).col_name, v_col_val);
    end loop;

    dbms_sql.close_cursor(v_cur);

    ihook.setColumnValue(row, 'VER_NR',v_version);
    ihook.setColumnValue(row, 'LST_UPD_DT',sysdate);

    action_rows.extend; action_rows(action_rows.last) := row;
    action := t_actionRowset(action_rows, v_table_name, 10, 'insert');
    actions.extend; actions(actions.last) := action;

/* Value Domains - then add Permissible Values */
    if v_admin_item.admin_item_typ_id = 3 then -- Add Perm Val
        action_rows := t_rows();
         CopyPermVal ( actions, v_admin_item.item_id, v_admin_item.ver_nr, v_admin_item.item_id, v_version);
    end if;

/*   Conceptual Domain  */
 if v_admin_item.admin_item_typ_id = 1 then -- Conceptual Domain then add CD-VM relationship
        action_rows := t_rows();

        v_table_name := 'CONC_DOM_VAL_MEAN';
        v_meta_col_cnt := TEMPLATE_11179.getColumnCount(v_table_name);

        for cdvm_cur in  (select CONC_DOM_VER_NR, CONC_DOM_ITEM_ID, NCI_VAL_MEAN_ITEM_ID, NCI_VAL_MEAN_VER_NR from conc_dom_val_mean where
        conc_dom_item_id = v_admin_item.item_id and conc_dom_ver_nr = v_admin_item.ver_nr) loop

            v_sql := TEMPLATE_11179.getSelectSql(v_table_name) || ' where CONC_DOM_VER_NR = :conc_dom_ver_nr and CONC_DOM_ITEM_ID = :conc_dom_item_id and NCI_VAL_MEAN_ITEM_ID = :nci_val_mean_item_id and NCI_VAL_MEAN_VER_NR = :nci_val_mean_ver_nr';
            v_cur := dbms_sql.open_cursor;
            dbms_sql.parse(v_cur, v_sql, dbms_sql.native);
            dbms_sql.bind_variable(v_cur, ':conc_dom_ver_nr', cdvm_cur.conc_dom_ver_nr);
            dbms_sql.bind_variable(v_cur, ':conc_dom_item_id', cdvm_cur.conc_dom_item_id);
            dbms_sql.bind_variable(v_cur, ':nci_val_mean_ver_nr', cdvm_cur.nci_val_mean_ver_nr);
            dbms_sql.bind_variable(v_cur, ':nci_val_mean_item_id', cdvm_cur.nci_val_mean_item_id);

            for i in 1..v_meta_col_cnt loop
                dbms_sql.define_column(v_cur, i, '', 4000);
            end loop;

            v_temp := dbms_sql.execute_and_fetch(v_cur);
            dbms_sql.describe_columns(v_cur, v_meta_col_cnt, v_meta_desc_tab);

            row := t_row();

            for i in 1..v_meta_col_cnt loop
                dbms_sql.column_value(v_cur, i, v_col_val);
                ihook.setColumnValue(row, v_meta_desc_tab(i).col_name, v_col_val);
            end loop;

            dbms_sql.close_cursor(v_cur);

            ihook.setColumnValue(row, 'CONC_DOM_VER_NR', v_version);
            action_rows.extend; action_rows(action_rows.last) := row;

        end loop;

        action := t_actionRowset(action_rows, v_table_name, 12, 'insert');
        actions.extend; actions(actions.last) := action;
    end if;


    /*  DE then copy Derived Components */
    if v_admin_item.admin_item_typ_id = 4 then

        action_rows := t_rows();
        v_table_name := 'NCI_ADMIN_ITEM_REL';
        v_meta_col_cnt := TEMPLATE_11179.getColumnCount(v_table_name);

        for de_cur in (select P_ITEM_ID, P_ITEM_VER_NR, C_ITEM_ID, C_ITEM_VER_NR, REL_TYP_ID from NCI_ADMIN_ITEM_REL where
        P_item_id = v_admin_item.item_id and p_ITEM_ver_nr = v_admin_item.ver_nr and rel_typ_id = 66 and nvl(fld_Delete,0) = 0) loop

            v_sql := TEMPLATE_11179.getSelectSql(v_table_name) || ' where P_ITEM_ID = :P_ITEM_ID and P_ITEM_VER_NR = :P_ITEM_VER_NR and C_ITEM_ID = :C_ITEM_ID and C_ITEM_VER_NR = :C_ITEM_VER_NR and REL_TYP_ID=66';

            v_cur := dbms_sql.open_cursor;
            dbms_sql.parse(v_cur, v_sql, dbms_sql.native);
            dbms_sql.bind_variable(v_cur, ':P_ITEM_ID', de_cur.P_ITEM_ID);
            dbms_sql.bind_variable(v_cur, ':P_ITEM_VER_NR', de_cur.P_ITEM_VER_NR);
            dbms_sql.bind_variable(v_cur, ':C_ITEM_ID', de_cur.C_ITEM_ID);
            dbms_sql.bind_variable(v_cur, ':C_ITEM_VER_NR', de_cur.C_ITEM_VER_NR);

            for i in 1..v_meta_col_cnt loop
                dbms_sql.define_column(v_cur, i, '', 4000);
            end loop;

            v_temp := dbms_sql.execute_and_fetch(v_cur);
            dbms_sql.describe_columns(v_cur, v_meta_col_cnt, v_meta_desc_tab);

            row := t_row();

            for i in 1..v_meta_col_cnt loop
                dbms_sql.column_value(v_cur, i, v_col_val);
                ihook.setColumnValue(row, v_meta_desc_tab(i).col_name, v_col_val);
            end loop;

            dbms_sql.close_cursor(v_cur);

            ihook.setColumnValue(row, 'P_ITEM_VER_NR', v_version);
            action_rows.extend; action_rows(action_rows.last) := row;
        end loop;

        action := t_actionRowset(action_rows, 'Derived CDE Component (Data Element CO)',2, 12, 'insert');
        actions.extend; actions(actions.last) := action;
    end if;

/*  If Form  */
    if v_admin_item.admin_item_typ_id = 54 then
    -- Add Modules
     for cur2 in (select c_item_id, c_item_ver_nr, disp_ord from nci_admin_item_rel where p_item_id = v_admin_item.item_id and p_item_ver_nr = v_admin_item.ver_nr
     and nvl(fld_delete,0) = 0) loop
        nci_11179.spCopyModuleNCI(actions, cur2.c_item_id, cur2.c_item_ver_nr, v_admin_item.item_id, v_admin_item.item_id, v_admin_item.item_id, v_version, cur2.disp_ord, 'V');
     end loop;
     -- Add protocols

        action_rows := t_rows();
        v_table_name := 'NCI_ADMIN_ITEM_REL';
        v_meta_col_cnt := TEMPLATE_11179.getColumnCount(v_table_name);
        v_found := false;

        for pro_cur in (select P_ITEM_ID, P_ITEM_VER_NR, C_ITEM_ID, C_ITEM_VER_NR, REL_TYP_ID from NCI_ADMIN_ITEM_REL where
        c_item_id = v_admin_item.item_id and c_ITEM_ver_nr = v_admin_item.ver_nr and rel_typ_id = 60 and nvl(fld_delete,0) = 0) loop
          --    raise_application_error(-20000,'Herer');

            row := t_row();
            ihook.setColumnValue(row, 'P_ITEM_ID', pro_cur.P_ITEM_ID);
          ihook.setColumnValue(row, 'P_ITEM_VER_NR', pro_cur.P_ITEM_VER_NR);
          ihook.setColumnValue(row, 'C_ITEM_ID', pro_cur.C_ITEM_ID);
          ihook.setColumnValue(row, 'REL_TYP_ID', pro_cur.rel_typ_id);
            ihook.setColumnValue(row, 'C_ITEM_VER_NR', v_version);

            v_found  := true;
            action_rows.extend; action_rows(action_rows.last) := row;
        end loop;
      if (v_found) then
        action := t_actionRowset(action_rows, 'Protocol-Form Relationship (Form View)',2, 22, 'insert');
        actions.extend; actions(actions.last) := action;
        end if;
    end if;
end;

/*  Command Hook - Create Version */
procedure spCreateVerNCI (v_data_in in clob, v_data_out out clob, v_user_id varchar2) as

    hookInput           t_hookInput;
    hookOutput           t_hookOutput := t_hookOutput();
    actions           t_actions := t_actions();
    action           t_actionRowset;
    ai_insert_action_rows  t_rows := t_rows();
    ai_update_action_rows  t_rows := t_rows();
    ai_audit_action_rows     t_rows := t_rows();
    row          t_row;

    v_admin_item     admin_item%rowtype;
    v_tab_admin_item   tab_admin_item_pk;

    v_creat_ver     number;
    v_stus_nm     varchar2(100);

    v_table_name      varchar2(30);
    v_sql        varchar2(4000);

    v_cur        number;
    v_temp        number;

    v_version  number(4,2);

    v_col_val       varchar2(4000);
    question    t_question;
    answer     t_answer;
    answers     t_answers;
    showrowset	t_showablerowset;
    forms t_forms;
    form1 t_form;
    rowform t_row;

    row_ori t_row;

    v_meta_col_cnt      integer;
    v_meta_desc_tab      dbms_sql.desc_tab;

begin

    hookInput := ihook.getHookInput(v_data_in);
    hookOutput.invocationNumber := hookInput.invocationNumber;
    hookOutput.originalRowset := hookInput.originalRowset;

    row_ori :=  hookInput.originalRowset.rowset(1);

    /* Check with user has privilege to create version for the context */
    select count(*) into v_temp from  onedata_md.vw_usr_row_filter  v
        where ( ( v.CNTXT_ITEM_ID = ihook.getColumnValue(row_ori, 'CNTXT_ITEM_ID') and v.cntxt_VER_NR  = ihook.getColumnValue(row_ori,'CNTXT_VER_NR')) or v.CNTXT_ITEM_ID = 100) and upper(v.USR_ID) = upper(v_user_id) and v.ACTION_TYP = 'I';

    if v_temp = 0 then
                   hookOutput.message := 'Not authorized to create version in the current context.';
                   v_data_out := ihook.getHookOutput(hookOutput);
                   return;
    end if;

    v_tab_admin_item := template_11179.getParsedAdminItemsData(hookInput.originalRowset);

    select * into v_admin_item from admin_item
    where item_id=v_tab_admin_item(1).item_id and ver_nr=v_tab_admin_item(1).ver_nr
    for update nowait;

     if v_admin_item.currnt_ver_ind = 0 then
        hookOutput.message := 'Cannot create version if the Administered Item is not the latest version.';
        v_data_out := ihook.getHookOutput(hookOutput);
        return;
     end if;

     if (v_admin_item.admin_item_typ_id not in (2,3,4,54)) then -- changed based on new rules from DW 2/3/2021
        hookOutput.message := 'Administered Item of this type cannot be versioned.';
        v_data_out := ihook.getHookOutput(hookOutput);
        return;
    end if;

      /*  if (v_admin_item.regstr_stus_id is null) then
      hookOutput.message := 'Cannot create version for Administered Items with no Registration Status assigned.';
            v_data_out := ihook.getHookOutput(hookOutput);
            return;
        end if;  */

    if hookInput.invocationNumber = 0 then  -- If first invocation, prompt for version number

        ANSWERS                    := T_ANSWERS();
        ANSWER                     := T_ANSWER(1, 1, 'Create Version' );
        ANSWERS.EXTEND;
        ANSWERS(ANSWERS.LAST) := ANSWER;
        QUESTION               := T_QUESTION('Specify New Version, Current Version is: ' || trim(to_char(ihook.getColumnValue(row_ori,'VER_NR' ), '9999.99')) , ANSWERS);
        HOOKOUTPUT.QUESTION    := QUESTION;
        forms                  := t_forms();
        form1                  := t_form('Version Creation', 2,1);
        forms.extend;
        forms(forms.last) := form1;
        hookOutput.forms := forms;
	elsif hookInput.invocationNumber = 1 then  -- Version number specified...
		  if hookInput.answerId = 1 then
            forms              := hookInput.forms;
            form1              := forms(1);
            rowform := form1.rowset.rowset(1);
            v_version := ihook.getColumnValue(rowform,'VER_NR');

            v_table_name := 'ADMIN_ITEM';

            v_meta_col_cnt := TEMPLATE_11179.getColumnCount(v_table_name);

            v_sql := TEMPLATE_11179.getSelectSql(v_table_name) || ' where item_id=:item_id and ver_nr=:ver_nr';
            v_cur := dbms_sql.open_cursor;
            dbms_sql.parse(v_cur, v_sql, dbms_sql.native);
            dbms_sql.bind_variable(v_cur, ':item_id', v_admin_item.item_id);
            dbms_sql.bind_variable(v_cur, ':ver_nr', v_admin_item.ver_nr);

            for i in 1..v_meta_col_cnt loop
                dbms_sql.define_column(v_cur, i, '', 4000);
            end loop;

            v_temp := dbms_sql.execute_and_fetch(v_cur);
            dbms_sql.describe_columns(v_cur, v_meta_col_cnt, v_meta_desc_tab);

            row := t_row();

            for i in 1..v_meta_col_cnt loop
                dbms_sql.column_value(v_cur, i, v_col_val);
                ihook.setColumnValue(row, v_meta_desc_tab(i).col_name, v_col_val);
            end loop;

            dbms_sql.close_cursor(v_cur);
            /*  Change values of the new version row */
            ihook.setColumnValue(row, 'VER_NR', v_version);
            ihook.setColumnValue(row, 'CREAT_USR_ID', hookInput.userId);
            ihook.setColumnValue(row, 'LST_UPD_USR_ID', hookInput.userId);
            ihook.setColumnValue(row, 'ADMIN_STUS_ID', 65 );
            ihook.setColumnValue(row, 'REGSTR_STUS_ID',9 );
            if (v_admin_item.admin_item_typ_id in (54)) then -- Form needs to Draft NEw
                ihook.setColumnValue(row, 'ADMIN_STUS_ID', 66 );
                ihook.setColumnValue(row, 'REGSTR_STUS_ID','' );
            end if;
            ihook.setColumnValue(row, 'NCI_IDSEQ', '');

            ai_insert_action_rows.extend; ai_insert_action_rows(ai_insert_action_rows.last) := row;

            /* set latest version to 0 for current row */
            row := t_row();
            ihook.setColumnValue(row, 'ITEM_ID', v_admin_item.item_id);
            ihook.setColumnValue(row, 'VER_NR', v_admin_item.ver_nr);
            ihook.setColumnValue(row, 'CURRNT_VER_IND', 0);
            ai_update_action_rows.extend; ai_update_action_rows(ai_update_action_rows.last) := row;

            /* Call sub-type creation function */
            spCreateSubtypeVerNCI(actions, v_admin_item, v_version);

            /* Copy all common children */
            spCreateCommonChildrenNCI(actions, v_admin_item.item_id,v_admin_item.ver_nr, v_admin_item.item_id, v_version);

            action := t_actionRowset(ai_insert_action_rows, 'Administered Item (No Sequence)',2, 0, 'insert');
            actions.extend; actions(actions.last) := action;

            action := t_actionRowset(ai_update_action_rows, 'ADMIN_ITEM', 0, 'update');
            actions.extend; actions(actions.last) := action;

            hookOutput.actions := actions;

            hookOutput.message := 'Version created successfully.';
        end if;
    end if;

    v_data_out := ihook.getHookOutput(hookOutput);

     nci_util.debugHook('GENERAL',v_data_out);
    -- insert into junk_debug (id, test) values (sysdate, v_data_out);
    -- commit;

end;

END;
/


DROP PACKAGE BODY ONEDATA_WA.NCI_11179_2;

CREATE OR REPLACE PACKAGE BODY ONEDATA_WA.nci_11179_2 AS

c_ver_suffix varchar2(5) := 'v1.00';
v_dflt_txt    varchar2(100) := 'Enter text or auto-generated.';
DEFAULT_TS_FORMAT    varchar2(50) := 'YYYY-MM-DD HH24:MI:SS';
v_int_cncpt_id  number := 2433736;

function getCollectionId return integer is
v_out integer;
begin
select od_seq_DLOAD_HDR.nextval into v_out from dual;
return v_out;
end;

function isCSParentCSIValid(row in t_row) return boolean is
v_item_id  number;
v_ver_nr number(4,2);
begin
 v_item_id := ihook.getColumnValue(row, 'ITEM_ID');
        v_ver_nr := ihook.getColumnValue(row, 'VER_NR');


for cur in (select * from vw_clsfctn_schm_item where cs_item_id <>  ihook.getColumnValue(row, 'CS_ITEM_ID') and item_id = nvl(ihook.getColumnValue(row, 'P_ITEM_ID'), -1)) loop
    return false;
end loop;

return true;
end;
procedure copyDDEComponents (v_src_item_id in number, v_src_ver_nr in number, v_tgt_item_id in number, v_tgt_ver_nr in number, actions in out t_actions) as
    action           t_actionRowset;
    action_rows              t_rows := t_rows();

    v_sql        varchar2(4000);
    v_cur        number;
    v_temp        number;
    v_col_val       varchar2(4000);

    v_meta_col_cnt      integer;
    v_meta_desc_tab      dbms_sql.desc_tab;
    v_table_name varchar2(100);
    row t_row;

begin

     v_table_name := 'NCI_ADMIN_ITEM_REL';
    action_rows := t_rows();

    v_meta_col_cnt := TEMPLATE_11179.getColumnCount(v_table_name);
      for de_cur in (select P_ITEM_ID, P_ITEM_VER_NR, C_ITEM_ID, C_ITEM_VER_NR, REL_TYP_ID from NCI_ADMIN_ITEM_REL where
        P_item_id = v_src_item_id and p_ITEM_ver_nr = v_src_ver_nr and rel_typ_id = 66 and nvl(fld_Delete,0) = 0) loop

            v_sql := TEMPLATE_11179.getSelectSql(v_table_name) || ' where P_ITEM_ID = :P_ITEM_ID and P_ITEM_VER_NR = :P_ITEM_VER_NR and C_ITEM_ID = :C_ITEM_ID and C_ITEM_VER_NR = :C_ITEM_VER_NR and REL_TYP_ID=66';

            v_cur := dbms_sql.open_cursor;
            dbms_sql.parse(v_cur, v_sql, dbms_sql.native);
            dbms_sql.bind_variable(v_cur, ':P_ITEM_ID', de_cur.P_ITEM_ID);
            dbms_sql.bind_variable(v_cur, ':P_ITEM_VER_NR', de_cur.P_ITEM_VER_NR);
            dbms_sql.bind_variable(v_cur, ':C_ITEM_ID', de_cur.C_ITEM_ID);
            dbms_sql.bind_variable(v_cur, ':C_ITEM_VER_NR', de_cur.C_ITEM_VER_NR);

            for i in 1..v_meta_col_cnt loop
                dbms_sql.define_column(v_cur, i, '', 4000);
            end loop;

            v_temp := dbms_sql.execute_and_fetch(v_cur);
            dbms_sql.describe_columns(v_cur, v_meta_col_cnt, v_meta_desc_tab);

            row := t_row();

            for i in 1..v_meta_col_cnt loop
                dbms_sql.column_value(v_cur, i, v_col_val);
                ihook.setColumnValue(row, v_meta_desc_tab(i).col_name, v_col_val);
            end loop;

            dbms_sql.close_cursor(v_cur);
         ihook.setColumnValue(row, 'P_ITEM_ID', v_tgt_item_id);

            ihook.setColumnValue(row, 'P_ITEM_VER_NR', v_tgt_ver_nr);
            action_rows.extend; action_rows(action_rows.last) := row;
        end loop;

        if (action_rows.count> 0) then
        action := t_actionRowset(action_rows, 'Derived CDE Component (Data Element CO)',2, 14, 'insert');
        actions.extend; actions(actions.last) := action;
        end if;



end;


procedure spAddAIToCartID (v_data_in in clob, v_data_out out clob, v_usr_id  IN varchar2)
AS
    hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();

    actions t_actions := t_actions();
    action t_actionRowset;
    row t_row;
    row_sel t_row;
    rows  t_rows;
    rowscart  t_rows;
    row_ori t_row;
    v_item_id  number;
    v_ver_nr number(4,2);
    v_temp integer;
    v_add integer :=0;
    v_already integer :=0;
    i integer := 0;
    v_item_typ_id integer;
    v_found boolean;
    v_str varchar2(4000);
    cnt integer;
 forms t_forms;
  form1 t_form;

begin
    hookinput := ihook.gethookinput (v_data_in);
    hookoutput.invocationnumber  := hookinput.invocationnumber;
    hookoutput.originalrowset    := hookinput.originalrowset;
--raise_application_error(-20000, v_usr_id);

    if (hookinput.invocationnumber = 0) then   -- First invocation
         forms                  := t_forms();
        form1                  := t_form('Add Item to Collection (Hook)', 2,1);
        forms.extend;    forms(forms.last) := form1;
        hookoutput.forms := forms;
       	 hookOutput.question := nci_dload.getAddComponentCreateQuestion;
	end if;

    if hookInput.invocationNumber = 1  then  -- Seconf invocation

        forms              := hookInput.forms;
        form1              := forms(1);
        row_sel := form1.rowset.rowset(1);
        v_str := trim(ihook.getColumnValue(row_sel, 'VM_DESC_TXT'));
             cnt := nci_11179.getwordcount(v_str);

          rowscart := t_rows();

         for i in  1..cnt loop
                        v_item_id := nci_11179.getWord(v_str, i, cnt);
        for cur in (select * from admin_item where item_id = v_item_id and currnt_ver_ind = 1 and admin_item_typ_id in (4,52,54) and (item_id, ver_nr) not in
        (select item_id, ver_nr from nci_usr_cart  where cntct_secu_id = v_usr_id)) loop

        row := t_row();
            ihook.setColumnValue(row, 'ITEM_ID', cur.item_id);
            ihook.setColumnValue(row, 'VER_NR', cur.ver_nr);
           ihook.setColumnValue(row,'CNTCT_SECU_ID', v_usr_id);
            --   ihook.setColumnValue(row,'CNTCT_SECU_ID', 'DWARZEL');

            ihook.setColumnValue(row,'GUEST_USR_NM', 'NONE');
                	rowscart.extend;
                    rowscart (rowscart.last) := row;


 end loop;
end loop;
        -- If Item needs to be added.

            /*  If item not already in cart */
            if (rowscart.count  > 0) then
                action := t_actionrowset(rowscart, 'User Cart', 2,0,'insert');
                actions.extend;
                actions(actions.last) := action;
            end if;

        if (actions.count > 0) then
            hookoutput.actions := actions;
        end if;
             hookoutput.message := 'Number of items added to cart: ' || rowscart.count;
   end if;
V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
END;


procedure spBulkUpdateContext (v_data_in in clob, v_data_out out clob, v_user_id in varchar2)
as
 hookInput t_hookInput;
  hookOutput t_hookOutput := t_hookOutput();
   actions t_actions := t_actions();
  action t_actionRowset;
  row t_row;
  rows  t_rows;
    row_ori t_row;
    rowform t_row;
    v_id integer;
  action_rows       t_rows := t_rows();
  action_row		    t_row;
  rowset            t_rowset;
 question    t_question;
answer     t_answer;
answers     t_answers;
showrowset	t_showablerowset;
forms     t_forms;
v_itemid     integer;
v_found boolean;
  v_temp integer;
  v_stg_ai_id number;
  i integer := 0;
  column  t_column;
  msg varchar2(4000);
  v_item_typ  integer;

  form1 t_form;
BEGIN
  hookinput                    := Ihook.gethookinput (v_data_in);
  hookoutput.invocationnumber  := hookinput.invocationnumber;
  hookoutput.originalrowset    := hookinput.originalrowset;


  if(hookinput.originalrowset.rowset.count > 0) then
  raise_application_error(-20000, 'Bulk change applies to to all items in the caDSR and not the selected/filtered items. Please deselect items and re-select the command.');
  end if;

    if hookInput.invocationNumber = 0 then

    forms                  := t_forms();
    form1                  := t_form('Context Bulk Change (Hook)', 2,1);
    forms.extend;    forms(forms.last) := form1;
  hookoutput.forms := forms;
       	 answers := t_answers();
  	   	 answer := t_answer(1, 1, 'Reassign');
  	   	 answers.extend; answers(answers.last) := answer;

	   	 question := t_question('Reassign Item Context', answers);
       	 hookOutput.question := question;

	end if;

    if hookInput.invocationNumber = 1  then
            rows :=         t_rows();
             forms              := hookInput.forms;
           form1              := forms(1);
      rowform := form1.rowset.rowset(1);

        if (nvl(ihook.getColumnValue(rowform,'IND_ALL_TYPES'),0) = 1) then
            update admin_item set cntxt_item_id = ihook.getColumnValue(rowform,'TO_CNTXT_ITEM_ID'), cntxt_ver_nr = ihook.getColumnValue(rowform,'TO_CNTXT_VER_NR')
            where cntxt_item_id = ihook.getColumnValue(rowform,'CNTXT_ITEM_ID') and cntxt_ver_nr = ihook.getColumnValue(rowform,'CNTXT_VER_NR');
            commit;
        else
        for i in 1..60 loop
        if (nvl(ihook.getColumnValue(rowform,'IND_TYP_' || i),0) = 1) then
        update admin_item set cntxt_item_id = ihook.getColumnValue(rowform,'TO_CNTXT_ITEM_ID'), cntxt_ver_nr = ihook.getColumnValue(rowform,'TO_CNTXT_VER_NR')
            where cntxt_item_id = ihook.getColumnValue(rowform,'CNTXT_ITEM_ID') and cntxt_ver_nr =  ihook.getColumnValue(rowform,'CNTXT_VER_NR') and admin_item_typ_id = i;
        end if;
        end loop;
        end if;

        if (nvl(ihook.getColumnValue(rowform,'IND_ALL_TYPES'),0) = 1 or nvl(ihook.getColumnValue(rowform,'IND_ALT_NMS'),0) = 1 ) then
              update alt_nms set cntxt_item_id = ihook.getColumnValue(rowform,'TO_CNTXT_ITEM_ID'), cntxt_ver_nr = ihook.getColumnValue(rowform,'TO_CNTXT_VER_NR')
            where cntxt_item_id = ihook.getColumnValue(rowform,'CNTXT_ITEM_ID') and cntxt_ver_nr =  ihook.getColumnValue(rowform,'CNTXT_VER_NR') ;

        end if;
            if (nvl(ihook.getColumnValue(rowform,'IND_ALL_TYPES'),0) = 1 or nvl(ihook.getColumnValue(rowform,'IND_ALT_DEF'),0) = 1 ) then
              update alt_def set cntxt_item_id = ihook.getColumnValue(rowform,'TO_CNTXT_ITEM_ID'), cntxt_ver_nr = ihook.getColumnValue(rowform,'TO_CNTXT_VER_NR')
            where cntxt_item_id = ihook.getColumnValue(rowform,'CNTXT_ITEM_ID') and cntxt_ver_nr =  ihook.getColumnValue(rowform,'CNTXT_VER_NR') ;

        end if;
              if (nvl(ihook.getColumnValue(rowform,'IND_ALL_TYPES'),0) = 1 or nvl(ihook.getColumnValue(rowform,'IND_REF_DOC'),0) = 1 ) then
              update ref set nci_cntxt_item_id = ihook.getColumnValue(rowform,'TO_CNTXT_ITEM_ID'), nci_cntxt_ver_nr = ihook.getColumnValue(rowform,'TO_CNTXT_VER_NR')
            where nci_cntxt_item_id = ihook.getColumnValue(rowform,'CNTXT_ITEM_ID') and nci_cntxt_ver_nr =  ihook.getColumnValue(rowform,'CNTXT_VER_NR') ;

        end if;



        hookoutput.message := 'Context reassigned.';
    end if;
  V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
 -- nci_util.debugHook('GENERAL',v_data_out);

END;


procedure spBulkUpdateCSI (v_data_in in clob, v_data_out out clob, v_user_id in varchar2)
as
 hookInput t_hookInput;
  hookOutput t_hookOutput := t_hookOutput();
   actions t_actions := t_actions();
  action t_actionRowset;
  row t_row;
  rows  t_rows;
    row_ori t_row;
    rowform t_row;
    v_id integer;
  action_rows       t_rows := t_rows();
  action_row		    t_row;
  rowset            t_rowset;
 question    t_question;
answer     t_answer;
answers     t_answers;
showrowset	t_showablerowset;
forms     t_forms;
v_itemid     integer;
v_found boolean;
  v_temp integer;
  v_stg_ai_id number;
  i integer := 0;
  column  t_column;
  msg varchar2(4000);
  v_item_typ  integer;

  form1 t_form;
BEGIN
  hookinput                    := Ihook.gethookinput (v_data_in);
  hookoutput.invocationnumber  := hookinput.invocationnumber;
  hookoutput.originalrowset    := hookinput.originalrowset;

  if(hookinput.originalrowset.rowset.count > 0) then
  raise_application_error(-20000, 'Bulk change applies to to all items in the caDSR and not the selected/filtered items. Please deselect items and re-select the command.');
  end if;

    if hookInput.invocationNumber = 0 then

    forms                  := t_forms();
    form1                  := t_form('CSI Bulk Change (Hook)', 2,1);
    forms.extend;    forms(forms.last) := form1;
  hookoutput.forms := forms;
       	 answers := t_answers();
  	   	 answer := t_answer(1, 1, 'Reassign');
  	   	 answers.extend; answers(answers.last) := answer;

	   	 question := t_question('Reassign Item CSI.', answers);
       	 hookOutput.question := question;

	end if;

    if hookInput.invocationNumber = 1  then
            rows :=         t_rows();
             forms              := hookInput.forms;
             form1              := forms(1);
             rowform := form1.rowset.rowset(1);


       update nci_admin_item_rel set p_item_id = ihook.getColumnValue(rowform, 'TO_CNTXT_ITEM_ID'), p_item_ver_nr =  ihook.getColumnValue(rowform, 'TO_CNTXT_VER_NR') where rel_typ_id = 65 and
       p_item_id = ihook.getColumnValue(rowform, 'CNTXT_ITEM_ID') and p_item_ver_nr =  ihook.getColumnValue(rowform, 'CNTXT_VER_NR');
       commit;

       update NCI_CSI_ALT_DEFNMS set NCI_PUB_ID = ihook.getColumnValue(rowform, 'TO_CNTXT_ITEM_ID'), NCI_VER_NR =  ihook.getColumnValue(rowform, 'TO_CNTXT_VER_NR') where
       NCI_PUB_ID = ihook.getColumnValue(rowform, 'CNTXT_ITEM_ID') and NCI_VER_NR =  ihook.getColumnValue(rowform, 'CNTXT_VER_NR');
       commit;


        hookoutput.message := 'CSI reassigned.';
    end if;
  V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
 -- nci_util.debugHook('GENERAL',v_data_out);

END;

function getStdDataType (v_data_typ_id in number) return number
is
v_temp number;
begin

select nvl(dttype_id,0) into v_temp from data_typ where nci_dttype_typ_id = 2 and
upper(dttype_nm) in ( select upper(nci_dttype_map) from data_typ where nci_dttype_typ_id = 1 and dttype_id = v_data_typ_id);

return v_temp;
end;

procedure setItemLongNm(row in out t_row, v_id in number) as
begin
 ihook.setColumnValue(row,'ITEM_LONG_NM', v_id || c_ver_suffix);
end;

function getStdShortName (v_item_id in number, v_ver_nr in number) return varchar2
is
begin
return  v_item_id ||  'v' || trim(to_char(v_ver_nr, '9999.99'));
end;

procedure stdAIValidation(rowai in t_row,  v_item_typ_id in number, v_valid in out boolean, v_err_str out varchar2) as
v_cntxt_id  number;
v_cntxt_ver_nr number;
begin

for cur in (select * from vw_admin_stus where stus_id = nvl(ihook.getColumnValue(rowai, 'ADMIN_STUS_ID'),-1) and upper(stus_nm) like '%RETIRED%'
and ihook.getColumnValue(rowai, 'UNTL_DT') is null) loop
    v_valid := false;
    v_err_str := 'Cannot retire an Administered Item without expiration date.';
    return;
end loop;
for cur in (select * from vw_admin_stus where ihook.getColumnValue(rowai, 'UNTL_DT') is not null and ihook.getColumnValue(rowai, 'UNTL_DT') < nvl(ihook.getColumnValue(rowai, 'EFF_DT'), sysdate) ) loop
    v_valid := false;
    v_err_str := 'Expiration date has to be the same or greater than Effective date.';
    return;
end loop;

for cur in (select ai.item_id item_id from admin_item ai
            where
            trim(ai.ITEM_LONG_NM)=trim(ihook.getColumnValue(rowai,'ITEM_LONG_NM'))
        --    and  ai.ver_nr =  ihook.getColumnValue(rowai, 'VER_NR')
            and ai.cntxt_item_id = ihook.getColumnValue(rowai, 'CNTXT_ITEM_ID')
            and  ai.cntxt_ver_nr = ihook.getColumnValue(rowai, 'CNTXT_VER_NR')
            and ai.item_id <>  nvl(ihook.getColumnValue(rowai, 'ITEM_ID'),0)
            and ai.admin_item_typ_id = v_item_typ_id
            and ihook.getColumnValue(rowai,'ITEM_LONG_NM') <> v_dflt_txt)
            loop
                v_valid := false;
                v_err_str := 'Duplicate found based on context/short name: ' || cur.item_id || chr(13);
                return;
            end loop;

end;


procedure stdCncptRowValidation(rowcncpt in t_row,  v_idx in number, v_valid in out boolean, v_err_str in out varchar2) as
i  integer;

begin
for i in 1..10 loop
    if (ihook.getColumnValue(rowcncpt, 'CNCPT_' || v_idx  ||'_ITEM_ID_' || i) = v_int_cncpt_id and
    ihook.getColumnValue(rowcncpt,'CNCPT_INT_' || v_idx || '_' || i) is null) then
        v_valid := false;
    v_err_str := v_err_str || ' ' || 'Value for Integer Concept missing.';
    end if;
end loop;
end;

procedure setStdAttr(row in out t_row)
as
begin
       ihook.setColumnValue(row,'ADMIN_STUS_ID',66 );
               ihook.setColumnValue(row,'REGSTR_STUS_ID',9 );
       ihook.setColumnValue(row, 'CURRNT_VER_IND', 1);
       ihook.setColumnValue(row, 'VER_NR', 1);
     ihook.setColumnValue(row, 'EFF_DT', to_char(sysdate, DEFAULT_TS_FORMAT));
ihook.setColumnValue(row, 'UNTL_DT', '');
    -- ihook.setColumnValue(row, 'ADMIN_NOTES', '2001/1/1');



end;

function isUserAuth(v_item_id in number, v_ver_nr in number,v_user_id in varchar2) return boolean  iS
v_auth boolean := false;
v_temp integer;
v_temp1 integer;
begin
select count(*) into v_temp from  onedata_md.vw_usr_row_filter  v, admin_item ai
        where ( ( v.CNTXT_ITEM_ID = ai.CNTXT_ITEM_ID and v.cntxt_VER_NR  = ai.CNTXT_VER_NR) or v.CNTXT_ITEM_ID = 100) and upper(v.USR_ID) = upper(v_user_id) and v.ACTION_TYP = 'I'
        and ai.item_id =v_item_id and ai.ver_nr = v_ver_nr;

-- If the item id sent are context item id and version number
select count(*) into v_temp1 from  onedata_md.vw_usr_row_filter  v
        where  ( v.CNTXT_ITEM_ID = v_item_id and v.cntxt_VER_NR  = v_ver_nr) and upper(v.USR_ID) = upper(v_user_id) and v.ACTION_TYP = 'I';

if (v_temp = 0 and v_temp1 = 0) then return false; else return true; end if;
end;


procedure spCheckUserAuth (v_data_in in clob, v_data_out out clob, v_user_id in varchar2)
as
    hookInput           t_hookInput;
    hookOutput           t_hookOutput := t_hookOutput();
    showRowset     t_showableRowset;

    rows      t_rows;
    row          t_row;
    row_ori t_row;
    row_cur t_row;
    v_item_id number;
    v_ver_nr number(4,2);

begin


    hookInput := ihook.getHookInput(v_data_in);
    hookOutput.invocationNumber := hookInput.invocationNumber;
    hookOutput.originalRowset := hookInput.originalRowset;

    row_ori := hookInput.originalRowset.rowset(1);


    if (hookinput.originalRowset.tablename  in ( 'ALT_DEF', 'ALT_NMS', 'REF')) then
        v_item_id := ihook.getColumnValue(row_ori, 'ITEM_ID');
        v_ver_nr := ihook.getColumnValue(row_ori, 'VER_NR');
    elsif (hookinput.originalRowset.tablename = 'NCI_ADMIN_ITEM_REL' and ihook.getColumnValue(row_ori,'REL_TYP_ID') = 60) then   ---  protocol
        v_item_id := ihook.getColumnValue(row_ori, 'C_ITEM_ID');
        v_ver_nr := ihook.getColumnValue(row_ori, 'C_ITEM_VER_NR');
    elsif hookinput.originalRowset.tablename = 'PERM_VAL' then
        v_item_id := ihook.getColumnValue(row_ori, 'VAL_DOM_ITEM_ID');
        v_ver_nr := ihook.getColumnValue(row_ori, 'VAL_DOM_VER_NR');
    elsif hookinput.originalRowset.tablename = 'REF_DOC' then
        select nci_cntxt_item_id, nci_cntxt_ver_nr into v_item_id, v_ver_nr from ref where
        ref_id = ihook.getColumnValue(row_ori, 'NCI_REF_ID');
    elsif   (hookinput.originalRowset.tablename = 'NCI_ADMIN_ITEM_REL' and ihook.getColumnValue(row_ori,'REL_TYP_ID') = 61 ) then   --- Module
        v_item_id := ihook.getColumnValue(row_ori,'P_ITEM_ID');
        v_ver_nr := ihook.getColumnValue(row_ori,'P_ITEM_VER_NR');
    elsif   (hookinput.originalRowset.tablename = 'NCI_ADMIN_ITEM_REL_ALT_KEY') then -- Question
        select p_item_id, p_item_ver_nr into v_item_id, v_ver_nr from nci_admin_item_rel where rel_typ_id = 61 and
        c_item_id = ihook.getColumnValue(row_ori, 'P_ITEM_ID') and c_item_ver_nr = ihook.getColumnValue(row_ori, 'P_ITEM_VER_NR');
    elsif   (hookinput.originalRowset.tablename = 'NCI_QUEST_VV_REP') then -- Question Repetision
        select frm_item_id, frm_ver_nr into v_item_id, v_ver_nr from vw_nci_module_de where
        nci_pub_id = ihook.getColumnValue(row_ori, 'QUEST_PUB_ID') and nci_ver_nr = ihook.getColumnValue(row_ori, 'QUEST_VER_NR');
    elsif   (hookinput.originalRowset.tablename = 'NCI_QUEST_VALID_VALUE') then -- Question Repetision
        select aim.p_item_id, aim.p_item_ver_nr into v_item_id, v_ver_nr from nci_admin_item_rel_alt_key air,  nci_admin_item_rel aim where
                air.nci_pub_id = ihook.getColumnValue(row_ori, 'Q_PUB_ID') and air.nci_ver_nr = ihook.getColumnValue(row_ori, 'Q_VER_NR')
                and air.p_item_id = aim.c_item_id and air.p_item_ver_nr = aim.c_item_ver_nr;

 end if;

     if (isUserAuth(v_item_id, v_ver_nr, v_user_id) = false) then
     raise_application_error(-20000, 'You are not authorized to insert/update or delete in this context. ');
        return;
    end if;

    if (hookinput.originalRowset.tablename = 'NCI_ADMIN_ITEM_REL' and ihook.getColumnValue(row_ori,'REL_TYP_ID') = 60) then   ---  checked form before. Now check Protocol
        v_item_id := ihook.getColumnValue(row_ori, 'P_ITEM_ID');
        v_ver_nr := ihook.getColumnValue(row_ori, 'P_ITEM_VER_NR');

        if (isUserAuth(v_item_id, v_ver_nr, v_user_id) = false) then
            raise_application_error(-20000, 'You are not authorized to insert/update or delete in this context. ');
            return;
        end if;
    end if;

    V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);

end;

/*  Pop-up compare DE for selected rows */
procedure spNCICompareDE (v_data_in in clob, v_data_out out clob)
as

    hookInput           t_hookInput;
    hookOutput           t_hookOutput := t_hookOutput();
    showRowset     t_showableRowset;

    rows      t_rows;
    row          t_row;
    row_cur t_row;

    v_found      boolean;

    v_val_mean_desc    val_mean.val_mean_desc%type;
    v_perm_val_nm    perm_val.perm_val_nm%type;
    v_item_id		 number;
    v_ver_nr		 number;
begin

    hookInput := ihook.getHookInput(v_data_in);
    hookOutput.invocationNumber := hookInput.invocationNumber;
    hookOutput.originalRowset := hookInput.originalRowset;

    rows := t_rows();

    /* Iterate through all the selected Data Elements */
    for i in 1 .. hookInput.originalRowset.Rowset.count loop
        row := t_row();
        row_cur := hookInput.originalRowset.Rowset(i);
        ihook.setColumnValue(row,'ITEM_ID', ihook.getColumnValue(row_cur,'ITEM_ID'));
        ihook.setColumnValue(row,'VER_NR', ihook.getColumnValue(row_cur,'VER_NR'));
        rows.extend; rows(rows.last) := row;
    end loop;

    showRowset := t_showableRowset(rows, 'NCI Data Element Details (for Compare)',2, 'unselectable');
    hookOutput.showRowset := showRowset;

    hookOutput.message := 'Data Element Compare';
    v_data_out := ihook.getHookOutput(hookOutput);
end;

/*  Pop-up compare VD for selected rows */
procedure spNCICompareVD (v_data_in in clob, v_data_out out clob)
as

    hookInput           t_hookInput;
    hookOutput           t_hookOutput := t_hookOutput();
    showRowset     t_showableRowset;

    rows      t_rows;
    row          t_row;
    row_cur t_row;


    v_found      boolean;
    v_item_id		 number;
    v_ver_nr		 number;
begin

    hookInput := ihook.getHookInput(v_data_in);
    hookOutput.invocationNumber := hookInput.invocationNumber;
    hookOutput.originalRowset := hookInput.originalRowset;

    rows := t_rows();

    /* Iterate through all the selected VALUE Domains */
    for i in 1 .. hookInput.originalRowset.Rowset.count loop
        row := t_row();
        row_cur := hookInput.originalRowset.Rowset(i);
        ihook.setColumnValue(row,'ITEM_ID', ihook.getColumnValue(row_cur,'ITEM_ID'));
        ihook.setColumnValue(row,'VER_NR', ihook.getColumnValue(row_cur,'VER_NR'));
        rows.extend; rows(rows.last) := row;
    end loop;

    showRowset := t_showableRowset(rows, 'Compare Value Domains',2, 'unselectable');
    hookOutput.showRowset := showRowset;

    hookOutput.message := 'Value Domain Compare';
    v_data_out := ihook.getHookOutput(hookOutput);
end;


/* PV Dependency called from NCI Data Elements */
procedure spNCIShowVMDependency (v_data_in in clob, v_data_out out clob)
as
    hookInput           t_hookInput;
    hookOutput           t_hookOutput := t_hookOutput();
    showRowset     t_showableRowset;

    rows      t_rows;
    row          t_row;
    row_cur t_row;

    v_admin_item                admin_item%rowtype;
    v_tab_admin_item            tab_admin_item_pk;

    v_found      boolean;

    type t_val_mean_cd is table of nci_admin_item_ext.cncpt_concat%type;
    type t_val_mean_nm is table of nci_admin_item_ext.cncpt_concat_nm%type;

    v_tab_val_mean_cd  t_val_mean_cd := t_val_mean_cd();
    v_tab_val_mean_nm  t_val_mean_nm := t_val_mean_nm();

    v_tab_val_dom    tab_admin_item_pk := tab_admin_item_pk();

    type      t_admin_item_nm is table of admin_item.item_nm%type;
    v_tab_admin_item_nm   t_admin_item_nm := t_admin_item_nm();

    v_val_mean_desc    val_mean.val_mean_desc%type;
    v_perm_val_nm    perm_val.perm_val_nm%type;
    v_item_id		 number;
    v_ver_nr		 number;
    vd_id_nm     varchar2(300);
begin

    hookInput := ihook.getHookInput(v_data_in);
    hookOutput.invocationNumber := hookInput.invocationNumber;
    hookOutput.originalRowset := hookInput.originalRowset;

-- saving all unique val_mean_ids from submitted admin items into v_tab_val_mean_id
    for i in 1 .. hookInput.originalRowset.Rowset.count loop
        row_cur := hookInput.originalRowset.Rowset(i);

        for rec in (  select nci_val_mean_item_id, nci_val_mean_ver_nr, cncpt_concat, cncpt_concat_nm from perm_val pv, nci_admin_item_ext ext
        where val_dom_item_id=ihook.getColumnValue(row_cur,'VAL_DOM_ITEM_ID')
        and val_dom_ver_nr=ihook.getColumnValue(row_cur,'VAL_DOM_VER_NR') and pv.fld_delete=0 and
        pv.nci_val_mean_item_id = ext.item_id and pv.nci_val_mean_ver_nr = ext.ver_nr) loop
            v_found := false;
            for j in 1..v_tab_val_mean_cd.count loop
                    v_found := v_found or v_tab_val_mean_cd(j)=rec.cncpt_concat;
            end loop;

            if not v_found then
                v_tab_val_mean_cd.extend();
                v_tab_val_mean_nm.extend();
                v_tab_val_mean_cd(v_tab_val_mean_cd.count) := rec.cncpt_concat;
                v_tab_val_mean_nm(v_tab_val_mean_nm.count) := rec.cncpt_concat_nm;
            end if;
    end loop;

     v_tab_admin_item_nm.extend();
     select ai.item_id || '-' || ai.item_nm into  vd_id_nm from admin_item ai, de where ai.item_id = de.val_dom_item_id and ai.ver_nr = de.val_dom_ver_nr and de.item_id =ihook.getColumnValue(row_cur,'ITEM_ID')
      and de.ver_nr = ihook.getColumnValue(row_cur,'VER_NR');

      v_tab_admin_item_nm(v_tab_admin_item_nm.count) := 'CDE:' || ihook.getColumnValue(row_cur,'ITEM_ID') || '-' || ihook.getColumnValue(row_cur,'ITEM_NM') || chr(13) || 'VD:' ||  vd_id_nm ;
    end loop;

    -- populating val means/perm vals
    rows := t_rows();
    for i in 1 .. v_tab_val_mean_cd.count loop
        row := t_row();
        ihook.setColumnValue(row, 'Concept Code', v_tab_val_mean_cd(i));
        ihook.setColumnValue(row, 'Concept Name', nci_11179.replaceChar(v_tab_val_mean_nm(i)));

        for j in 1 .. hookInput.originalRowset.Rowset.count loop
            row_cur := hookInput.originalRowset.Rowset(j);
            v_perm_val_nm := '';
            for rec in   (select perm_val_nm   from perm_val a, nci_admin_item_Ext ext
            where nci_val_mean_item_id=ext.item_id  and nci_val_mean_ver_nr = ext.ver_nr and ext.cncpt_concat = v_tab_val_mean_cd(i)
            and val_dom_item_id=ihook.getColumnValue(row_cur,'VAL_DOM_ITEM_ID')
            and val_dom_ver_nr=ihook.getColumnValue(row_cur,'VAL_DOM_VER_NR') and a.fld_delete=0) loop
                v_perm_val_nm := rec.perm_val_nm;
            end loop;
            ihook.setColumnValue(row, v_tab_admin_item_nm(j), nci_11179.replaceChar(v_perm_val_nm));
        end loop;
        rows.extend; rows(rows.last) := row;
    end loop;

    showRowset := t_showableRowset(rows, 'Permissible Value Comparison',4, 'unselectable');
    hookOutput.showRowset := showRowset;

    v_data_out := ihook.getHookOutput(hookOutput);

end;

/*  Show PV comparison from ADministereds Item */

procedure spNCIShowVMDependencyDS (v_data_in in clob, v_data_out out clob)
as

    hookInput           t_hookInput;
    hookOutput           t_hookOutput := t_hookOutput();
    showRowset     t_showableRowset;

    rows      t_rows;
    row          t_row;
    row_cur t_row;
    row_ori  t_row;
    v_hdr_id number;

    v_admin_item                admin_item%rowtype;
    v_tab_admin_item            tab_admin_item_pk;

    v_found      boolean;

    type t_val_mean_cd is table of nci_admin_item_ext.cncpt_concat%type;
    type t_val_mean_nm is table of nci_admin_item_ext.cncpt_concat_nm%type;

    v_tab_val_mean_cd  t_val_mean_cd := t_val_mean_cd();
    v_tab_val_mean_nm  t_val_mean_nm := t_val_mean_nm();

    v_tab_val_dom    tab_admin_item_pk := tab_admin_item_pk();

    type      t_admin_item_nm is table of admin_item.item_nm%type;
    v_tab_admin_item_nm   t_admin_item_nm := t_admin_item_nm();

    v_val_mean_desc    val_mean.val_mean_desc%type;
    v_perm_val_nm    perm_val.perm_val_nm%type;
    v_item_id		 number;
    v_ver_nr		 number;
    vd_id_nm    varchar2(300);
begin

    hookInput := ihook.getHookInput(v_data_in);
    hookOutput.invocationNumber := hookInput.invocationNumber;
    hookOutput.originalRowset := hookInput.originalRowset;

 row_ori := hookInput.originalRowset.rowset (1);
 v_hdr_id := ihook.getColumnValue(row_ori, 'HDR_ID');
-- saving all unique val_mean_ids from submitted admin items into v_tab_val_mean_id

    for i in 1 .. hookInput.originalRowset.Rowset.count loop
        row_cur := hookInput.originalRowset.Rowset(i);

        for rec in (  select nci_val_mean_item_id, nci_val_mean_ver_nr, cncpt_concat, cncpt_concat_nm from perm_val pv, nci_admin_item_ext ext, de
        where pv.val_dom_item_id=de.val_dom_item_id and de.item_id = ihook.getColumnValue(row_cur,'ITEM_ID')
        and pv.val_dom_ver_nr=de.val_dom_ver_nr and de.ver_nr = ihook.getColumnValue(row_cur,'VER_NR') and pv.fld_delete=0 and
        pv.nci_val_mean_item_id = ext.item_id and pv.nci_val_mean_ver_nr = ext.ver_nr) loop

            v_found := false;
            for j in 1..v_tab_val_mean_cd.count loop
                    v_found := v_found or v_tab_val_mean_cd(j)=rec.cncpt_concat;
            end loop;
            if not v_found then
                v_tab_val_mean_cd.extend();
                v_tab_val_mean_nm.extend();
                v_tab_val_mean_cd(v_tab_val_mean_cd.count) := rec.cncpt_concat;
                v_tab_val_mean_nm(v_tab_val_mean_nm.count) := rec.cncpt_concat_nm;
            end if;
        end loop;

        v_tab_admin_item_nm.extend();
        select ai.item_id || '-' || ai.item_nm into  vd_id_nm from admin_item ai, de where ai.item_id = de.val_dom_item_id and ai.ver_nr = de.val_dom_ver_nr and de.item_id =ihook.getColumnValue(row_cur,'ITEM_ID')
        and de.ver_nr = ihook.getColumnValue(row_cur,'VER_NR');

        v_tab_admin_item_nm(v_tab_admin_item_nm.count) := 'CDE:' || ihook.getColumnValue(row_cur,'ITEM_ID') || '-' || ihook.getColumnValue(row_cur,'ITEM_NM') || chr(13) || 'VD:' ||  vd_id_nm ;
    end loop;

        v_tab_admin_item_nm.extend();

        v_tab_admin_item_nm(v_tab_admin_item_nm.count) := 'Input' ;

    -- populating val means/perm vals
    rows := t_rows();
    for i in 1 .. v_tab_val_mean_cd.count loop

        row := t_row();
        if (v_tab_val_mean_cd(i) = v_tab_val_mean_nm(i)) then
         --   ihook.setColumnValue(row, 'Concept Code', 'No Concepts');
          ihook.setColumnValue(row, 'VM Concept Codes', '');
        else
        ihook.setColumnValue(row, 'VM Concept Codes', v_tab_val_mean_cd(i));
        end if;
        ihook.setColumnValue(row, 'VM Concept Names', nci_11179.replaceChar(v_tab_val_mean_nm(i)));

        for j in 1 .. hookInput.originalRowset.Rowset.count loop
           row_cur := hookInput.originalRowset.Rowset(j);

            v_perm_val_nm := '';
            for rec in   (select perm_val_nm   from perm_val a, nci_admin_item_Ext ext, de
            where nci_val_mean_item_id=ext.item_id  and nci_val_mean_ver_nr = ext.ver_nr and ext.cncpt_concat = v_tab_val_mean_cd(i)
            and a.val_dom_item_id=de.val_dom_item_id and de.item_id = ihook.getColumnValue(row_cur,'ITEM_ID')
            and a.val_dom_ver_nr=de.val_dom_ver_nr and de.ver_nr = ihook.getColumnValue(row_cur,'VER_NR') and a.fld_delete=0) loop
                v_perm_val_nm := rec.perm_val_nm;
            end loop;
            ihook.setColumnValue(row, v_tab_admin_item_nm(j), nci_11179.replaceChar(v_perm_val_nm));
        end loop;
        -- input
        for cur1 in (select perm_val_nm from NCI_DS_DTL where hdr_id = v_hdr_id) loop
        if upper(cur1.perm_Val_nm) = upper(v_tab_val_mean_nm(i)) then
            ihook.setColumnValue(row, 'Input', cur1.perm_val_nm);
        end if;
        end loop;
        rows.extend; rows(rows.last) := row;
    end loop;

    showRowset := t_showableRowset(rows, 'Permissible Value Comparison',4, 'unselectable');
    hookOutput.showRowset := showRowset;

    v_data_out := ihook.getHookOutput(hookOutput);
end;


/*  Show PV comparison from ADministereds Item */

procedure spNCIShowVMDependencyComb (v_data_in in clob, v_data_out out clob)
as

    hookInput           t_hookInput;
    hookOutput           t_hookOutput := t_hookOutput();
    showRowset     t_showableRowset;

    rows      t_rows;
    row          t_row;
    row_cur t_row;
    row_ori  t_row;

    v_admin_item                admin_item%rowtype;
    v_tab_admin_item            tab_admin_item_pk;

    v_found      boolean;

    type t_val_mean_cd is table of nci_admin_item_ext.cncpt_concat%type;
    type t_val_mean_nm is table of nci_admin_item_ext.cncpt_concat_nm%type;

    v_tab_val_mean_cd  t_val_mean_cd := t_val_mean_cd();
    v_tab_val_mean_nm  t_val_mean_nm := t_val_mean_nm();

    v_tab_val_dom    tab_admin_item_pk := tab_admin_item_pk();

    type      t_admin_item_nm is table of admin_item.item_nm%type;
    v_tab_admin_item_nm   t_admin_item_nm := t_admin_item_nm();
    k integer;
    v_val_mean_desc    val_mean.val_mean_desc%type;
    v_perm_val_nm    perm_val.perm_val_nm%type;
    v_item_id		 number;
    v_ver_nr		 number;
    v_cart boolean;
    vd_id_nm    varchar2(300);
    v_item_typ_id integer;
begin

    hookInput := ihook.getHookInput(v_data_in);
    hookOutput.invocationNumber := hookInput.invocationNumber;
    hookOutput.originalRowset := hookInput.originalRowset;
v_cart := false;
 row_ori := hookInput.originalRowset.rowset (1);
-- saving all unique val_mean_ids from submitted admin items into v_tab_val_mean_id

if (upper(hookinput.originalrowset.tablename) like '%CART%') then
    v_item_typ_id := 4;
    v_cart := true;
else
    v_item_typ_id := ihook.getColumnValue(row_ori,'ADMIN_ITEM_TYP_ID');
end if;

    if (v_item_typ_id not in (3, 4)) then
        raise_application_error(-20000,'!!!! This functionality is only applicable for CDE and VD !!!!');
    return;
    end if;

    if (v_item_typ_id = 4) then -- Data Element
    for i in 1 .. hookInput.originalRowset.Rowset.count loop
        row_cur := hookInput.originalRowset.Rowset(i);
        if (ihook.getColumnValue(row_cur, 'ADMIN_ITEM_TYP_ID') = v_item_typ_id or v_cart) then
        for rec in (  select nci_val_mean_item_id, nci_val_mean_ver_nr, cncpt_concat, cncpt_concat_nm from perm_val pv, nci_admin_item_ext ext, de
        where pv.val_dom_item_id=de.val_dom_item_id and de.item_id = ihook.getColumnValue(row_cur,'ITEM_ID')
        and pv.val_dom_ver_nr=de.val_dom_ver_nr and de.ver_nr = ihook.getColumnValue(row_cur,'VER_NR') and pv.fld_delete=0 and
        pv.nci_val_mean_item_id = ext.item_id and pv.nci_val_mean_ver_nr = ext.ver_nr) loop

            v_found := false;
            for j in 1..v_tab_val_mean_cd.count loop
                    v_found := v_found or v_tab_val_mean_cd(j)=rec.cncpt_concat;
            end loop;
            if not v_found then
                v_tab_val_mean_cd.extend();
                v_tab_val_mean_nm.extend();
                v_tab_val_mean_cd(v_tab_val_mean_cd.count) := rec.cncpt_concat;
                v_tab_val_mean_nm(v_tab_val_mean_nm.count) := rec.cncpt_concat_nm;
            end if;
        end loop;

        v_tab_admin_item_nm.extend();
        select ai.item_id || '-' || ai.item_nm into  vd_id_nm from admin_item ai, de where ai.item_id = de.val_dom_item_id and ai.ver_nr = de.val_dom_ver_nr and de.item_id =ihook.getColumnValue(row_cur,'ITEM_ID')
        and de.ver_nr = ihook.getColumnValue(row_cur,'VER_NR');

        v_tab_admin_item_nm(v_tab_admin_item_nm.count) := 'CDE:' || ihook.getColumnValue(row_cur,'ITEM_ID') || '-' || ihook.getColumnValue(row_cur,'ITEM_NM') || chr(13) || 'VD:' ||  vd_id_nm ;
     end if;
    end loop;
  end if;
  if (v_item_typ_id = 3) then --Value Domain

    for i in 1 .. hookInput.originalRowset.Rowset.count loop
        row_cur := hookInput.originalRowset.Rowset(i);
     if (ihook.getColumnValue(row_cur, 'ADMIN_ITEM_TYP_ID') = v_item_typ_id) then

        for rec in (  select nci_val_mean_item_id, nci_val_mean_ver_nr, cncpt_concat, cncpt_concat_nm from perm_val pv, nci_admin_item_ext ext
        where val_dom_item_id=ihook.getColumnValue(row_cur,'ITEM_ID')
        and val_dom_ver_nr=ihook.getColumnValue(row_cur,'VER_NR') and pv.fld_delete=0 and
        pv.nci_val_mean_item_id = ext.item_id and pv.nci_val_mean_ver_nr = ext.ver_nr) loop
            v_found := false;
            for j in 1..v_tab_val_mean_cd.count loop
                    v_found := v_found or v_tab_val_mean_cd(j)=rec.cncpt_concat;
            end loop;

            if not v_found then
                v_tab_val_mean_cd.extend();
                v_tab_val_mean_nm.extend();
                v_tab_val_mean_cd(v_tab_val_mean_cd.count) := rec.cncpt_concat;
                v_tab_val_mean_nm(v_tab_val_mean_nm.count) := rec.cncpt_concat_nm;
            end if;
        end loop;
      v_tab_admin_item_nm.extend();

      v_tab_admin_item_nm(v_tab_admin_item_nm.count) := 'VD:' || ihook.getColumnValue(row_cur,'ITEM_ID') || '-' || ihook.getColumnValue(row_cur,'ITEM_NM');
    end if;
    end loop;
   end if;

    -- populating val means/perm vals

    if (v_item_typ_id = 4) then

    rows := t_rows();
    for i in 1 .. v_tab_val_mean_cd.count loop

        row := t_row();
        if (v_tab_val_mean_cd(i) = v_tab_val_mean_nm(i)) then
         --   ihook.setColumnValue(row, 'Concept Code', 'No Concepts');
          ihook.setColumnValue(row, 'VM Concept Codes', '');
        else
        ihook.setColumnValue(row, 'VM Concept Codes', v_tab_val_mean_cd(i));
        end if;
        ihook.setColumnValue(row, 'VM Concept Names', nci_11179.replaceChar(v_tab_val_mean_nm(i)));
    k := 1;
        for j in 1 .. hookInput.originalRowset.Rowset.count loop
           row_cur := hookInput.originalRowset.Rowset(j);
        if (ihook.getColumnValue(row_cur, 'ADMIN_ITEM_TYP_ID') = v_item_typ_id or v_cart) then

            v_perm_val_nm := '';
            for rec in   (select perm_val_nm   from perm_val a, nci_admin_item_Ext ext, de
            where nci_val_mean_item_id=ext.item_id  and nci_val_mean_ver_nr = ext.ver_nr and ext.cncpt_concat = v_tab_val_mean_cd(i)
            and a.val_dom_item_id=de.val_dom_item_id and de.item_id = ihook.getColumnValue(row_cur,'ITEM_ID')
            and a.val_dom_ver_nr=de.val_dom_ver_nr and de.ver_nr = ihook.getColumnValue(row_cur,'VER_NR') and a.fld_delete=0) loop
                v_perm_val_nm := rec.perm_val_nm;
            end loop;
            ihook.setColumnValue(row, v_tab_admin_item_nm(k), nci_11179.replaceChar(v_perm_val_nm));
            k := k + 1;
            end if;
        end loop;
        rows.extend; rows(rows.last) := row;
    end loop;
    end if;

    if (v_item_typ_id = 3) then

    rows := t_rows();
    for i in 1 .. v_tab_val_mean_cd.count loop

        row := t_row();
        if (v_tab_val_mean_cd(i) = v_tab_val_mean_nm(i)) then
         --   ihook.setColumnValue(row, 'Concept Code', 'No Concepts');
          ihook.setColumnValue(row, 'VM Concept Codes', '');
        else
        ihook.setColumnValue(row, 'VM Concept Codes', v_tab_val_mean_cd(i));
        end if;
        ihook.setColumnValue(row, 'VM Concept Names', nci_11179.replaceChar(v_tab_val_mean_nm(i)));
        k := 1;
        for j in 1 .. hookInput.originalRowset.Rowset.count loop
           row_cur := hookInput.originalRowset.Rowset(j);
        if (ihook.getColumnValue(row_cur, 'ADMIN_ITEM_TYP_ID') = v_item_typ_id) then

            v_perm_val_nm := '';
            for rec in   (select perm_val_nm   from perm_val a, nci_admin_item_Ext ext
            where nci_val_mean_item_id=ext.item_id  and nci_val_mean_ver_nr = ext.ver_nr and ext.cncpt_concat = v_tab_val_mean_cd(i)
            and a.val_dom_item_id=ihook.getColumnValue(row_cur,'ITEM_ID')
            and a.val_dom_ver_nr= ihook.getColumnValue(row_cur,'VER_NR') and a.fld_delete=0) loop
                v_perm_val_nm := rec.perm_val_nm;
            end loop;
            ihook.setColumnValue(row, v_tab_admin_item_nm(k), nci_11179.replaceChar(v_perm_val_nm));
            k := k+1;
            end if;
        end loop;
        rows.extend; rows(rows.last) := row;

    end loop;
    end if;

    showRowset := t_showableRowset(rows, 'Permissible Value Comparison',4, 'unselectable');
    hookOutput.showRowset := showRowset;

    v_data_out := ihook.getHookOutput(hookOutput);
end;

end;
/


DROP PACKAGE BODY ONEDATA_WA.NCI_CADSR_PULL;

CREATE OR REPLACE PACKAGE BODY ONEDATA_WA.nci_caDSR_PULL AS


v_dflt_usr  varchar2(30) := 'ONEDATA';

v_err_str      varchar2(1000) := '';
DEFAULT_TS_FORMAT    varchar2(50) := 'YYYY-MM-DD HH24:MI:SS';
--v_dflt_date date := to_date('8/18/2020','mm/dd/yyyy');
v_dflt_date date := sysdate;



procedure sp_quest_rep as
i integer;
v_found boolean;
v_max_rep integer;
begin




delete from temp_import;
commit;

insert into temp_import(item_id, ver_nr, rep_no)
select c_item_id, c_item_ver_nr, rep_no from nci_admin_item_rel r where rel_typ_id = 61 and nvl(rep_no ,0) >0 ;
commit;

insert into /* APPEND */ nci_quest_vv_rep (quest_pub_id, quest_ver_nr, rep_seq)
select nci_pub_id, nci_ver_nr, 1 from nci_admin_item_rel_alt_key ak where (p_item_id, p_item_ver_nr) in (select item_id, ver_nr from temp_import where rep_no = 1)
minus
select quest_pub_id, quest_ver_nr, rep_seq from nci_quest_vv_rep ak where rep_seq = 1;
commit;
delete from temp_import where rep_no = 1;
commit;


for cur in (select * from temp_import) loop
for i in 1..cur.rep_no  loop
--for i in 1..1  loop
insert into /* APPEND */ nci_quest_vv_rep (quest_pub_id, quest_ver_nr, rep_seq)
select nci_pub_id, nci_ver_nr, i from nci_admin_item_rel_alt_key ak where p_item_id = cur.item_id and p_item_ver_nr= cur.ver_nr
minus
select quest_pub_id, quest_ver_nr, rep_seq from nci_quest_vv_rep ak where rep_seq = i;
commit;
end loop;
end loop;

end;


PROCEDURE spCreateNewNode
AS
cur_idseq char(36);
new_idseq char(36);
v_id number;
  type t_cs_csi_idseq is table of cs_csi.cs_csi_idseq%type;
    type t_csi_idseq is table of cs_csi.csi_idseq%type;

    v_tab_cs_csi_idseq  t_cs_csi_idseq := t_cs_csi_idseq();
    v_tab_csi_idseq  t_csi_idseq := t_csi_idseq();
i integer;
j integer;
begin

-- Null parents
for cur in (select csi_idseq from cs_csi_copy  group by csi_idseq having count(*) > 1) loop
    i := 0;
    for cur1 in (select * from cs_csi_copy where csi_idseq = cur.csi_idseq) loop
        i :=  i + 1;
        if (i > 1) then
            v_tab_cs_csi_idseq.extend();
            v_tab_csi_idseq.extend();
            v_tab_cs_csi_idseq(v_tab_cs_csi_idseq.count) := cur1.cs_csi_idseq;
            v_tab_csi_idseq(v_tab_csi_idseq.count) := cur1.csi_idseq;
        end if;
    end loop;
end loop;

                for i in 1 .. v_tab_cs_csi_idseq.count loop
               new_idseq := nci_11179.cmr_guid;
                v_id := nci_11179.getItemId;
                insert into cs_items_copy(
                    CSI_IDSEQ, VERSION, CSI_NAME,CSITL_NAME,DESCRIPTION,COMMENTS,
                    DATE_CREATED,
                    CREATED_BY,DATE_MODIFIED,MODIFIED_BY,CONDR_IDSEQ,LONG_NAME,PREFERRED_DEFINITION,PREFERRED_NAME,CSI_ID,
                    CONTE_IDSEQ,ASL_NAME,DELETED_IND,LATEST_VERSION_IND, ORIGIN,BEGIN_DATE,END_DATE,CHANGE_NOTE)
                select new_idseq, 1, CSI_NAME,CSITL_NAME,DESCRIPTION,COMMENTS,
                sysdate,
                CREATED_BY,DATE_MODIFIED,MODIFIED_BY,CONDR_IDSEQ,LONG_NAME ,PREFERRED_DEFINITION, v_id || 'v1.00' ,v_id,
                CONTE_IDSEQ,ASL_NAME,DELETED_IND,LATEST_VERSION_IND, ORIGIN,BEGIN_DATE,END_DATE,CHANGE_NOTE from sbr_m.cs_items where csi_idseq = v_tab_csi_idseq(i);
            commit;
            update cs_csi_copy set csi_idseq = new_idseq where cs_csi_idseq = v_tab_cs_csi_idseq(i);
            commit;

        end loop;
end;

PROCEDURE            sp_create_ai_1
AS
    v_cnt   INTEGER;
BEGIN
    -- Context creation
    DELETE FROM cntxt;

    COMMIT;

    DELETE FROM admin_item
          WHERE admin_item_typ_id = 8;

    COMMIT;

--v_cnt := 20000000000;
--
--for cur in ( SELECT TRIM (conte_idseq) conte_idseq,
--               description,
--               name,
--               version,
--               nvl(created_by,v_dflt_usr) created_by,
--               nvl(date_created,v_dflt_date) date_created,
--   nvl(NVL (date_modified, date_created), v_dflt_date) date_modified,
--            nvl(modified_by,v_dflt_usr) modified_by
--          FROM sbr_m.contexts order by name) loop
--    INSERT INTO admin_item (item_id, admin_item_typ_id,
--                            NCI_iDSEQ,
--                            ITEM_DESC,
--                            ITEM_NM,
--                            ITEM_LONG_NM,
--                            VER_NR,
--                            CNTXT_NM_DN,
--                            CREAT_USR_ID,
--                            CREAT_DT,
--                            LST_UPD_DT,
--                            LST_UPD_USR_ID)
--        values( v_cnt, 8, cur.conte_idseq,
--               cur.description,
--               cur.name,
--               cur.name,
--               cur.version,
--               cur.name,
--               cur.created_by,
--               cur.date_created,
--   cur.date_modified,
--            cur.modified_by);
--          v_cnt := v_cnt + 1;
--end loop;
--    COMMIT;
--
--    -- Language is not used in context
--    INSERT INTO cntxt (ITEM_ID,
--                       VER_NR,
--                       LANG_ID,
--                       NCI_PRG_AREA_ID,
--                       CREAT_USR_ID,
--                       CREAT_DT,
--                       LST_UPD_DT,
--                       LST_UPD_USR_ID)
--        SELECT ai.ITEM_ID,
--               ai.VER_NR,
--               1000,
--               ok.OBJ_KEY_ID,
--                            nvl(c.created_by,v_dflt_usr),
--               nvl(c.date_created,v_dflt_date) ,
--               nvl(NVL (date_modified, date_created), v_dflt_date),
--               nvl(c.modified_by,v_dflt_usr)
--          FROM sbr_m.contexts c, admin_item ai, obj_key ok
--         WHERE     TRIM (ai.NCI_IDSEQ) = TRIM (c.conte_idseq)
--               AND TRIM (c.pal_name) = TRIM (ok.NCI_CD)
--               AND ok.obj_typ_id = 14
--               AND ai.admin_item_typ_id = 8;

 --   COMMIT;


Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000000, 1, NULL, 'Adult Brain Tumor'||CHR(10)||'Consortium',
    NULL, 1, 'ABTC', 'ABTC', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('4/2/2014 10:56:07 AM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBR', 'SBREXT', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('12/21/2015 9:52:21 AM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000000-1', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED', 'ABTC',
    'F6117C06-C689-F9FD-E040-BB89AD432E40', 'SBR', 'SBREXT');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000001, 1, NULL, 'Albert Einstein Cancer Center',
    NULL, 1, 'AECC', 'AECC', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('3/26/2013 1:31:13 PM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBREXT', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('3/25/2015 4:45:46 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000001-1', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED', 'AECC',
    'D8D849BC-68CF-10AA-E040-BB89AD430348', 'SBREXT', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000002, 1, NULL, 'Agency for Healthcare Research and Quality',
    NULL, 1, 'AHRQ', 'AHRQ', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('2/14/2017 8:50:33 AM', 'MM/DD/YYYY HH:MI:SS AM'), 'DWARZEL', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('3/14/2017 2:35:27 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000002-1', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED', 'AHRQ',
    '487ED90A-F48B-58EE-E053-F662850AE260', 'DWARZEL', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000003, 1, NULL, 'AIDS Malignancy Consortium',
    NULL, 1, 'AMC', 'AMC', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('4/21/2020 9:52:31 AM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBR', 'ONEDATA', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/21/2020 9:52:31 AM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000003-1', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED', 'AMC',
    'A3CE53B0-1ED6-7EE8-E053-F662850A014F', 'SBR', 'ONEDATA');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000004, 1, NULL, 'Alliance',
    NULL, 1, 'Alliance', 'Alliance', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('9/25/2013 2:08:52 PM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBR', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('6/8/2015 5:37:42 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000004-1', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED', 'Alliance',
    'E73A2559-FDAF-96CB-E040-BB89AD431DD5', 'SBR', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000005, 1, NULL, 'Biorepositories and Biospecimen Research Branch',
    NULL, 1, 'BBRB', 'BBRB', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('3/10/2016 4:13:07 PM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBR', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('1/23/2017 8:44:19 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000005-1', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED','BBRB',
    '2DB947EE-DAEC-E767-E050-BB89AD43388C', 'SBR', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000006, 1, NULL, 'Breast Oncology Local Disease',
    NULL, 1, 'BOLD', 'BOLD', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('8/13/2013 2:39:29 PM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBR', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('3/25/2015 4:45:46 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000006-1', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED', 'BOLD',
    'E3D98FAA-4194-FE1E-E040-BB89AD432060', 'SBR', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000007, 1, NULL, 'BRIDG Collaboration',
    NULL, 1, 'BRIDG', 'BRIDG', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('12/1/2008', 'MM/DD/YYYY'), 'DWARZEL', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('3/25/2015 4:45:46 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000007-1', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED', 'BRIDG',
    '5D003B18-1A08-6BD4-E044-0003BA3F9857', 'DWARZEL', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000008, 1, NULL, 'NCI Center for Cancer Research',
    NULL, 1, 'CCR', 'CCR', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('7/9/2002', 'MM/DD/YYYY'), 'SBR', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('3/25/2015 4:45:46 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000008-1', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED', 'CCR',
    'A5599257-A08F-41D1-E034-080020C9C0E0', 'SBR', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000009, 1, NULL, 'Canadian Cancer Trials Group',
    NULL, 1, 'CCTG', 'CCTG', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('10/20/2017 11:06:06 AM', 'MM/DD/YYYY HH:MI:SS AM'), 'SYS', 'ONEDATA', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('10/20/2017 11:06:06 AM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000009-1', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED', 'CCTG',
    '5BFCCFEA-8EF6-2F96-E053-F662850A3080', NULL, 'ONEDATA');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000010, 1, NULL, 'Centers for Disease Prevention and Control - Public Health Network',
    NULL, 1, 'CDC/PHIN', 'CDC/PHIN', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('7/21/2011 5:55:03 PM', 'MM/DD/YYYY HH:MI:SS AM'), 'RALEYGJ', 'ONEDATA', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('7/21/2011 5:55:03 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000010-1', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED', 'CDC/PHIN',
    'A89C651A-180D-1166-E040-BB89AD43308E', 'RALEYGJ', 'ONEDATA');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000011, 1, NULL, 'Common Data Model Harmonization Project',
    NULL, 1, 'CDMH Phase I', 'CDMH Phase I', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('5/21/2018 10:49:48 AM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBR', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('7/20/2020 4:46:25 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000011-1', NULL, NULL,
    NULL, NULL, 'Application', 'RELEASED', 'CDMH Phase I',
    '6CB969CC-DD4B-1016-E053-F662850A40C7', 'SBR', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000012, 2.31, NULL, 'NCI Cancer Imaging Program',
    NULL, 1, 'CIP', 'CIP', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('2/13/2002', 'MM/DD/YYYY'), 'SBR', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('3/25/2015 4:45:46 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000012-2.31', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED', 'CIP',
    '99BA9DC8-2094-4E69-E034-080020C9C0E0', 'SBR', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000013, 1, NULL, 'Cancer Immunotherapy Trials Network',
    NULL, 1, 'CITN', 'CITN', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('5/15/2013 12:23:51 PM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBREXT', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('6/8/2015 5:37:42 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000013-1', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED', 'CITN',
    'DCC52CE8-A028-A908-E040-BB89AD435412', 'SBREXT', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000014, 1, NULL, 'Children''s Oncology Group',
    NULL, 1, 'COG', 'COG', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('11/12/2013 2:45:44 PM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBR', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('6/8/2015 5:37:42 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000014-1', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED','COG',
    'EB011825-878C-E0E9-E040-BB89AD437FDD', 'SBR', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000015, 2.31, NULL, 'NCI Cancer Therapy Evaluation Program',
    NULL, 1, 'CTEP', 'CTEP', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('2/13/2002', 'MM/DD/YYYY'), 'SBR', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('3/25/2015 4:45:46 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000015-2.31', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED', 'CTEP',
    '99BA9DC8-2095-4E69-E034-080020C9C0E0', 'SBR', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000016, 1, NULL, 'Duke Cancer Institute',
    NULL, 1, 'DCI', 'DCI', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('6/10/2013 12:22:15 PM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBR', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('3/25/2015 4:45:46 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000016-1', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED', 'DCI',
    'DED02F08-8D34-D3EA-E040-BB89AD43785C', 'SBR', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000017, 1, NULL, 'NCI Division of Cancer Prevention',
    NULL, 1, 'DCP', 'DCP', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('8/27/2002 11:01:20 AM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBREXT', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('3/25/2015 4:45:46 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000017-1', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED', 'DCP',
    'A932C6E7-82EE-67C2-E034-0003BA12F5E7', 'SBREXT', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000018, 1, NULL, 'ECOG-ACRIN',
    NULL, 1, 'ECOG-ACRIN', 'ECOG-ACRIN', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('7/11/2011', 'MM/DD/YYYY'), 'DWARZEL', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('6/8/2015 5:37:42 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000018-1', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED', 'ECOG-ACRIN',
    'A7CF3B35-74D1-8852-E040-BB89AD435FAB', 'DWARZEL', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000019, 1, NULL, 'NCI Early Detection Research Program',
    NULL, 1, 'EDRN', 'EDRN', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('4/30/2002', 'MM/DD/YYYY'), 'SBR', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('3/25/2015 4:45:46 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000019-1', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED', 'EDRN',
    '9FDD834A-802F-1221-E034-080020C9C0E0', 'SBR', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000020, 1, NULL, 'Genomic Data Commons',
    NULL, 1, 'GDC', 'GDC', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('2/24/2016 4:23:57 PM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBR', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('2/26/2016 11:52:01 AM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000020-1', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED', 'GDC',
    '2C8BAF10-7E19-B797-E050-BB89AD43619C', 'SBR', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000021, 1, NULL, 'Lombardi Cancer Center',
    NULL, 1, 'LCC', 'LCC', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('3/26/2013 1:31:24 PM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBREXT', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('3/25/2015 4:45:46 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000021-1', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED', 'LCC',
    'D8D849BC-6955-10AA-E040-BB89AD430348', 'SBREXT', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000022, 1, NULL, 'Molecular and Cellular Characterization of Screened Lesions',
    NULL, 1, 'MCL', 'MCL', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('5/16/2016 11:02:16 AM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBR', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('10/5/2016 10:40:55 AM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000022-1', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED', 'MCL',
    '32F7E90C-9933-F958-E050-BB89AD4333ED', 'SBR', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000023, 1, NULL, 'NCI Preferred Standards',
    NULL, 1, 'NCI Standards', 'NCI Standards', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('6/8/2009', 'MM/DD/YYYY'), 'DWARZEL', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('3/14/2017 2:35:27 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000023-1', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED', 'NCI Standards',
    '6BDC8E1A-E021-BC44-E040-BB89AD4365F6', 'DWARZEL', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000024, 1, NULL, 'NCI Programs',
    NULL, 1, 'NCIP', 'NCIP', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('4/29/2004 7:46:31 AM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBR', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('2/10/2017 12:16:50 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000024-1', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED', 'NCIP',
    'D9344734-8CAF-4378-E034-0003BA12F5E7', 'SBR', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000025, 1, NULL, 'Norton Cancer Institute',
    NULL, 1, 'NHC-NCI', 'NHC-NCI', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('5/15/2013 12:23:05 PM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBREXT', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('3/25/2015 4:45:46 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000025-1', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED', 'NHC-NCI',
    'DCC52A25-A107-42D4-E040-BB89AD4346A7', 'SBREXT', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000026, 1, NULL, 'National Heart, Lung and Blood Institute ',
    NULL, 1, 'NHLBI', 'NHLBI', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('1/14/2005 2:29:37 PM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBR', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('3/25/2015 4:45:46 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000026-1', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED', 'NHLBI',
    'EDA90DE9-80D9-1E28-E034-0003BA3F9857', 'SBR', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000027, 1, NULL, 'National Institute of Child Health and Development',
    NULL, 1, 'NICHD', 'NICHD', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('8/31/2009', 'MM/DD/YYYY'), 'DWARZEL', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('3/25/2015 4:45:46 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000027-1', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED', 'NICHD',
    '726AD4F3-13C8-7001-E040-BB89AD430AA8', 'DWARZEL', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000028, 1, NULL, 'National Institute on Drug Abuse',
    NULL, 1, 'NIDA', 'NIDA', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('7/21/2011 5:54:53 PM', 'MM/DD/YYYY HH:MI:SS AM'), 'RALEYGJ', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('3/25/2015 4:45:46 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000028-1', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED', 'NIDA',
    'A89C651A-17CA-1166-E040-BB89AD43308E', 'RALEYGJ', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000029, 1, NULL, 'National Institute of Dental and Craniofacial Research',
    NULL, 1, 'NIDCR', 'NIDCR', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('4/29/2005 3:28:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBR', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('3/25/2015 4:45:46 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000029-1', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED', 'NIDCR',
    'F5E94686-5C79-2E5A-E034-0003BA3F9857', 'SBR', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000030, 1, NULL, 'Network RAVE Data Standards',
    NULL, 1, 'NRDS', 'NRDS', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('3/10/2016 4:13:46 PM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBR', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('6/7/2016 12:10:39 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000030-1', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED', 'NRDS',
    '2DB947EE-DB2F-E767-E050-BB89AD43388C', 'SBR', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000031, 1, NULL, 'NRG Oncology Group',
    NULL, 1, 'NRG', 'NRG', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('7/18/2013', 'MM/DD/YYYY'), 'DWARZEL', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('6/8/2015 5:37:42 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000031-1', NULL, NULL,
    NULL, NULL, 'Application', 'RELEASED', 'NRG',
    'E1D35591-F639-B5F8-E040-BB89AD437255', 'DWARZEL', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000032, 1, NULL, 'Office of Cancer Clinical Proteomics Research',
    NULL, 1, 'OCCPR', 'OCCPR', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('12/14/2018 5:00:44 PM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBR', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('1/18/2019 11:11:10 AM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000032-1', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED','OCCPR',
    '7D039015-B8B2-785E-E053-F662850AB762', 'SBR', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000033, 1, NULL, 'Office of Cancer Genomics',
    NULL, 1, 'OCG', 'OCG', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('1/23/2017 4:31:52 PM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBR', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('2/10/2017 11:49:39 AM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000033-1', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED', 'OCG',
    '46CABA5D-DAFF-6D24-E053-F662850A8A74', 'SBR', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000034, 1, NULL, 'Oregon Health and Science University Knight Cancer Institute',
    NULL, 1, 'OHSU Knight', 'OHSU Knight', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('5/15/2013 12:32:06 PM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBREXT', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('3/25/2015 4:45:46 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000034-1', NULL, NULL,
    NULL, NULL, 'Application', 'RELEASED', 'OHSU Knight',
    'DCC54A60-45E6-51EF-E040-BB89AD4336DC', 'SBREXT', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000035, 1, NULL, 'ONC S Framework Structured Data Capture Project',
    NULL, 1, 'ONC SDC Project', 'ONC SDC Project', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('4/2/2014 2:04:32 PM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBR', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('3/14/2017 2:35:27 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000035-1', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED', 'ONC SDC Project',
    'F6141DD3-5081-EC4B-E040-BB89AD435D8B', 'SBR', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000036, 1, NULL, 'Pediatric Brain Tumor Consortium',
    NULL, 1, 'PBTC', 'PBTC', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('5/15/2013 12:23:30 PM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBREXT', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('3/25/2015 4:45:46 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000036-1', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED', 'PBTC',
    'DCC52B9A-C60D-1CD4-E040-BB89AD434F2D', 'SBREXT', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000037, 1, NULL, 'NCI Population Sciences  Control',
    NULL, 1, 'PS-CC', 'PS-CC', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('9/11/2003 10:50:47 AM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBREXT', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('11/8/2017 12:34:37 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000037-1', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED', 'PS-CC',
    'C70EECD5-9998-2C9B-E034-0003BA12F5E7', 'SBREXT', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000038, 1, NULL, 'Consensus measures for Phenotypes and eXposures',
    NULL, 1, 'PhenX', 'PhenX', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('12/11/2015 1:45:54 PM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBREXT', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('6/7/2016 12:11:43 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000038-1', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED', 'PhenX',
    '26A4BBBE-35B8-55F4-E050-BB89AD43750D', 'SBREXT', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000039, 2.31, NULL, 'NCI Specialized Programs of Research Excellence',
    NULL, 1, 'SPOREs', 'SPOREs', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('2/13/2002', 'MM/DD/YYYY'), 'SBR', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('3/25/2015 4:45:46 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000039-2.31', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED', 'SPOREs',
    '99BA9DC8-2096-4E69-E034-080020C9C0E0', 'SBR', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000040, 1, NULL, 'SWOG',
    NULL, 1, 'SWOG', 'SWOG', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('5/13/2013 3:32:15 PM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBR', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('6/8/2015 5:38:53 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000040-1', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED', 'SWOG',
    'DC9F92F1-33F1-63FE-E040-BB89AD431DA1', 'SBR', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000041, 1, NULL, 'Test',
    NULL, 1, 'TEST', 'TEST', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('1/16/2002 2:29:40 PM', 'MM/DD/YYYY HH:MI:SS AM'), 'DER13_OWNER', 'SBR', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('5/28/2004 9:49:57 AM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000041-1', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED', 'TEST',
    '29A8FB18-0AB1-11D6-A42F-0010A4C1E842', NULL, 'SBR');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000042, 1, NULL, 'Theradex',
    NULL, 1, 'Theradex', 'Theradex', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('9/4/2013', 'MM/DD/YYYY'), 'DWARZEL', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('6/8/2015 5:37:42 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000042-1', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED', 'Theradex',
    'E593F10C-3186-508C-E040-BB89AD4324A0', 'DWARZEL', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000043, 1, NULL, 'Training Context',
    NULL, 1, 'Training', 'Training', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('10/6/2004 11:34:30 AM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBR', 'ONEDATA', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('10/6/2004 11:34:30 AM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000043-1', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED', 'Training',
    'E5CA1CEF-E2C6-3073-E034-0003BA3F9857', 'SBR', 'ONEDATA');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000044, 1, NULL, 'USC/Norris Comprehensive Cancer Center',
    NULL, 1, 'USC/NCCC', 'USC/NCCC', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('3/26/2013 1:31:17 PM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBREXT', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('3/25/2015 4:45:46 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000044-1', NULL, NULL,
    NULL, NULL,  'Application', 'RELEASED','USC/NCCC',
    'D8D849BC-6912-10AA-E040-BB89AD430348', 'SBREXT', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000045, 1, NULL, 'NCI Core Infrastructure',
    NULL, 1, 'caCORE', 'caCORE', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('9/10/2002 12:04:36 PM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBREXT', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('3/25/2015 4:45:46 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000045-1', NULL, NULL,
    NULL, NULL, 'Application', 'RELEASED', 'caCORE',
    'AA4E4AEC-5422-3E11-E034-0003BA12F5E7', 'SBREXT', 'DWARZEL');
Insert into ADMIN_ITEM
   (DATA_ID_STR, ITEM_ID, VER_NR, CLSFCTN_SCHM_ID, ITEM_DESC,
    CNTXT_ITEM_ID, CNTXT_VER_NR, ITEM_LONG_NM, ITEM_NM, ADMIN_NOTES,
    CHNG_DESC_TXT, CREATION_DT, EFF_DT, ORIGIN, UNRSLVD_ISSUE,
    UNTL_DT, CLSFCTN_SCHM_VER_NR, ADMIN_ITEM_TYP_ID, CURRNT_VER_IND, ADMIN_STUS_ID,
    REGSTR_STUS_ID, REGISTRR_CNTCT_ID, SUBMT_CNTCT_ID, STEWRD_CNTCT_ID, SUBMT_ORG_ID,
    STEWRD_ORG_ID, CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE,
    LST_DEL_DT, S2P_TRN_DT, LST_UPD_DT, LEGCY_CD, CASE_FILE_ID,
    REGSTR_AUTH_ID, BTCH_NR, ALT_KEY, ABAC_ATTR, ORIGIN_ID,
    ORIGIN_ID_DN, DEF_SRC, REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN, CNTXT_NM_DN,
    NCI_IDSEQ, CREAT_USR_ID_X, LST_UPD_USR_ID_X)
 Values
   (NULL, 20000000046, 1, NULL, 'Buffett Cancer Center',
    NULL, 1, 'iCaRe2', 'iCaRe2', NULL,
    NULL, TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL, NULL,
    NULL, NULL, 8, 1, 75,
    9, NULL, NULL, NULL, NULL,
    NULL, TO_DATE('5/7/2015 4:19:10 PM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBR', 'DWARZEL', 0,
    TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('4/19/2021 3:46:14 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('11/30/2015 7:38:00 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, NULL,
    NULL, NULL, '20000000046-1', NULL, NULL,
    NULL, NULL, 'Application', 'RELEASED', 'iCaRe2',
    '15849FD6-F176-2FF9-E050-BB89AD4362B4', 'SBR', 'DWARZEL');
COMMIT;

select max(item_id)+1 into v_cnt  from admin_item a where a.ADMIN_ITEM_TYP_ID=8;


for cur in ( SELECT TRIM (conte_idseq) conte_idseq,
               description,
               name,
               version,
               nvl(created_by,v_dflt_usr) created_by,
               nvl(date_created,v_dflt_date) date_created,
   nvl(NVL (date_modified, date_created), v_dflt_date) date_modified,
            nvl(modified_by,v_dflt_usr) modified_by
          FROM sbr_m.contexts c
          where  NOT EXISTS (select * from admin_item a where c.conte_idseq =a.nci_IDSEQ and a.ADMIN_ITEM_TYP_ID=8)order by name)
    loop
    INSERT INTO admin_item (item_id, admin_item_typ_id,
                            NCI_iDSEQ,
                            ITEM_DESC,
                            ITEM_NM,
                            ITEM_LONG_NM,
                            VER_NR,
                            CNTXT_NM_DN,
                            CREAT_USR_ID,
                            CREAT_DT,
                            LST_UPD_DT,
                            LST_UPD_USR_ID,
                            REGSTR_STUS_NM_DN, ADMIN_STUS_NM_DN,
                            REGSTR_STUS_ID, ADMIN_STUS_ID)
        values( v_cnt, 8, cur.conte_idseq,
               cur.description,
               cur.name,
               cur.name,
               cur.version,
               cur.name,
               cur.created_by,
               cur.date_created,
   cur.date_modified,
             cur.modified_by, 'Application', 'RELEASED',9,75);
          v_cnt := v_cnt + 1;
end loop;
    COMMIT;

    -- Language is not used in context
    INSERT INTO cntxt (ITEM_ID,
                       VER_NR,
                       LANG_ID,
                       NCI_PRG_AREA_ID,
                       CREAT_USR_ID,
                       CREAT_DT,
                       LST_UPD_DT,
                       LST_UPD_USR_ID)
        SELECT ai.ITEM_ID,
               ai.VER_NR,
               1000,
               ok.OBJ_KEY_ID,
                            nvl(c.created_by,v_dflt_usr),
               nvl(c.date_created,v_dflt_date) ,
               nvl(NVL (date_modified, date_created), v_dflt_date),
               nvl(c.modified_by,v_dflt_usr)
          FROM sbr_m.contexts c, admin_item ai, obj_key ok
         WHERE     TRIM (ai.NCI_IDSEQ) = TRIM (c.conte_idseq)
               AND TRIM (c.pal_name) = TRIM (ok.NCI_CD)
               AND ok.obj_typ_id = 14
               AND ai.admin_item_typ_id = 8;

    COMMIT;

update admin_Item set fld_delete = 1 where admin_item_typ_id = 8 and nci_idseq not in (Select conte_idseq from sbr_m.contexts);
commit;
MERGE INTO admin_item a
USING sbr_m.contexts c
ON (c.conte_idseq =a.nci_IDSEQ
 AND a.admin_item_typ_id = 8)
  WHEN MATCHED THEN
update SET
    a.ITEM_DESC=c.description,
    a.ITEM_NM=c.name,
    a.ITEM_LONG_NM=c.name  ,
    a.CNTXT_NM_DN=c.name ,
     a.LST_UPD_DT=nvl(NVL (date_modified, date_created), v_dflt_date),
     a.LST_UPD_USR_ID= nvl(c.modified_by,v_dflt_usr);
    COMMIT;
MERGE INTO cntxt c
USING  admin_item a
on (c.ITEM_ID =a.ITEM_ID
and c.VER_NR=a.VER_NR
AND a.admin_item_typ_id = 8 )
WHEN MATCHED THEN
update SET
    c.LST_UPD_USR_ID=a.LST_UPD_USR_ID,
   c.LST_UPD_DT= a.LST_UPD_DT,
   c.fld_delete=a.fld_delete;
 COMMIT;

    -- Conceptual Domain Creation
    DELETE FROM conc_dom;

    COMMIT;

    DELETE FROM admin_item
          WHERE admin_item_typ_id = 1;

    COMMIT;


    INSERT INTO admin_item (NCI_IDSEQ,
                            ADMIN_ITEM_TYP_ID,
                            ADMIN_STUS_ID,
                            ADMIN_STUS_NM_DN,
                            EFF_DT,
                            CHNG_DESC_TXT,
                            CNTXT_ITEM_ID,
                            CNTXT_VER_NR,
                            CNTXT_NM_DN,
                            UNTL_DT,
                            CURRNT_VER_IND,
                            ITEM_LONG_NM,
                            ORIGIN,
                            ITEM_DESC,
                            ITEM_ID,
                            ITEM_NM,
                            --STEWRD_ORG_ID
                 --           UNRSLVD_ISSUE,
                            VER_NR,
                            CREAT_USR_ID,
                            CREAT_DT,
                            LST_UPD_DT,
                            LST_UPD_USR_ID)
        SELECT ac.cd_idseq,
               1,
               s.stus_id,
               s.nci_stus,
               ac.begin_date,
               ac.change_note,
               --conte_idseq,
               cntxt.item_id,
               cntxt.ver_nr,
               cntxt.item_nm,
               ac.end_date,
               DECODE (UPPER (ac.latest_version_ind),  'YES', 1,  'NO', 0),
               ac.preferred_name,
               ac.origin,
               ac.preferred_definition,
               ac.cd_id,
               NVL (ac.long_name, ac.preferred_name),
               --stewa_idseq,
               --ac.unresolved_issue,
               ac.version,
               nvl(ac.created_by,v_dflt_usr),
               nvl(ac.date_created,v_dflt_date) ,
               nvl(NVL (ac.date_modified, ac.date_created), v_dflt_date),
               nvl(ac.modified_by,v_dflt_usr)
          FROM sbr_m.conceptual_domains  ac,
               admin_item                   cntxt,
               stus_mstr                    s
         WHERE     ac.conte_idseq = cntxt.nci_idseq
               AND TRIM (ac.asl_name) = TRIM (s.nci_STUS)
               AND cntxt.admin_item_typ_id = 8;

    COMMIT;

    INSERT INTO conc_dom (item_id,
                          ver_nr,
                          DIMNSNLTY,
                          CREAT_USR_ID,
                          CREAT_DT,
                          LST_UPD_DT,
                          LST_UPD_USR_ID)
        SELECT ai.item_id,
               ai.ver_nr,
               cd.dimensionality,
             nvl(cd.created_by,v_dflt_usr),
               nvl(cd.date_created,v_dflt_date) ,
                  nvl(NVL (cd.date_modified, cd.date_created), v_dflt_date),
               nvl(cd.modified_by,v_dflt_usr)
          FROM sbr_m.conceptual_domains cd, admin_item ai
         WHERE ai.NCI_IDSEQ = cd.CD_IDSEQ;

    COMMIT;

    -- Object class and Property creation. Need to confirm the OC and Property specific attributes
    DELETE FROM obj_cls;

    COMMIT;

    DELETE FROM prop;

    COMMIT;

    DELETE FROM admin_item
          WHERE admin_item_typ_id IN (5, 6);

    COMMIT;

    INSERT /*+ APPEND */
           INTO admin_item (NCI_IDSEQ,
                            ADMIN_ITEM_TYP_ID,
                            ADMIN_STUS_ID,
                            ADMIN_STUS_NM_DN,
                            EFF_DT,
                            CHNG_DESC_TXT,
                            CNTXT_ITEM_ID,
                            CNTXT_VER_NR,
                            CNTXT_NM_DN,
                            UNTL_DT,
                            CURRNT_VER_IND,
                            ITEM_LONG_NM,
                            ORIGIN,
                            ITEM_DESC,
                            ITEM_ID,
                            ITEM_NM,
                            --STEWRD_ORG_ID
                            VER_NR,
                            CREAT_USR_ID,
                            CREAT_DT,
                            LST_UPD_DT,
                            LST_UPD_USR_ID,
                            DEF_SRC)
        SELECT ac.oc_idseq,
               5,
               s.stus_id,
               s.nci_stus,
               ac.begin_date,
               ac.change_note,
               --conte_idseq,
               cntxt.item_id,
               cntxt.ver_nr,
               cntxt.item_nm,
               ac.end_date,
               DECODE (UPPER (ac.latest_version_ind),  'YES', 1,  'NO', 0),
               ac.preferred_name,
               ac.origin,
               ac.preferred_definition,
               ac.oc_id,
               NVL (ac.long_name, ac.preferred_name),
               --stewa_idseq,
               ac.version,
             nvl(ac.created_by,v_dflt_usr),
               nvl(ac.date_created,v_dflt_date) ,
                    nvl(NVL (ac.date_modified, ac.date_created), v_dflt_date),
               nvl(ac.modified_by,v_dflt_usr),
               ac.definition_source
          FROM admin_item cntxt, stus_mstr s, sbrext_m.object_classes_ext ac
         WHERE     ac.conte_idseq = cntxt.nci_idseq
               AND TRIM (ac.asl_name) = TRIM (s.nci_STUS)
               AND cntxt.admin_item_typ_id = 8;

    COMMIT;


    INSERT /*+ APPEND */
           INTO admin_item (NCI_IDSEQ,
                            ADMIN_ITEM_TYP_ID,
                            ADMIN_STUS_ID,
                            ADMIN_STUS_NM_DN,
                            EFF_DT,
                            CHNG_DESC_TXT,
                            CNTXT_ITEM_ID,
                            CNTXT_VER_NR,
                            CNTXT_NM_DN,
                            UNTL_DT,
                            CURRNT_VER_IND,
                            ITEM_LONG_NM,
                            ORIGIN,
                            ITEM_DESC,
                            ITEM_ID,
                            ITEM_NM,
                            --STEWRD_ORG_ID
                            VER_NR,
                            CREAT_USR_ID,
                            CREAT_DT,
                            LST_UPD_DT,
                            LST_UPD_USR_ID,
                            DEF_SRC)
        SELECT ac.prop_idseq,
               6,
               s.stus_id,
               s.nci_stus,
               ac.begin_date,
               ac.change_note,
               --conte_idseq,
               cntxt.item_id,
               cntxt.ver_nr,
               cntxt.item_nm,
               ac.end_date,
               DECODE (UPPER (ac.latest_version_ind),  'YES', 1,  'NO', 0),
               ac.preferred_name,
               ac.origin,
               ac.preferred_definition,
               ac.prop_id,
               NVL (ac.long_name, ac.preferred_name),
               --stewa_idseq,
               ac.version,
               nvl(ac.created_by,v_dflt_usr),
               nvl(ac.date_created,v_dflt_date) ,
                   nvl(NVL (ac.date_modified, ac.date_created), v_dflt_date),
               nvl(ac.modified_by,v_dflt_usr),
               ac.definition_source
          FROM admin_item cntxt, stus_mstr s, sbrext_m.properties_ext ac
         WHERE     ac.conte_idseq = cntxt.nci_idseq
               AND TRIM (ac.asl_name) = TRIM (s.nci_STUS)
               AND cntxt.admin_item_typ_id = 8;

    COMMIT;


    INSERT INTO obj_cls (item_id,
                         ver_nr,
                         CREAT_USR_ID,
                         CREAT_DT,
                         LST_UPD_DT,
                         LST_UPD_USR_ID)
        SELECT ai.item_id,
               ai.ver_nr,
               nvl(cd.created_by,v_dflt_usr),
               nvl(cd.date_created,v_dflt_date) ,
                              nvl(NVL (cd.date_modified, cd.date_created), v_dflt_date),
               nvl(cd.modified_by,v_dflt_usr)
          FROM sbrext_m.object_classes_ext cd, admin_item ai
         WHERE ai.NCI_IDSEQ = cd.OC_IDSEQ;

    COMMIT;


    INSERT INTO prop (item_id,
                      ver_nr,
                      CREAT_USR_ID,
                      CREAT_DT,
                      LST_UPD_DT,
                      LST_UPD_USR_ID)
        SELECT ai.item_id,
               ai.ver_nr,
             nvl(cd.created_by,v_dflt_usr),
               nvl(cd.date_created,v_dflt_date) ,
                 nvl(NVL (cd.date_modified, cd.date_created), v_dflt_date),
               nvl(cd.modified_by,v_dflt_usr)
          FROM sbrext_m.properties_ext cd, admin_item ai
         WHERE ai.NCI_IDSEQ = cd.PROP_IDSEQ;

    COMMIT;

    -- Classification Scheme and Representation Class creation
    DELETE FROM CLSFCTN_SCHM;

    COMMIT;

    DELETE FROM REP_CLS;

    COMMIT;

    DELETE FROM admin_item
          WHERE admin_item_typ_id IN (7, 9);

    COMMIT;

    INSERT INTO admin_item (NCI_IDSEQ,
                            ADMIN_ITEM_TYP_ID,
                            ADMIN_STUS_ID,
                            ADMIN_STUS_NM_DN,
                            EFF_DT,
                            CHNG_DESC_TXT,
                            CNTXT_ITEM_ID,
                            CNTXT_VER_NR,
                            CNTXT_NM_DN,
                            UNTL_DT,
                            CURRNT_VER_IND,
                            ITEM_LONG_NM,
                            ORIGIN,
                            ITEM_DESC,
                            ITEM_ID,
                            ITEM_NM,
                            --STEWRD_ORG_ID
                   --         UNRSLVD_ISSUE,
                            VER_NR,
                            CREAT_USR_ID,
                            CREAT_DT,
                            LST_UPD_DT,
                            LST_UPD_USR_ID)
        SELECT ac.cs_idseq,
              9,
               s.stus_id,
               s.nci_stus,
               ac.begin_date,
               ac.change_note,
               --conte_idseq,
               cntxt.item_id,
               cntxt.ver_nr,
               cntxt.item_nm,
               ac.end_date,
               DECODE (UPPER (ac.latest_version_ind),  'YES', 1,  'NO', 0),
               ac.preferred_name,
               ac.origin,
               ac.preferred_definition,
               ac.cs_id,
               NVL (ac.long_name, ac.preferred_name),
               --stewa_idseq,
               --ac.unresolved_issue,
               ac.version,
              nvl(ac.created_by,v_dflt_usr),
               nvl(ac.date_created,v_dflt_date) ,
  nvl(NVL (ac.date_modified, ac.date_created), v_dflt_date),
               nvl(ac.modified_by,v_dflt_usr)
          FROM sbr_m.classification_schemes  ac,
               admin_item                   cntxt,
               stus_mstr                    s
         WHERE     ac.conte_idseq = cntxt.nci_idseq
               AND TRIM (ac.asl_name) = TRIM (s.nci_STUS)
               AND cntxt.admin_item_typ_id = 8;

    COMMIT;

    INSERT INTO admin_item (NCI_IDSEQ,
                            ADMIN_ITEM_TYP_ID,
                            ADMIN_STUS_ID,
                            ADMIN_STUS_NM_DN,
                            EFF_DT,
                            CHNG_DESC_TXT,
                            CNTXT_ITEM_ID,
                            CNTXT_VER_NR,
                            CNTXT_NM_DN,
                            UNTL_DT,
                            CURRNT_VER_IND,
                            ITEM_LONG_NM,
                            ORIGIN,
                            ITEM_DESC,
                            ITEM_ID,
                            ITEM_NM,
                            --STEWRD_ORG_ID
                            --UNRSLVD_ISSUE,
                            VER_NR,
                            CREAT_USR_ID,
                            CREAT_DT,
                            LST_UPD_DT,
                            LST_UPD_USR_ID,
                            DEF_SRC)
        SELECT ac.rep_idseq,
               7,
               s.stus_id,
               s.nci_stus,
               ac.begin_date,
               ac.change_note,
               --conte_idseq,
               cntxt.item_id,
               cntxt.ver_nr,
               cntxt.item_nm,
               ac.end_date,
               DECODE (UPPER (ac.latest_version_ind),  'YES', 1,  'NO', 0),
               ac.preferred_name,
               ac.origin,
               ac.preferred_definition,
               ac.rep_id,
               NVL (ac.long_name, ac.preferred_name),
               --stewa_idseq,
               --ac.unresolved_issue,
               ac.version,
               nvl(ac.created_by,v_dflt_usr),
               nvl(ac.date_created,v_dflt_date) ,
               nvl(NVL (ac.date_modified, ac.date_created), v_dflt_date),
               nvl(ac.modified_by,v_dflt_usr),
               ac.definition_source
          FROM sbrext_m.representations_ext  ac,
               admin_item                   cntxt,
               stus_mstr                    s
         WHERE     ac.conte_idseq = cntxt.nci_idseq
               AND TRIM (ac.asl_name) = TRIM (s.nci_STUS)
               AND cntxt.admin_item_typ_id = 8;

    COMMIT;

    INSERT INTO clsfctn_schm (item_id,
                              ver_nr,
                              CLSFCTN_SCHM_TYP_ID,
                              NCI_LABEL_TYP_FLG,
                              CREAT_USR_ID,
                              CREAT_DT,
                              LST_UPD_DT,
                              LST_UPD_USR_ID)
        SELECT ai.item_id,
               ai.ver_nr,
               ok.obj_key_id,
               label_type_flag,
               nvl(cd.created_by,v_dflt_usr),
               nvl(cd.date_created,v_dflt_date) ,
               nvl(NVL (cd.date_modified, cd.date_created), v_dflt_date),
               nvl(cd.modified_by,v_dflt_usr)
          FROM sbr_m.classification_schemes cd, admin_item ai, obj_key ok
         WHERE     ai.NCI_IDSEQ = cd.CS_IDSEQ
               AND TRIM (cstl_name) = ok.nci_cd
               AND ok.obj_typ_id = 3;

    COMMIT;



    INSERT INTO rep_cls (item_id,
                         ver_nr,
                         CREAT_USR_ID,
                         CREAT_DT,
                         LST_UPD_DT,
                         LST_UPD_USR_ID)
        SELECT ai.item_id,
               ai.ver_nr,
               nvl(cd.created_by,v_dflt_usr),
               nvl(cd.date_created,v_dflt_date) ,
               nvl(NVL (cd.date_modified, cd.date_created), v_dflt_date),
               nvl(cd.modified_by,v_dflt_usr)
          FROM sbrext_m.representations_ext cd, admin_item ai
         WHERE ai.NCI_IDSEQ = cd.REP_IDSEQ;

    COMMIT;

END;
PROCEDURE            sp_create_ai_2
AS
    v_cnt   INTEGER;
BEGIN
    DELETE FROM de;

    COMMIT;

    DELETE FROM value_dom;

    COMMIT;

    DELETE FROM de_conc;

    COMMIT;

    -- Creation of Value DOmain, DEC and DE

    DELETE FROM admin_item
          WHERE admin_item_typ_id IN (2, 3, 4);

    COMMIT;

    INSERT /*+ APPEND */
           INTO admin_item (NCI_IDSEQ,
                            ADMIN_ITEM_TYP_ID,
                            ADMIN_STUS_ID,
                            ADMIN_STUS_NM_DN,
                            EFF_DT,
                            CHNG_DESC_TXT,
                            CNTXT_ITEM_ID,
                            CNTXT_VER_NR,
                            CNTXT_NM_DN,
                            UNTL_DT,
                            CURRNT_VER_IND,
                            ITEM_LONG_NM,
                            ORIGIN,
                            ITEM_DESC,
                            ITEM_ID,
                            ITEM_NM,
                            --STEWRD_ORG_ID
                            VER_NR,
                            CREAT_USR_ID,
                            CREAT_DT,
                            LST_UPD_DT,
                            LST_UPD_USR_ID)
        SELECT ac.dec_idseq,
               2,
               s.stus_id,
               s.nci_stus,
               ac.begin_date,
               ac.change_note,
               --conte_idseq,
               cntxt.item_id,
               cntxt.ver_nr,
               cntxt.item_nm,
               ac.end_date,
               DECODE (UPPER (ac.latest_version_ind),  'YES', 1,  'NO', 0),
               ac.preferred_name,
               ac.origin,
               ac.preferred_definition,
               ac.dec_id,
               NVL (ac.long_name, ac.preferred_name),
               --stewa_idseq,
               ac.version,
        nvl(ac.created_by,v_dflt_usr),
               nvl(ac.date_created,v_dflt_date) ,
               nvl(NVL (ac.date_modified, ac.date_created), v_dflt_date),
               nvl(ac.modified_by,v_dflt_usr)
                 FROM sbr_m.data_element_concepts ac, admin_item cntxt, stus_mstr s
         WHERE     ac.conte_idseq = cntxt.nci_idseq
               AND TRIM (ac.asl_name) = TRIM (s.nci_STUS)
               AND cntxt.admin_item_typ_id = 8;

    COMMIT;


    INSERT /*+ APPEND */
           INTO admin_item (NCI_IDSEQ,
                            ADMIN_ITEM_TYP_ID,
                            ADMIN_STUS_ID,
                            ADMIN_STUS_NM_DN,
                            EFF_DT,
                            CHNG_DESC_TXT,
                            CNTXT_ITEM_ID,
                            CNTXT_VER_NR,
                            CNTXT_NM_DN,
                            UNTL_DT,
                            CURRNT_VER_IND,
                            ITEM_LONG_NM,
                            ORIGIN,
                            ITEM_DESC,
                            ITEM_ID,
                            ITEM_NM,
                            --STEWRD_ORG_ID
                            VER_NR,
                            CREAT_USR_ID,
                            CREAT_DT,
                            LST_UPD_DT,
                            LST_UPD_USR_ID)
        SELECT ac.vd_idseq,
               3,
               s.stus_id,
               s.nci_stus,
               ac.begin_date,
               ac.change_note,
               --conte_idseq,
               cntxt.item_id,
               cntxt.ver_nr,
               cntxt.item_nm,
               ac.end_date,
               DECODE (UPPER (ac.latest_version_ind),  'YES', 1,  'NO', 0),
               ac.preferred_name,
               ac.origin,
               ac.preferred_definition,
               ac.vd_id,
               NVL (ac.long_name, ac.preferred_name),
               --stewa_idseq,
               ac.version,
               nvl(ac.created_by,v_dflt_usr),
               nvl(ac.date_created,v_dflt_date) ,
               nvl(NVL (ac.date_modified, ac.date_created), v_dflt_date),
               nvl(ac.modified_by,v_dflt_usr)
          FROM sbr_m.value_domains ac, admin_item cntxt, stus_mstr s
         WHERE     ac.conte_idseq = cntxt.nci_idseq
               AND TRIM (ac.asl_name) = TRIM (s.nci_STUS)
               AND cntxt.admin_item_typ_id = 8;

    COMMIT;



    INSERT /*+ APPEND */
           INTO admin_item (NCI_IDSEQ,
                            ADMIN_ITEM_TYP_ID,
                            ADMIN_STUS_ID,
                            ADMIN_STUS_NM_DN,
                            EFF_DT,
                            CHNG_DESC_TXT,
                            CNTXT_ITEM_ID,
                            CNTXT_VER_NR,
                            CNTXT_NM_DN,
                            UNTL_DT,
                            CURRNT_VER_IND,
                            ITEM_LONG_NM,
                            ORIGIN,
                            ITEM_DESC,
                            ITEM_ID,
                            ITEM_NM,
                            --STEWRD_ORG_ID
                            VER_NR,
                            CREAT_USR_ID,
                            CREAT_DT,
                            LST_UPD_DT,
                            LST_UPD_USR_ID)
        SELECT ac.de_idseq,
               4,
               s.stus_id,
               s.nci_stus,
               ac.begin_date,
               ac.change_note,
               --conte_idseq,
               cntxt.item_id,
               cntxt.ver_nr,
               cntxt.item_nm,
               ac.end_date,
               DECODE (UPPER (ac.latest_version_ind),  'YES', 1,  'NO', 0),
               ac.preferred_name,
               ac.origin,
               ac.preferred_definition,
               ac.cde_id,
               NVL (ac.long_name, ac.preferred_name),
               --stewa_idseq,
               ac.version,
               nvl(ac.created_by,v_dflt_usr),
               nvl(ac.date_created,v_dflt_date) ,
               nvl(NVL (ac.date_modified, ac.date_created), v_dflt_date),
               nvl(ac.modified_by,v_dflt_usr)
          FROM sbr_m.data_elements ac, admin_item cntxt, stus_mstr s
         WHERE     ac.conte_idseq = cntxt.nci_idseq
               AND TRIM (ac.asl_name) = TRIM (s.nci_STUS)
               AND cntxt.admin_item_typ_id = 8;

    COMMIT;
END;

 PROCEDURE            sp_create_ai_3
AS
    v_cnt   INTEGER;
    un_oc number;
    un_prop number;
BEGIN
    DELETE FROM de;

    COMMIT;

    DELETE FROM value_dom;

    COMMIT;

    DELETE FROM de_conc;

    COMMIT;

   un_oc := 7318107;
   un_prop := 7318108;

    INSERT INTO de_conc (item_id,
                         ver_nr,
                         CONC_DOM_ITEM_ID,
                         CONC_DOM_VER_NR,
                         OBJ_CLS_ITEM_ID,
                         OBJ_CLS_VER_NR,
                         PROP_ITEM_ID,
                         PROP_VER_NR,
                         OBJ_CLS_QUAL,
                         PROP_QUAL,
                         CREAT_USR_ID,
                         CREAT_DT,
                         LST_UPD_DT,
                         LST_UPD_USR_ID)
        SELECT ai.item_id,
               ai.ver_nr,
               cd.ITEM_ID,
               cd.VER_NR,
               oc.ITEM_ID,
               oc.VER_NR,
               prop.ITEM_ID,
               prop.VER_NR,
               dec.OBJ_CLASS_QUALIFIER,
               dec.PROPERTY_QUALIFIER,
        nvl(dec.created_by,v_dflt_usr),
               nvl(dec.date_created,v_dflt_date) ,
               nvl(NVL (dec.date_modified, dec.date_created), v_dflt_date),
               nvl(dec.modified_by,v_dflt_usr)
                 FROM sbr_m.data_element_concepts  dec,
               admin_item                 ai,
               admin_item                 oc,
               admin_item                 prop,
               admin_item                 cd
         WHERE     ai.NCI_IDSEQ = dec.dec_IDSEQ
               AND oc.admin_item_typ_id = 5
               AND prop.admin_item_typ_id = 6
               AND cd.admin_item_typ_id = 1
               AND dec.oc_idseq = oc.NCI_IDSEQ
               AND dec.prop_idseq = prop.NCI_IDSEQ
               AND dec.cd_idseq = cd.NCI_IDSEQ
               AND dec.oc_idseq IS NOT NULL
               AND dec.prop_idseq IS NOT NULL;

    COMMIT;



    INSERT INTO de_conc (item_id,
                         ver_nr,
                         CONC_DOM_ITEM_ID,
                         CONC_DOM_VER_NR,
                         OBJ_CLS_ITEM_ID,
                         OBJ_CLS_VER_NR,
                         PROP_ITEM_ID,
                         PROP_VER_NR,
                         OBJ_CLS_QUAL,
                         PROP_QUAL,
                         CREAT_USR_ID,
                         CREAT_DT,
                         LST_UPD_DT,
                         LST_UPD_USR_ID)
        SELECT ai.item_id,
               ai.ver_nr,
               cd.ITEM_ID,
               cd.VER_NR,
               oc.ITEM_ID,
               oc.VER_NR,
               un_prop,
               1,
               dec.OBJ_CLASS_QUALIFIER,
               dec.PROPERTY_QUALIFIER,
        nvl(dec.created_by,v_dflt_usr),
               nvl(dec.date_created,v_dflt_date) ,
               nvl(NVL (dec.date_modified, dec.date_created), v_dflt_date),
               nvl(dec.modified_by,v_dflt_usr)
          FROM sbr_m.data_element_concepts  dec,
               admin_item                 ai,
               admin_item                 oc,
               admin_item                 cd
         WHERE     ai.NCI_IDSEQ = dec.dec_IDSEQ
               AND oc.admin_item_typ_id = 5
               AND cd.admin_item_typ_id = 1
               AND dec.oc_idseq = oc.NCI_IDSEQ
               AND dec.cd_idseq = cd.NCI_IDSEQ
               AND dec.oc_idseq IS NOT NULL
               AND dec.prop_idseq IS NULL;

    COMMIT;

    INSERT INTO de_conc (item_id,
                         ver_nr,
                         CONC_DOM_ITEM_ID,
                         CONC_DOM_VER_NR,
                         OBJ_CLS_ITEM_ID,
                         OBJ_CLS_VER_NR,
                         PROP_ITEM_ID,
                         PROP_VER_NR,
                         OBJ_CLS_QUAL,
                         PROP_QUAL,
                         CREAT_USR_ID,
                         CREAT_DT,
                         LST_UPD_DT,
                         LST_UPD_USR_ID)
        SELECT ai.item_id,
               ai.ver_nr,
               cd.ITEM_ID,
               cd.VER_NR,
               un_oc,
               1,
               prop.ITEM_ID,
               prop.VER_NR,
               dec.OBJ_CLASS_QUALIFIER,
               dec.PROPERTY_QUALIFIER,
        nvl(dec.created_by,v_dflt_usr),
               nvl(dec.date_created,v_dflt_date) ,
               nvl(NVL (dec.date_modified, dec.date_created), v_dflt_date),
               nvl(dec.modified_by,v_dflt_usr)
          FROM sbr_m.data_element_concepts  dec,
               admin_item                 ai,
               admin_item                 prop,
               admin_item                 cd
         WHERE     ai.NCI_IDSEQ = dec.dec_IDSEQ
               AND prop.admin_item_typ_id = 6
               AND cd.admin_item_typ_id = 1
               AND dec.prop_idseq = prop.NCI_IDSEQ
               AND dec.cd_idseq = cd.NCI_IDSEQ
               AND dec.oc_idseq IS NULL
               AND dec.prop_idseq IS NOT NULL;

    COMMIT;

    INSERT INTO de_conc (item_id,
                         ver_nr,
                         CONC_DOM_ITEM_ID,
                         CONC_DOM_VER_NR,
                         OBJ_CLS_ITEM_ID,
                         OBJ_CLS_VER_NR,
                         PROP_ITEM_ID,
                         PROP_VER_NR,
                         OBJ_CLS_QUAL,
                         PROP_QUAL,
                         CREAT_USR_ID,
                         CREAT_DT,
                         LST_UPD_DT,
                         LST_UPD_USR_ID)
        SELECT ai.item_id,
               ai.ver_nr,
               cd.ITEM_ID,
               cd.VER_NR,
               un_oc,
               1,
               un_prop,
               1,
               dec.OBJ_CLASS_QUALIFIER,
               dec.PROPERTY_QUALIFIER,
        nvl(dec.created_by,v_dflt_usr),
               nvl(dec.date_created,v_dflt_date) ,
               nvl(NVL (dec.date_modified, dec.date_created), v_dflt_date),
               nvl(dec.modified_by,v_dflt_usr)
          FROM sbr_m.data_element_concepts dec, admin_item ai, admin_item cd
         WHERE     ai.NCI_IDSEQ = dec.dec_IDSEQ
               AND cd.admin_item_typ_id = 1
               AND dec.cd_idseq = cd.NCI_IDSEQ
               AND dec.oc_idseq IS NULL
               AND dec.prop_idseq IS NULL;

    COMMIT;


    INSERT INTO value_dom (item_id,
                           ver_nr,
                           CONC_DOM_ITEM_ID,
                           CONC_DOM_VER_NR,
                           NCI_DEC_PREC,
                           DTTYPE_ID,
                           VAL_DOM_FMT_ID,
                           UOM_ID,
                           VAL_DOM_HIGH_VAL_NUM,
                           VAL_DOM_LOW_VAL_NUM,
                           VAL_DOM_MAX_CHAR,
                           VAL_DOM_MIN_CHAR,
                           REP_CLS_ITEM_ID,
                           REP_CLS_VER_NR,
                           CREAT_USR_ID,
                           CREAT_DT,
                           LST_UPD_DT,
                           LST_UPD_USR_ID,
                           VAL_DOM_TYP_ID)
        SELECT ai.item_id,
               ai.ver_nr,
               cd.ITEM_ID,
               cd.VER_NR,
               vd.decimal_place,
               data_typ.DTTYPE_ID,
               fmt.fmt_id,
               uom.uom_id,
               vd.high_value_num,
               vd.low_value_num,
               vd.max_length_num,
               vd.min_length_num,
               rc.item_id,
               rc.ver_nr,
nvl(vd.created_by,v_dflt_usr),
               nvl(vd.date_created,v_dflt_date) ,
               nvl(NVL (vd.date_modified, vd.date_created), v_dflt_date),
               nvl(vd.modified_by,v_dflt_usr),
                       DECODE (VD_TYPE_FLAG,  'E', 17,  'N', 18)
          FROM sbr_m.value_domains  vd,
               admin_item         ai,
               admin_item         cd,
               admin_item         rc,
               uom,
               fmt,
               data_typ
         WHERE     ai.NCI_IDSEQ = vd.vd_IDSEQ
               AND cd.admin_item_typ_id = 1
               AND vd.cd_idseq = cd.NCI_IDSEQ
               AND vd.rep_idseq = rc.nci_idseq(+)
               AND vd.uoml_name = uom.nci_cd(+)
               AND vd.dtl_name = data_typ.nci_cd
               AND vd.forml_name = fmt.nci_cd(+);

    COMMIT;

    -- Update Standard data type based on mapping in OBJ_KEY table

    UPDATE value_dom v
       SET nci_std_dttype_id =
               (SELECT dt1.dttype_id
                  FROM data_typ dt, data_typ dt1
                 WHERE     dt.nci_dttype_map = dt1.dttype_nm
                       AND v.dttype_id = dt.dttype_id
                       AND dt.nci_dttype_typ_id = 1
                       AND dt1.nci_dttype_typ_id = 2);

    COMMIT;



    INSERT INTO de (item_id,
                    ver_nr,
                    DE_CONC_ITEM_ID,
                    DE_CONC_VER_NR,
                    VAL_DOM_ITEM_ID,
                    VAL_DOM_VER_NR,
                    CREAT_USR_ID,
                    CREAT_DT,
                    LST_UPD_DT,
                    LST_UPD_USR_ID)
        SELECT ai.item_id,
               ai.ver_nr,
               dec.ITEM_ID,
               dec.VER_NR,
               vd.ITEM_ID,
               vd.VER_NR,
      nvl(de.created_by,v_dflt_usr),
               nvl(de.date_created,v_dflt_date) ,
               nvl(NVL (de.date_modified, de.date_created), v_dflt_date),
               nvl(de.modified_by,v_dflt_usr)
            FROM sbr_m.data_elements  de,
               admin_item         ai,
               admin_item         dec,
               admin_item         vd
         WHERE     ai.NCI_IDSEQ = de.de_IDSEQ
               AND dec.admin_item_typ_id = 2
               AND vd.admin_item_typ_id = 3
               AND de.dec_idseq = dec.NCI_IDSEQ
               AND de.vd_idseq = vd.nci_idseq;

    COMMIT;

    UPDATE de
       SET (DERV_MTHD,
            DERV_RUL,
            DERV_TYP_ID,
            CONCAT_CHAR,
            DERV_DE_IND) =
               (SELECT METHODS,
                       RULE,
                       o.obj_key_id,
                       cdr.CONCAT_CHAR,
                       1
                  FROM sbr_m.complex_data_elements  cdr,
                       obj_key                    o,
                       admin_item                 ai
                 WHERE     cdr.CRTL_NAME = o.nci_cd(+)
                       AND o.obj_typ_id(+) = 21
                       AND cdr.p_de_idseq = ai.nci_idseq
                       AND de.item_id = ai.item_id
                       AND de.ver_nr = ai.ver_nr);

    COMMIT;


    UPDATE de
       SET PREF_QUEST_TXT = ( select doc_text     FROM sbr_m.reference_documents  d, --Changed from name to doc_text for DSRMWS-455 By AT 12/01/2020
                       obj_key                    ok,
                       admin_item                 ai
                 WHERE             d.dctl_name = ok.nci_cd
                           AND ok.obj_typ_id = 1
               and ok.obj_key_desc = 'Preferred Question Text'
            AND d.ac_idseq = ai.nci_idseq
                       AND de.item_id = ai.item_id
                       AND de.ver_nr = ai.ver_nr);

    COMMIT;

    -- Tracker 668. DM - Added 2/1/2021


    INSERT INTO REF (ITEM_ID,
                     VER_NR,
                     NCI_CNTXT_ITEM_ID,
                     NCI_CNTXT_VER_NR,
                     REF_TYP_ID,
                     DISP_ORD,
                     REF_DESC,
                     REF_NM,
                     LANG_ID)
    SELECT ai.item_id,
               ai.ver_nr,
               ai.cntxt_item_id,
               ai.cntxt_ver_nr,
               80,
               0,
               'Data Element ' || item_nm|| ' does not have Preferred Question Text',
               substr('Data Element ' || item_nm|| ' does not have Preferred Question Text',1,255),
               1000
          FROM admin_item               ai, de
         WHERE     ai.item_id = de.item_id and ai.ver_nr = de.ver_nr and de.pref_quest_txt is null;
    COMMIT;

UPDATE de
       SET PREF_QUEST_TXT = ( select 'Data Element ' || item_nm|| ' does not have Preferred Question Text'     FROM
                       admin_item                 ai
                 WHERE              de.item_id = ai.item_id
                       AND de.ver_nr = ai.ver_nr)
    where de.pref_quest_txt is null;

    COMMIT;

  --  insert into ref_doc
/*

    INSERT INTO admin_item (item_id,
                            ver_nr,
                            admin_item_typ_id,
                            item_nm,
                            ITEM_LONG_NM)
         VALUES (-20004,
                 1,
                 2,
                 'Unspecified VD',
                 'Unspecified VD');

    COMMIT;

    INSERT INTO admin_item (item_id,
                            ver_nr,
                            admin_item_typ_id,
                            item_nm,
                            ITEM_LONG_NM)
         VALUES (-20005,
                 1,
                 2,
                 'Unspecified DE',
                 'Unspecified DE');

    COMMIT;

    INSERT INTO value_dom (item_id,
                           ver_nr,
                           CONC_DOM_ITEM_ID,
                           CONC_DOM_VER_NR,
                           LST_UPD_DT)
        SELECT -20004, 1, -20002, 1, SYSDATE FROM DUAL;

    COMMIT;

    INSERT INTO de (item_id,
                    ver_nr,
                    VAL_DOM_ITEM_ID,
                    VAL_DOM_VER_NR,
                    DE_CONC_ITEM_ID,
                    DE_CONC_VER_NR,
                    LST_UPD_DT)
        SELECT -20005, 1, -20004, 1, -20003, 1, SYSDATE FROM DUAL;

    COMMIT;
*/

    DELETE FROM nci_admin_item_rel
          WHERE rel_typ_id = 66;

    COMMIT;


    INSERT INTO nci_admin_item_rel (P_ITEM_ID,
                                    P_ITEM_VER_NR,
                                    C_ITEM_ID,
                                    C_ITEM_VER_NR,
                                    --CNTXT_ITEM_ID, CNTXT_VER_NR,
                                    REL_TYP_ID,
                                    DISP_ORD,
                                    CREAT_USR_ID,
                                    CREAT_DT,
                                    LST_UPD_DT,
                                    LST_UPD_USR_ID)
        --DISP_LBL,
        --CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, LST_UPD_DT)
        SELECT prnt.item_id,
               prnt.ver_nr,
               child.item_id,
               child.ver_nr,
               66,
               display_order,
               nvl(cdr.created_by,v_dflt_usr),
               nvl(cdr.date_created,v_dflt_date) ,
               nvl(NVL (cdr.date_modified, cdr.date_created), v_dflt_date),
               nvl(cdr.modified_by,v_dflt_usr)
          --, qc.DISPLAY_ORDER
          --, qc.DATE_CREATED,qc.CREATED_BY,qc.MODIFIED_BY,DATE_MODIFIED
          FROM admin_item                    prnt,
               admin_item                    child,
               sbr_m.complex_de_relationships  cdr
         WHERE     prnt.nci_idseq = cdr.p_de_idseq
               AND child.nci_idseq = cdr.c_de_idseq;

    COMMIT;
END;

PROCEDURE            sp_create_ai_4
AS
    v_cnt   INTEGER;
BEGIN
    DELETE FROM nci_oc_recs;

    COMMIT;

    DELETE FROM admin_item
          WHERE admin_item_typ_id = 56;

    COMMIT;

    INSERT INTO admin_item (NCI_IDSEQ,
                            ADMIN_ITEM_TYP_ID,
                            ADMIN_STUS_ID,
                            ADMIN_STUS_NM_DN,
                            EFF_DT,
                            CHNG_DESC_TXT,
                            CNTXT_ITEM_ID,
                            CNTXT_VER_NR,
                            CNTXT_NM_DN,
                            UNTL_DT,
                            CURRNT_VER_IND,
                            ITEM_LONG_NM,
                            ORIGIN,
                            ITEM_DESC,
                            ITEM_ID,
                            ITEM_NM,
                            --STEWRD_ORG_ID
                 --           UNRSLVD_ISSUE,
                            VER_NR,
                            CREAT_USR_ID,
                            CREAT_DT,
                            LST_UPD_DT,
                            LST_UPD_USR_ID)
        SELECT ac.ocr_idseq,
               56,
               s.stus_id,
               s.nci_stus,
               ac.begin_date,
               ac.change_note,
               --conte_idseq,
               cntxt.item_id,
               cntxt.ver_nr,
               cntxt.item_nm,
               ac.end_date,
               DECODE (UPPER (ac.latest_version_ind),  'YES', 1,  'NO', 0),
               ac.preferred_name,
               ac.origin,
               ac.preferred_definition,
               ac.ocr_id,
               NVL (ac.long_name, ac.preferred_name),
               --stewa_idseq,
               --ac.unresolved_issue,
               ac.version,
               nvl(ac.created_by,v_dflt_usr),
               nvl(ac.date_created,v_dflt_date) ,
               nvl(NVL (ac.date_modified, ac.date_created), v_dflt_date),
               nvl(ac.modified_by,v_dflt_usr)
          FROM sbrext_m.oc_recs_ext ac, admin_item cntxt, stus_mstr s
         WHERE     ac.conte_idseq = cntxt.nci_idseq
               AND TRIM (ac.asl_name) = TRIM (s.nci_STUS)
               AND --ac.end_date is not null and
                   cntxt.admin_item_typ_id = 8;

    COMMIT;


    INSERT INTO NCI_OC_RECS (ITEM_ID,
                             VER_NR,
                             TRGT_OBJ_CLS_ITEM_ID,
                             TRGT_OBJ_CLS_VER_NR,
                             SRC_OBJ_CLS_ITEM_ID,
                             SRC_OBJ_CLS_VER_NR,
                             REL_TYP_NM,
                             SRC_ROLE,
                             TRGT_ROLE,
                             DRCTN,
                             SRC_LOW_MULT,
                             SRC_HIGH_MULT,
                             TRGT_LOW_MULT,
                             TRGT_HIGH_MULT,
                             DISP_ORD,
                             DIMNSNLTY,
                             ARRAY_IND)
        SELECT ocr.ocr_id,
               ocr.version,
               toc.item_id,
               toc.ver_nr,
               soc.item_id,
               soc.ver_nr,
               rl_name,
               source_role,
               target_role,
               direction,
               source_low_multiplicity,
               source_high_multiplicity,
               target_low_multiplicity,
               target_high_multiplicity,
               display_order,
               dimensionality,
               array_ind
          FROM sbrext_m.oc_recs_ext ocr, admin_item soc, admin_item toc
         WHERE     soc.admin_item_typ_id = 5
               AND toc.admin_item_typ_id = 5
               AND ocr.t_oc_idseq = toc.nci_idseq
               AND ocr.s_oc_idseq = soc.nci_idseq;

    COMMIT;
END;

PROCEDURE            sp_create_ai_children
AS
    v_cnt   INTEGER;
BEGIN
    -- Alternate Definitions
    DELETE FROM alt_def;

    COMMIT;

    INSERT INTO alt_def (ITEM_ID,
                         VER_NR,
                         CNTXT_ITEM_ID,
                         CNTXT_VER_NR,
                         DEF_DESC,
                         NCI_DEF_TYP_ID,
                         LANG_ID,
                         CREAT_USR_ID,
                         CREAT_DT,
                         LST_UPD_DT,
                         LST_UPD_USR_ID,
                         NCI_IDSEQ)
        SELECT ai.item_id,
               ai.ver_nr,
               cntxt.item_id,
               cntxt.ver_nr,
               definition,
               ok.obj_key_id,
               DECODE (UPPER (lae_name),
                       'ENGLISH', 1000,
                       'ICELANDIC', 1007,
                       'SPANISH', 1004),
      nvl(created_by,v_dflt_usr),
               nvl(date_created,v_dflt_date) ,
               nvl(NVL (date_modified, date_created), v_dflt_date),
               nvl(modified_by,v_dflt_usr),
               def.defin_idseq
          FROM admin_item       ai,
               sbr_m.definitions  def,
               admin_item       cntxt,
               obj_key          ok
         WHERE     ai.nci_idseq = def.ac_idseq
               AND def.conte_idseq = cntxt.nci_idseq
               AND cntxt.admin_item_typ_id = 8
               AND def.defl_name = ok.nci_cd(+)
               AND ok.obj_typ_id(+) = 15;

    -- Alternate Names
    DELETE FROM alt_nms;

    COMMIT;

    INSERT INTO alt_nms (ITEM_ID,
                         VER_NR,
                         CNTXT_ITEM_ID,
                         CNTXT_VER_NR,
                         NM_DESC,
                         NM_TYP_ID,
                         LANG_ID,
                         CREAT_USR_ID,
                         CREAT_DT,
                         LST_UPD_DT,
                         LST_UPD_USR_ID,
                         CNTXT_NM_DN,
                         NCI_IDSEQ)
        SELECT ai.item_id,
               ai.ver_nr,
               cntxt.item_id,
               cntxt.ver_nr,
               name,
               ok.obj_key_id,
               DECODE (UPPER (lae_name),
                       'ENGLISH', 1000,
                       'ICELANDIC', 1007,
                       'SPANISH', 1004),
      nvl(created_by,v_dflt_usr),
               nvl(date_created,v_dflt_date) ,
               nvl(NVL (date_modified, date_created), v_dflt_date),
               nvl(modified_by,v_dflt_usr),
               cntxt.ITEM_NM,
               def.desig_idseq
          FROM admin_item        ai,
               sbr_m.designations  def,
               admin_item        cntxt,
               obj_key           ok
         WHERE     ai.nci_idseq = def.ac_idseq
               AND def.conte_idseq = cntxt.nci_idseq
               AND cntxt.admin_item_typ_id = 8
               AND def.detl_name = ok.nci_cd(+)
               AND ok.obj_typ_id(+) = 11;

    COMMIT;


    INSERT INTO REF (ITEM_ID,
                     VER_NR,
                     NCI_CNTXT_ITEM_ID,
                     NCI_CNTXT_VER_NR,
                     REF_TYP_ID,
                     DISP_ORD,
                     REF_DESC,
                     REF_NM,
                     LANG_ID,
                     URL,
                     CREAT_USR_ID,
                     CREAT_DT,
                     LST_UPD_DT,
                     LST_UPD_USR_ID,
                     NCI_IDSEQ)
        SELECT ai.item_id,
               ai.ver_nr,
               cntxt.item_id,
               cntxt.ver_nr,
               ok.obj_key_id,
               display_order,
               doc_text,
               name,
               DECODE (UPPER (lae_name),
                       'ENGLISH', 1000,
                       'ICELANDIC', 1007,
                       'SPANISH', 1004),
               URL,
      nvl(created_by,v_dflt_usr),
               nvl(date_created,v_dflt_date) ,
               nvl(NVL (date_modified, date_created), v_dflt_date),
               nvl(modified_by,v_dflt_usr),
               rd_idseq
          FROM admin_item               ai,
               sbr_m.reference_documents  def,
               admin_item               cntxt,
               obj_key                  ok
         WHERE     ai.nci_idseq = def.ac_idseq
               AND def.conte_idseq = cntxt.nci_idseq
               AND cntxt.admin_item_typ_id = 8
               AND def.dctl_name = ok.nci_cd(+)
               AND ok.obj_typ_id(+) = 1;

    COMMIT;


    DELETE FROM NCI_CSI_ALT_DEFNMS;

    COMMIT;



    INSERT INTO NCI_CSI_ALT_DEFNMS (NCI_PUB_ID,
                                    NCI_VER_NR,
                                    NMDEF_ID,
                                    TYP_NM)
        --,
        --CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID)
        SELECT DISTINCT csi.ITEM_ID,
                        csi.VER_NR,
                        NM_ID,
                        atl_name
          --att.created_by, att.date_created,
          --att.date_modified, att.modified_by
          FROM nci_CLSFCTN_SCHM_ITEM  csi,
               sbrext_m.AC_ATT_CSCSI_EXT     att,
               alt_nms                     am
         WHERE     csi.cs_csi_idseq = att.cs_csi_idseq
               AND am.nci_idseq = att.att_idseq
               AND atl_name = 'DESIGNATION';

    COMMIT;



    INSERT INTO NCI_CSI_ALT_DEFNMS (NCI_PUB_ID,
                                    NCI_VER_NR,
                                    NMDEF_ID,
                                    TYP_NM)
        --CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID)
        SELECT DISTINCT csi.ITEM_ID,
                        csi.VER_NR,
                        DEF_ID,
                        atl_name
          --att.created_by, att.date_created,
          --att.date_modified, att.modified_by
          FROM nci_CLSFCTN_SCHM_ITEM  csi,
               sbrext_m.AC_ATT_CSCSI_EXT     att,
               alt_def                     am
         WHERE    csi.cs_csi_idseq = att.cs_csi_idseq
               AND am.nci_idseq = att.att_idseq
               AND atl_name = 'DEFINITION';

    COMMIT;
END;

PROCEDURE            sp_create_ai_cncpt
AS
    v_cnt   INTEGER;
BEGIN
    DELETE FROM cncpt_admin_item;

    COMMIT;

    DELETE FROM cncpt;

    COMMIT;

    -- Concept and concept relationships
    DELETE FROM admin_item
          WHERE admin_item_typ_id = 49;

    COMMIT;



    INSERT /*+ APPEND */
           INTO admin_item (NCI_IDSEQ,
                            ADMIN_ITEM_TYP_ID,
                            ADMIN_STUS_ID,
                            ADMIN_STUS_NM_DN,
                            EFF_DT,
                            CHNG_DESC_TXT,
                            CNTXT_ITEM_ID,
                            CNTXT_VER_NR,
                            CNTXT_NM_DN,
                            UNTL_DT,
                            CURRNT_VER_IND,
                            ITEM_LONG_NM,
                            ORIGIN,
                            ITEM_DESC,
                            ITEM_ID,
                            ITEM_NM,
                            --STEWRD_ORG_ID
                            VER_NR,
                            CREAT_USR_ID,
                            CREAT_DT,
                            LST_UPD_DT,
                            LST_UPD_USR_ID,
                            DEF_SRC)
        SELECT ac.con_idseq,
               49,
               s.stus_id,
               s.nci_stus,
               ac.begin_date,
               ac.change_note,
               --conte_idseq,
               cntxt.item_id,
               cntxt.ver_nr,
               cntxt.item_nm,
               ac.end_date,
               DECODE (UPPER (ac.latest_version_ind),  'YES', 1,  'NO', 0),
               ac.preferred_name,
               ac.origin,
               ac.preferred_definition,
               ac.con_id,
               NVL (ac.long_name, ac.preferred_name),
               --stewa_idseq,
               ac.version,
           nvl(ac.created_by,v_dflt_usr),
               nvl(ac.date_created,v_dflt_date) ,
               nvl(NVL (ac.date_modified, ac.date_created), v_dflt_date),
               nvl(ac.modified_by,v_dflt_usr),
             ac.DEFINITION_SOURCE
          FROM sbrext_m.concepts_ext ac, admin_item cntxt, stus_mstr s
         WHERE     ac.conte_idseq = cntxt.nci_idseq
               AND TRIM (ac.asl_name) = TRIM (s.nci_STUS)
               AND cntxt.admin_item_typ_id = 8;

    COMMIT;


    INSERT INTO cncpt (item_id,
                       ver_nr,
                       evs_src_id,
                       CREAT_USR_ID,
                       CREAT_DT,
                       LST_UPD_DT,
                       LST_UPD_USR_ID)
        SELECT con_id,
               version,
               ok.obj_key_id,
        nvl(created_by,v_dflt_usr),
               nvl(date_created,v_dflt_date) ,
               nvl(NVL (date_modified, date_created), v_dflt_date),
               nvl(modified_by,v_dflt_usr)
          FROM sbrext_m.concepts_ext c, obj_key ok
         WHERE c.evs_source = ok.obj_key_desc(+) AND ok.obj_typ_id(+) = 23;

    COMMIT;

    update cncpt set PRMRY_CNCPT_IND = 1 where (item_id, ver_nr) in (Select
    item_id, ver_nr from admin_item where admin_item_typ_id = 49 and item_long_nm  in (
'C13717',
'C25372',
'C25162',
'C25463',
'C25164',
'C37939',
'C25488',
'C25330',
'C48150',
'C25515',
'C48309',
'C25364',
'C25180',
'C45255',
'C25543',
'C25209',
'C42614',
'C25337',
'C20200',
'C38013',
'C25636',
'C25638',
'C25664',
'C25338',
'C25683',
'C25685',
'C16899',
'C25688',
'C25704',
'C25207',
'C25284',
'C25709',
'C25712') );
    commit;

    -- Object class-Concept relationship

    INSERT INTO cncpt_admin_item (cncpt_item_id,
                                  cncpt_ver_nr,
                                  item_id,
                                  ver_nr,
                                  nci_ord,
                                  nci_prmry_ind,
                                  nci_cncpt_val,
                                  CREAT_USR_ID,
                                  CREAT_DT,
                                  LST_UPD_DT,
                                  LST_UPD_USR_ID)
        SELECT con.item_id,
               con.ver_nr,
               oc.item_id,
               oc.ver_nr,
               cc.DISPLAY_ORDER,
               DECODE (cc.primary_flag_ind,  'Yes', 1,  'No', 0),
               concept_value,
        nvl(cc.created_by,v_dflt_usr),
               nvl(cc.date_created,v_dflt_date) ,
               nvl(NVL (cc.date_modified, cc.date_created), v_dflt_date),
               nvl(cc.modified_by,v_dflt_usr)
           FROM sbrext_m.COMPONENT_CONCEPTS_EXT  cc,
               sbrext_m.object_classes_ext      oce,
               admin_item                     con,
               admin_item                     oc
         WHERE     cc.CONDR_IDSEQ = oce.CONDR_IDSEQ
               AND oce.oc_idseq = oc.nci_idseq
               AND cc.con_idseq = con.nci_idseq;

    COMMIT;



    -- Property- Concept relationship

    INSERT INTO cncpt_admin_item (cncpt_item_id,
                                  cncpt_ver_nr,
                                  item_id,
                                  ver_nr,
                                  nci_ord,
                                  nci_prmry_ind,
                                  nci_cncpt_val,
                                  CREAT_USR_ID,
                                  CREAT_DT,
                                  LST_UPD_DT,
                                  LST_UPD_USR_ID)
        SELECT con.item_id,
               con.ver_nr,
               prop.item_id,
               prop.ver_nr,
               cc.DISPLAY_ORDER,
               DECODE (cc.primary_flag_ind,  'Yes', 1,  'No', 0),
               concept_value,
        nvl(cc.created_by,v_dflt_usr),
               nvl(cc.date_created,v_dflt_date) ,
               nvl(NVL (cc.date_modified, cc.date_created), v_dflt_date),
               nvl(cc.modified_by,v_dflt_usr)
          FROM sbrext_m.COMPONENT_CONCEPTS_EXT  cc,
               sbrext_m.properties_ext          prope,
               admin_item                     con,
               admin_item                     prop
         WHERE     cc.CONDR_IDSEQ = prope.CONDR_IDSEQ
               AND prope.prop_idseq = prop.nci_idseq
               AND cc.con_idseq = con.nci_idseq;

    COMMIT;


    -- Representation CLass - COncept relationship

    INSERT INTO cncpt_admin_item (cncpt_item_id,
                                  cncpt_ver_nr,
                                  item_id,
                                  ver_nr,
                                  nci_ord,
                                  nci_prmry_ind,
                                  nci_cncpt_val,
                                  CREAT_USR_ID,
                                  CREAT_DT,
                                  LST_UPD_DT,
                                  LST_UPD_USR_ID)
        SELECT con.item_id,
               con.ver_nr,
               rep.item_id,
               rep.ver_nr,
               cc.DISPLAY_ORDER,
               DECODE (cc.primary_flag_ind,  'Yes', 1,  'No', 0),
               concept_value,
        nvl(cc.created_by,v_dflt_usr),
               nvl(cc.date_created,v_dflt_date) ,
               nvl(NVL (cc.date_modified, cc.date_created), v_dflt_date),
               nvl(cc.modified_by,v_dflt_usr)
          FROM sbrext_m.COMPONENT_CONCEPTS_EXT  cc,
               sbrext_m.representations_ext     repe,
               admin_item                     con,
               admin_item                     rep
         WHERE     cc.CONDR_IDSEQ = repe.CONDR_IDSEQ
               AND Repe.rep_idseq = rep.nci_idseq
               AND cc.con_idseq = con.nci_idseq;

    COMMIT;


    -- Value Meaning  - COncept relationship

    INSERT INTO cncpt_admin_item (cncpt_item_id,
                                  cncpt_ver_nr,
                                  item_id,
                                  ver_nr,
                                  nci_ord,
                                  nci_prmry_ind,
                                  nci_cncpt_val,
                                  CREAT_USR_ID,
                                  CREAT_DT,
                                  LST_UPD_DT,
                                  LST_UPD_USR_ID)
        SELECT con.item_id,
               con.ver_nr,
               rep.item_id,
               rep.ver_nr,
               cc.DISPLAY_ORDER,
               DECODE (cc.primary_flag_ind,  'Yes', 1,  'No', 0),
               concept_value,
        nvl(cc.created_by,v_dflt_usr),
               nvl(cc.date_created,v_dflt_date) ,
               nvl(NVL (cc.date_modified, cc.date_created), v_dflt_date),
               nvl(cc.modified_by,v_dflt_usr)
          FROM sbrext_m.COMPONENT_CONCEPTS_EXT  cc,
               sbr_m.value_meanings             vm,
               admin_item                     con,
               admin_item                     rep
         WHERE     cc.CONDR_IDSEQ = vm.CONDR_IDSEQ
               AND vm.vm_idseq = rep.nci_idseq
               AND cc.con_idseq = con.nci_idseq;

    COMMIT;


    -- Value Domain  - COncept relationship

    INSERT INTO cncpt_admin_item (cncpt_item_id,
                                  cncpt_ver_nr,
                                  item_id,
                                  ver_nr,
                                  nci_ord,
                                  nci_prmry_ind,
                                  nci_cncpt_val,
                                  CREAT_USR_ID,
                                  CREAT_DT,
                                  LST_UPD_DT,
                                  LST_UPD_USR_ID)
        SELECT con.item_id,
               con.ver_nr,
               vd.item_id,
               vd.ver_nr,
               cc.DISPLAY_ORDER,
               DECODE (cc.primary_flag_ind,  'Yes', 1,  'No', 0),
               concept_value,
        nvl(cc.created_by,v_dflt_usr),
               nvl(cc.date_created,v_dflt_date) ,
               nvl(NVL (cc.date_modified, cc.date_created), v_dflt_date),
               nvl(cc.modified_by,v_dflt_usr)
          FROM sbrext_m.COMPONENT_CONCEPTS_EXT  cc,
               sbr_m.value_domains              vde,
               admin_item                     con,
               admin_item                     vd
         WHERE     cc.CONDR_IDSEQ = vde.CONDR_IDSEQ
               AND vde.vd_idseq = vd.nci_idseq
               AND cc.con_idseq = con.nci_idseq;

    COMMIT;


    -- Conceptual Domain  - COncept relationship

    INSERT INTO cncpt_admin_item (cncpt_item_id,
                                  cncpt_ver_nr,
                                  item_id,
                                  ver_nr,
                                  nci_ord,
                                  nci_prmry_ind,
                                  nci_cncpt_val,
                                  CREAT_USR_ID,
                                  CREAT_DT,
                                  LST_UPD_DT,
                                  LST_UPD_USR_ID)
        SELECT con.item_id,
               con.ver_nr,
               cd.item_id,
               cd.ver_nr,
               cc.DISPLAY_ORDER,
               DECODE (cc.primary_flag_ind,  'Yes', 1,  'No', 0),
               concept_value,
        nvl(cc.created_by,v_dflt_usr),
               nvl(cc.date_created,v_dflt_date) ,
               nvl(NVL (cc.date_modified, cc.date_created), v_dflt_date),
               nvl(cc.modified_by,v_dflt_usr)
          FROM sbrext_m.COMPONENT_CONCEPTS_EXT  cc,
               sbr_m.conceptual_domains         cde,
               admin_item                     con,
               admin_item                     cd
         WHERE     cc.CONDR_IDSEQ = cde.CONDR_IDSEQ
               AND cde.cd_idseq = cd.nci_idseq
               AND cc.con_idseq = con.nci_idseq;

    COMMIT;
END;

PROCEDURE            sp_create_csi
AS
    v_cnt   INTEGER;
BEGIN
    DELETE FROM admin_item
          WHERE admin_item_typ_id = 51;

    COMMIT;

    DELETE FROM nci_clsfctn_schm_item;

    COMMIT;


    INSERT INTO admin_item (NCI_IDSEQ,
                            ADMIN_ITEM_TYP_ID,
                            ADMIN_STUS_ID,
                            ADMIN_STUS_NM_DN,
                            EFF_DT,
                            CHNG_DESC_TXT,
                            CNTXT_ITEM_ID,
                            CNTXT_VER_NR,
                            CNTXT_NM_DN,
                            UNTL_DT,
                            CURRNT_VER_IND,
                            ITEM_LONG_NM,
                            ORIGIN,
                            ITEM_DESC,
                            ITEM_ID,
                            ITEM_NM,
                            --STEWRD_ORG_ID
                            VER_NR,
                            CREAT_USR_ID,
                            CREAT_DT,
                            LST_UPD_DT,
                            LST_UPD_USR_ID)
        SELECT ac.csi_idseq,
               51,
               s.stus_id,
               s.nci_stus,
               ac.begin_date,
               ac.change_note,
               --conte_idseq,
               cntxt.item_id,
               cntxt.ver_nr,
               cntxt.item_nm,
               ac.end_date,
               DECODE (UPPER (ac.latest_version_ind),  'YES', 1,  'NO', 0),
               ac.preferred_name,
               ac.origin,
               ac.preferred_definition,
               ac.csi_id,
               NVL (ac.long_name, ac.preferred_name),
               --stewa_idseq,
               ac.version,
      nvl(ac.created_by,v_dflt_usr),
               nvl(ac.date_created,v_dflt_date) ,
               nvl(NVL (ac.date_modified, ac.date_created), v_dflt_date),
               nvl(ac.modified_by,v_dflt_usr)
            FROM cs_items_copy ac, admin_item cntxt, stus_mstr s
         WHERE     ac.conte_idseq = cntxt.nci_idseq
               AND TRIM (ac.asl_name) = TRIM (s.nci_STUS)
               AND --ac.end_date is not null and
                   cntxt.admin_item_typ_id = 8;

    COMMIT;

/* -- Old
 INSERT INTO NCI_CLSFCTN_SCHM_ITEM (item_id,
                                       ver_nr,
                                       CSI_TYP_ID,
                                       CSI_DESC_TXT,
                                       CSI_CMNTS,
                                       CREAT_USR_ID,
                                       CREAT_DT,
                                       LST_UPD_DT,
                                       LST_UPD_USR_ID)
        SELECT ai.item_id,
               ai.ver_nr,
               ok.obj_key_id,
               description,
               comments,
       nvl(cd.created_by,v_dflt_usr),
               nvl(cd.date_created, v_dflt_date) ,
               nvl(NVL (cd.date_modified, cd.date_created), v_dflt_date),
               nvl(cd.modified_by,v_dflt_usr)
          FROM sbr_m.cs_items cd, admin_item ai, obj_key ok
         WHERE     ai.NCI_IDSEQ = cd.CSI_IDSEQ
               AND TRIM (csitl_name) = ok.nci_cd
               AND ok.obj_typ_id = 20;

    COMMIT;
*/

-- New COde 2/18 Deepali
 INSERT INTO NCI_CLSFCTN_SCHM_ITEM (item_id,
                                       ver_nr,
                                       CSI_TYP_ID,
                                       CSI_DESC_TXT,
                                       CSI_CMNTS,
                                       CS_ITEM_ID,
                                       CS_ITEM_VER_NR,
                                       CS_CSI_IDSEQ,
                                       CREAT_USR_ID,
                                       CREAT_DT,
                                       LST_UPD_DT,
                                       LST_UPD_USR_ID,
                                       DISP_ORD)
        SELECT ai.item_id,
               ai.ver_nr,
               ok.obj_key_id,
               description,
               comments,
               cs.ITEM_ID,
               cs.ver_nr,
               cscsi.cs_csi_idseq,
       nvl(cd.created_by,v_dflt_usr),
               nvl(cd.date_created, v_dflt_date) ,
               nvl(NVL (cd.date_modified, cd.date_created), v_dflt_date),
               nvl(cd.modified_by,v_dflt_usr), cscsi.DISPLAY_ORDER
          FROM cs_items_copy cd, admin_item ai, obj_key ok, cs_csi_copy cscsi, admin_item cs
         WHERE     ai.NCI_IDSEQ = cd.CSI_IDSEQ
               AND TRIM (csitl_name) = ok.nci_cd
               AND ok.obj_typ_id = 20
               and cd.csi_idseq = cscsi.csi_idseq (+)
               and cscsi.cs_idseq = cs.nci_idseq (+);

    COMMIT;

    update NCI_CLSFCTN_SCHM_ITEM x set (p_item_id, p_item_ver_nr) = (
    select csi.item_id, csi.ver_nr from admin_item csi, cs_csi_copy cscsi , cs_csi_copy pcscsi, admin_item ai where ai.item_id = x.item_id
    and ai.ver_nr = x.ver_nr and ai.nci_idseq = cscsi.csi_idseq and cscsi.p_cs_csi_idseq = pcscsi.cs_csi_idseq and pcscsi.csi_idseq = csi.nci_idseq);
    commit;


-- CSI with no CS - set Workflow status to Retired Withdrawn. Denise - 8/4/2021
 update ADMIN_ITEM set ADMIN_STUS_ID = 77, ADMIN_STUS_NM_DN = 'RETIRED ARCHIVED', UNTL_DT = LST_UPD_DT where admin_item_typ_id = 51 and (item_id, ver_nr) in
 (select item_id, ver_nr from NCI_CLSFCTN_SCHM_ITEM where cs_item_id is null);
 commit;

/*  commented if new code works.
 --last version 12/10/2020
 INSERT INTO nci_admin_item_rel_alt_key (CNTXT_CS_ITEM_ID,
                                            CNTXT_CS_VER_NR,
                                            C_ITEM_ID,
                                            C_ITEM_VER_NR,
                                            DISP_ORD,
                                            DISP_LBL,
                                            NCI_VER_NR,
                                            REL_TYP_ID,
                                            NCI_IDSEQ,
                                            CREAT_USR_ID,
                                            CREAT_DT,
                                            LST_UPD_DT,
                                            LST_UPD_USR_ID)
        SELECT cs.item_id,
               cs.ver_nr,
               ccsi.item_id,
               ccsi.ver_nr,
               cscsi.DISPLAY_ORDER,
               cscsi.label,
               1,
               64,
               cscsi.CS_CSI_IDSEQ,
      nvl(cscsi.created_by,v_dflt_usr),
               nvl(cscsi.date_created,v_dflt_date) ,
               nvl(NVL (cscsi.date_modified, cscsi.date_created), v_dflt_date),
               nvl(cscsi.modified_by,v_dflt_usr)
          FROM admin_item cs, admin_item ccsi, sbr_m.cs_csi cscsi
         WHERE     cscsi.cs_idseq = cs.nci_idseq
               AND cscsi.p_cs_csi_idseq IS NULL
               AND cscsi.csi_idseq = ccsi.nci_idseq;

    COMMIT;
  INSERT INTO nci_admin_item_rel_alt_key (CNTXT_CS_ITEM_ID,
                                            CNTXT_CS_VER_NR,
                                            P_ITEM_ID,
                                            P_ITEM_VER_NR,
                                            C_ITEM_ID,
                                            C_ITEM_VER_NR,
                                            DISP_ORD,
                                            DISP_LBL,
                                            NCI_VER_NR,
                                            REL_TYP_ID,
                                            NCI_IDSEQ,
                                            CREAT_USR_ID,
                                            CREAT_DT,
                                            LST_UPD_DT,
                                            LST_UPD_USR_ID)
        SELECT cs.item_id,
               cs.ver_nr,
               pcsi.item_id,
               pcsi.ver_nr,
               ccsi.item_id,
               ccsi.ver_nr,
               cscsi.DISPLAY_ORDER,
               cscsi.label,
               1,
               64,
               cscsi.CS_CSI_IDSEQ,
      nvl(cscsi.created_by,v_dflt_usr),
               nvl(cscsi.date_created,v_dflt_date) ,
               nvl(NVL (cscsi.date_modified, cscsi.date_created), v_dflt_date),
               nvl(cscsi.modified_by,v_dflt_usr)
            FROM admin_item  cs,
               admin_item  pcsi,
               admin_item  ccsi,
               sbr_m.cs_csi  cscsi,
               sbr_m.cs_csi  pcscsi
         WHERE     cscsi.cs_idseq = cs.nci_idseq
               AND cscsi.p_cs_csi_idseq IS NOT NULL
               AND pcscsi.cs_csi_idseq = cscsi.p_cs_csi_idseq
               AND pcscsi.csi_idseq = pcsi.nci_idseq
               AND cscsi.csi_idseq = ccsi.nci_idseq;

    COMMIT;



     update nci_admin_item_rel_alt_key k set (P_NCI_PUB_ID, P_NCI_VER_NR)
 = (select nci_pub_id, NCI_VER_NR from nci_admin_item_rel_alt_key a, sbr_m.cs_csi cscsi where k.nci_idseq = cscsi.cs_csi_idseq and cscsi.p_cs_csi_idseq = a.nci_idseq
 and cscsi.p_cs_csi_idseq is not null
 )
 where rel_typ_id = 64;
 commit;
 */
END;

procedure sp_load_status
as
v_cnt integer;
v_found varchar2(5);
begin
delete from ONEDATA_WA.STUS_MSTR ;
commit;
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (9,'Application','The AC is part of a computer program or application and may not have all the metadata generally required by the registry.',1,to_date('26-MAY-04','DD-MON-RR'),'SBR','CHENR',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('02-DEC-16','DD-MON-RR'),'000000',null,'Application',null,55);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (10,'Historical','Historical',1,to_date('02-DEC-16','DD-MON-RR'),'CHENR','CHENR',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('02-DEC-16','DD-MON-RR'),'000000',null,'Historical',null,58);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (11,'Retired','The AC should no longer be used.',1,to_date('26-MAY-04','DD-MON-RR'),'SBR','SBR',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('29-MAR-05','DD-MON-RR'),'000000',null,'Retired',null,60);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (50,'APPRVD FOR TRIAL USE','Fully specified administered component, CRFs CDE-compliant',2,to_date('19-FEB-02','DD-MON-RR'),'SBR','DWARZEL',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('02-APR-15','DD-MON-RR'),'000000',null,'APPRVD FOR TRIAL USE','Status assigned to Draft New Data Elements included on CDE-compliant forms, as well as their associated Administered Components.  Promotion to this status occurs when the Administered Component has been fully specified and CRFs with which the Data Element is associated are deemed CDE-compliant.',20);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (51,'CMTE APPROVED','Administered component approved by a Committee',2,to_date('19-FEB-02','DD-MON-RR'),'SBR','DWARZEL',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('02-APR-15','DD-MON-RR'),'000000',null,'CMTE APPROVED','Status assigned to Committee Submitted or Committee Submitted Used Data Elements, and their associated Administered Components, that have been approved for general use by a CDE Disease Committee.  Promotion to this status occurs upon consensus of the validity of the Data Element by the Committee.',40);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (52,'CMTE SUBMTD','Administered component submitted to a review committee',2,to_date('19-FEB-02','DD-MON-RR'),'SBR','DWARZEL',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('02-APR-15','DD-MON-RR'),'000000',null,'CMTE SUBMTD','Status assigned to new or modified Data Elements, and their associated Administered Components, created and submitted for review by a CDE Disease Committee.',50);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (53,'CMTE SUBMTD USED','Trial use approved, committee submitted admin. component',2,to_date('19-FEB-02','DD-MON-RR'),'SBR','DWARZEL',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('02-APR-15','DD-MON-RR'),'000000',null,'CMTE SUBMTD USED','Status assigned to new or modified Data Elements, and their associated Administered Components, that have been approved for use on a trial and submitted to a CDE Disease Committee for review.  Committee Submitted Used Administered Components must be fully specified.',60);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (54,'CMTE TENT ACCP USED','Status to be replaced with Committee Submitted Used',2,to_date('19-FEB-02','DD-MON-RR'),'SBR','DWARZEL',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('02-APR-15','DD-MON-RR'),'000000',null,'CMTE TENT ACCP USED','Status not to be used; transfer elements to Committee Submitted Used.',null);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (55,'CMTE UNDER REV','Status to be replaced with Committee Submitted',2,to_date('19-FEB-02','DD-MON-RR'),'SBR','DWARZEL',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('02-APR-15','DD-MON-RR'),'000000',null,'CMTE UNDER REV','Status not to be used; transfer elements to Committee Submitted.',null);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (56,'CMTE UNDER REV USED','Status to be replaced with Committee Submitted Used',2,to_date('19-FEB-02','DD-MON-RR'),'SBR','DWARZEL',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('02-APR-15','DD-MON-RR'),'000000',null,'CMTE UNDER REV USED','Status not to be used; transfer elements to Committee Submitted Used.',null);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (57,'CMTE: UNDER DEV','Status to be replaced with Committee Submitted',2,to_date('19-FEB-02','DD-MON-RR'),'SBR','JASUR',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('30-OCT-03','DD-MON-RR'),'000000',null,'CMTE: UNDER DEV','Status not to be used; transfer elements to Committee Submitted.',null);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (58,'CRF DE TO GROUP','The CRF initial review is ready for Group response',2,to_date('19-FEB-02','DD-MON-RR'),'SBR','SBR',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('19-FEB-02','DD-MON-RR'),'000000',null,'CRF DE TO GROUP','Treatment Trials Context. Indicates that all elements not exact matches are ready for the Group Response.  Onloy activated when the entire protocol is ready',null);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (59,'CRF GROUP RV DONE','NCI has complete the review of the Group Resp for a CRF',2,to_date('21-FEB-02','DD-MON-RR'),'JMAURER','JMAURER',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('21-FEB-02','DD-MON-RR'),'000000',null,'CRF GROUP RV DONE','Treatment Trials Context: The NCI has completed the review of the Group reponse for the new data elements or modified data elements and a decision has been made for all data elements on that CRF',null);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (60,'CRF MATCH EXISTING','The CRF submitted matches an existing CRf or template',2,to_date('19-FEB-02','DD-MON-RR'),'SBR','SBR',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('19-FEB-02','DD-MON-RR'),'000000',null,'CRF MATCH EXISTING','Treatment Trials Context: The groups are re-using an exisiting CRF or template without changes',null);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (61,'CRF NOT APPROVED','The CRF is not approved for use in any clinical trial',2,to_date('19-FEB-02','DD-MON-RR'),'SBR','SBR',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('19-FEB-02','DD-MON-RR'),'000000',null,'CRF NOT APPROVED','Treatment Trials Context:  A CRF that is not approved for trial use.  May stay in this state without furhter work or may be retired',null);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (62,'CRF RELOAD','The CRF and its elements need to be deleted and reloaded ',2,to_date('19-FEB-02','DD-MON-RR'),'SBR','SBR',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('19-FEB-02','DD-MON-RR'),'000000',null,'CRF RELOAD','Treatment Trials Context:  The CRF load process has failed and the CRF is marked ot be deleted and reloaded from the original submission file',null);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (1,'Preferred Standard','Registration status meaning that the Registration Authority confirms than the Administered Item is preferred for use in the community that uses this metadata registry.',1,to_date('15-AUG-16','DD-MON-RR'),'REEVESD','REEVESD',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('15-AUG-16','DD-MON-RR'),'000000',null,'Preferred Standard',null,1);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (2,'Standard','Recommended for usage by all contexts.',1,to_date('26-MAY-04','DD-MON-RR'),'SBR','CHENR',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('02-DEC-16','DD-MON-RR'),'000000',null,'Standard',null,2);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (3,'Qualified','Met quality requirements, ready to be reviewed for Proposed.',1,to_date('26-MAY-04','DD-MON-RR'),'SBR','CHENR',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('02-DEC-16','DD-MON-RR'),'000000',null,'Qualified',null,5);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (4,'Recorded','Recorded',1,to_date('02-DEC-16','DD-MON-RR'),'CHENR','CHENR',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('02-DEC-16','DD-MON-RR'),'000000',null,'Recorded',null,8);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (5,'Candidate','Being reviewed for standardization.',1,to_date('26-MAY-04','DD-MON-RR'),'SBR','SBR',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('29-MAR-05','DD-MON-RR'),'000000',null,'Candidate',null,10);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (6,'Incomplete','Incomplete',1,to_date('02-DEC-16','DD-MON-RR'),'CHENR','CHENR',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('02-DEC-16','DD-MON-RR'),'000000',null,'Incomplete',null,15);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (7,'Proposed',null,1,to_date('29-MAR-05','DD-MON-RR'),'SBR','SBR',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('29-MAR-05','DD-MON-RR'),'000000',null,'Proposed',null,20);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (8,'Superceded','The AC is no longer recommended for usage because it has been replaced by another AC.',1,to_date('26-MAY-04','DD-MON-RR'),'SBR','SBR',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('29-MAR-05','DD-MON-RR'),'000000',null,'Superceded',null,40);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (63,'CRF TEMPLATE','The CRF has been approved by a committee as a template',2,to_date('19-FEB-02','DD-MON-RR'),'SBR','SBR',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('19-FEB-02','DD-MON-RR'),'000000',null,'CRF TEMPLATE','Treatment Trials Context;  The committee has reviewed the CRF and recommended it as a template for other CRFs',null);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (64,'DATA QUAL REV DONE','Data load is complete, ready for content review',2,to_date('19-FEB-02','DD-MON-RR'),'SBR','SBR',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('19-FEB-02','DD-MON-RR'),'000000',null,'DATA QUAL REV DONE','Treatment Trials Context: Load of CRF is done and all data is present.',null);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (65,'DRAFT MOD','New version of an existing administered component',2,to_date('19-FEB-02','DD-MON-RR'),'SBR','SBR',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('29-MAR-05','DD-MON-RR'),'000000',null,'DRAFT MOD','Status assigned to new versions of existing Administered Components created to accommodate and represent requested changes.',70);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (66,'DRAFT NEW','Newly created administered component',2,to_date('19-FEB-02','DD-MON-RR'),'SBR','SBR',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('29-MAR-05','DD-MON-RR'),'000000',null,'DRAFT NEW','Status assigned to new Administered Component created during protocol review or in response to another request.',30);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (67,'EXACT MATCH','The questionnaire element matches an SBR entry exactly',2,to_date('19-FEB-02','DD-MON-RR'),'SBR','SBR',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('19-FEB-02','DD-MON-RR'),'000000',null,'EXACT MATCH','Treatment Trials Context: An exact match of a data element or valid value that is released is apporved and does not require further work',null);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (68,'GRP REVIEW COMP','The CoopGroup has completed the review-data entry ',2,to_date('19-FEB-02','DD-MON-RR'),'SBR','SBR',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('19-FEB-02','DD-MON-RR'),'000000',null,'GRP REVIEW COMP','Treatment Trials Context:  The Cooperative Group contributor has reviewed the reponse of NCI to the previous submission, made changes as needed and is ready for the NCI to review the changes.',null);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (69,'NEW TERM SUBMTD','A new term has been identified as a potential new CDE',2,to_date('19-FEB-02','DD-MON-RR'),'SBR','SBR',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('19-FEB-02','DD-MON-RR'),'000000',null,'NEW TERM SUBMTD','Treatment Trials Context:  The NCI reviewer has identified this questionnaire element as a potential new data element of valid value and requires input from the contributor',null);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (70,'NEW VERS SUBMTD','A new version of an item that needs input',2,to_date('19-FEB-02','DD-MON-RR'),'SBR','SBR',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('19-FEB-02','DD-MON-RR'),'000000',null,'NEW VERS SUBMTD','Treatment Trials Context: A potential new version or modified item has been identified and requires input from the contributor',null);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (71,'PROTOCOL GRP RV COMP','The NCI has completed the review of the Group Response',2,to_date('19-FEB-02','DD-MON-RR'),'SBR','JMAURER',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('21-FEB-02','DD-MON-RR'),'000000',null,'PROTOCOL GRP RV COMP','Treatment Trials Context: The NCI has completed the review of the Group response to the new or modified terms for the entire protocol.',null);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (72,'PROTOCOL TO GRP REV','All the new elements of protocol are ready for Group input',2,to_date('19-FEB-02','DD-MON-RR'),'SBR','SBR',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('19-FEB-02','DD-MON-RR'),'000000',null,'PROTOCOL TO GRP REV','Treatment Trials Context. Indicates that the intitial review of the submitted protocol CRf is done and all the data elements or valid values are ready for a response by the groups of the NCI review.',null);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (73,'RECOMM TERM USED','The term recommended by NCI is accepted',2,to_date('19-FEB-02','DD-MON-RR'),'SBR','SBR',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('19-FEB-02','DD-MON-RR'),'000000',null,'RECOMM TERM USED','Treatment Trials Context:  The term recommended by CTEP has been accepted by the contributor and is automatically approved for use',null);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (74,'RECOMMENDED TERM','Term recommended by a reviewer to be used for the submitted ',2,to_date('19-FEB-02','DD-MON-RR'),'SBR','SBR',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('19-FEB-02','DD-MON-RR'),'000000',null,'RECOMMENDED TERM','Treatment Trials Context: A term recommended to be used instead of the term used by the submitter. ',null);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (75,'RELEASED','Reviewed and approved administered component',2,to_date('13-FEB-02','DD-MON-RR'),'SBRCONV','SBR',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('29-MAR-05','DD-MON-RR'),'000000',null,'RELEASED','Status assigned to new or modified Data Elements, and their associated Administered Components, that have been reviewed and approved by the owning context''s review process (by committee or other decision-maker).  Released Administerd Components must be fully specified and compliant with the ISO 11179 model and associated naming guidelines and conventions.',1);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (76,'RELEASED-NON-CMPLNT','Status for short-term use only, to be replaced long term',2,to_date('23-OCT-02','DD-MON-RR'),'SBR','SBR',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('29-MAR-05','DD-MON-RR'),'000000',null,'RELEASED-NON-CMPLNT','Status not to be used long-term, but is needed temporarily; contexts that have EXISTING Released elements that are not compliant may direct NCICB to change their status to Released-non-compliant or to Approved for Trial Use.  Otherwise, no new elements should be assigned to this status.  Status assigned to Released Data Elements that are not fully specified or compliant with the ISO 11179 standards and guidelines; these Data Elements will be specified and designated as Released.',120);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (77,'RETIRED ARCHIVED','Old version administered component replaced with new version',2,to_date('19-FEB-02','DD-MON-RR'),'SBR','SBR',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('29-MAR-05','DD-MON-RR'),'000000',null,'RETIRED ARCHIVED','Status assigned to old versions of Administered Components that have been replaced with new versions.  Retired Archived Data Elements should not be used on future trials and should not be sent through the owning context''s review process again.',80);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (78,'RETIRED DELETED','Erroneous administered component to be removed from database',2,to_date('19-FEB-02','DD-MON-RR'),'SBR','SBR',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('29-MAR-05','DD-MON-RR'),'000000',null,'RETIRED DELETED','Status assigned to Administered Components that were created in error and may be deleted from the database.  Retired Deleted Data Elements should not be viewed in the CDE Browser and should not be used on CRFs.',110);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (79,'RETIRED PHASED OUT','Administered component rejected for general release',2,to_date('19-FEB-02','DD-MON-RR'),'SBR','SBR',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('29-MAR-05','DD-MON-RR'),'000000',null,'RETIRED PHASED OUT','Status assigned to new Data Elements or modified versions (not old versions) of Data Elements, and their associated Administered Components, that have been rejected for general release during the owning context''s review process (by committee or other decision-maker).  Retired Phased Out Data Elements should not be sent through another round of the owning context''s review process,  but may be used as a last-resort on future protocols, if the need is determined by the CRF reviewer.',90);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (80,'RETIRED UNLOADED',null,2,to_date('06-JUN-16','DD-MON-RR'),'SBREXT','ONEDATA',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('06-JUN-16','DD-MON-RR'),'000000',null,'RETIRED UNLOADED',null,null);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (81,'RETIRED WITHDRAWN','Administered component not subjected to review process',2,to_date('19-FEB-02','DD-MON-RR'),'SBR','SBR',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('29-MAR-05','DD-MON-RR'),'000000',null,'RETIRED WITHDRAWN','Status assigned to Data Elements, and their associated Administered Components, that have not been subjected to the owning context''s review process (by committee or other decision-maker), including those created for grandfathered protocols (those approved prior to the creation of Released CDEs for the disease under study).  This also includes Draft New or Draft Mod Data Elements, and their associated Administered Components, that are removed from submitted CRFs prior to the forms being deemed CDE-compliant and Data Elements, and their associated Administered Components,  that are removed from consideration prior to the owning context''s review process.  Retirement may only occur if the Data Element is not being used on other CRFs.  Retired Withdrawn Data Elements may be used on future CRFs as Draft New.',100);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (82,'SUBMITTED TO CTEP','Status to be replaced with Draft New',2,to_date('19-FEB-02','DD-MON-RR'),'SBR','JASUR',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('30-OCT-03','DD-MON-RR'),'000000',null,'SUBMITTED TO CTEP','Status not to be used; transfer elements to Draft New.',null);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (83,'UNASSIGNED','Status to be replaced with Draft New',2,to_date('11-JAN-02','DD-MON-RR'),'DER13_OWNER','JASUR',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('30-OCT-03','DD-MON-RR'),'000000',null,'UNASSIGNED','Status not to be used; transfer elements to Draft New.',null);
Insert into ONEDATA_WA.STUS_MSTR (STUS_ID,STUS_NM,STUS_DESC,STUS_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_USR_ID,FLD_DELETE,LST_DEL_DT,S2P_TRN_DT,LST_UPD_DT,STUS_MSK,STUS_ACRO,NCI_STUS,NCI_CMNTS,NCI_DISP_ORDR) values (84,'UNDER DEVELOPMENT','Status to be replaced with Context-selected status',2,to_date('13-FEB-02','DD-MON-RR'),'SBRCONV','JASUR',0,to_date('19-APR-21','DD-MON-RR'),to_date('19-APR-21','DD-MON-RR'),to_date('30-OCT-03','DD-MON-RR'),'000000',null,'UNDER DEVELOPMENT','Status not to be used; transfer elements as directed by context.',null);
commit;

update stus_mstr set fld_delete = 1 where stus_typ_id = 1 and nci_stus not in (Select registration_status from sbr_m.reg_status_lov);
commit;
update stus_mstr set fld_delete = 1 where stus_typ_id = 2 and nci_stus not in (Select asl_name from sbr_m.ac_status_lov);
commit;

/* we do not clean up this table, but populate it incrementally to preserve IDs
*/

v_cnt := 0; -- status ID to use

for cur in (select registration_status,description,
                    comments,created_by, date_created,
                    nvl(date_modified, date_created) date_modified, modified_by,
                    display_order from sbr_m.reg_status_lov
                    order by display_order) loop

v_cnt := get_stus_mstr_id(cur.registration_status, 1); -- we need to preserve ID

v_found := is_stus_mstr_exist(cur.registration_status, 1);

if (v_found = 'FALSE') then --if not exist INSERT
insert into stus_mstr (STUS_ID, NCI_STUS, STUS_NM, STUS_DESC,
                       NCI_CMNTS, CREAT_USR_ID, CREAT_DT, LST_UPD_DT, LST_UPD_USR_ID,
                       NCI_DISP_ORDR, STUS_TYP_ID )
values (v_cnt, cur.registration_status, cur.registration_status, cur.description,
cur.comments, nvl(cur.created_by, v_dflt_usr), nvl(cur.date_created,v_dflt_date), nvl(nvl(cur.date_modified,cur.date_created), v_dflt_date), nvl(cur.modified_by, v_dflt_usr),
cur.display_order, 1);
else --update
update stus_mstr set NCI_STUS = cur.registration_status, STUS_NM = cur.registration_status, STUS_DESC=cur.description,
NCI_CMNTS = cur.comments, CREAT_USR_ID = nvl(cur.created_by, v_dflt_usr), CREAT_DT = nvl(cur.date_created,v_dflt_date),
LST_UPD_DT = nvl(nvl(cur.date_modified,cur.date_created), v_dflt_date), LST_UPD_USR_ID = nvl(cur.modified_by, v_dflt_usr),
NCI_DISP_ORDR = cur.display_order where STUS_ID = v_cnt;
end if;
end loop;
commit;

for cur in (select asl_name,description,
                    comments,created_by, date_created,
                    nvl(date_modified, date_created) date_modified, modified_by,
                    display_order from sbr_m.ac_status_lov
                    order by asl_name) loop

v_cnt := get_stus_mstr_id(cur.asl_name, 2); -- we need to preserve ID

v_found := is_stus_mstr_exist(cur.asl_name, 2);

if (v_found = 'FALSE') then --if not exist INSERT
insert into stus_mstr (STUS_ID, NCI_STUS, STUS_NM, STUS_DESC,
                       NCI_CMNTS, CREAT_USR_ID, CREAT_DT, LST_UPD_DT, LST_UPD_USR_ID,
                       NCI_DISP_ORDR, STUS_TYP_ID )
values (v_cnt, cur.asl_name, cur.asl_name, cur.description,
cur.comments, nvl(cur.created_by, v_dflt_usr), nvl(cur.date_created,v_dflt_date),
 nvl(nvl(cur.date_modified,cur.date_created), v_dflt_date), nvl(cur.modified_by, v_dflt_usr),
cur.display_order, 2);

else --update
update stus_mstr set NCI_STUS = cur.asl_name, STUS_NM = cur.asl_name, STUS_DESC = cur.description,
NCI_CMNTS = cur.comments, CREAT_USR_ID = nvl(cur.created_by, v_dflt_usr), CREAT_DT = nvl(cur.date_created,v_dflt_date),
LST_UPD_DT = nvl(nvl(cur.date_modified,cur.date_created), v_dflt_date), LST_UPD_USR_ID = nvl(cur.modified_by, v_dflt_usr),
NCI_DISP_ORDR = cur.display_order where STUS_ID = v_cnt;
end if;
end loop;
commit;

end;


procedure sp_create_csi_2
as
v_cnt integer;
begin

/*

insert into NCI_ALT_KEY_ADMIN_ITEM_REL (NCI_PUB_ID  ,  NCI_VER_NR  , C_ITEM_ID ,  C_ITEM_VER_NR ,  REL_TYP_ID,
CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID)
select ak.nci_pub_id, ak.nci_ver_nr, ai.item_id, ai.ver_nr, 65,
     nvl(accsi.created_by,v_dflt_usr),
               nvl(accsi.date_created,v_dflt_date) ,
               nvl(NVL (accsi.date_modified, accsi.date_created), v_dflt_date),
               nvl(accsi.modified_by,v_dflt_usr)
 from  sbr_m.ac_csi accsi, nci_admin_item_rel_alt_key ak, admin_item ai
where accsi.ac_idseq = ai.nci_idseq and
 accsi.cs_csi_idseq = ak.nci_idseq and ak.rel_typ_id = 64;
commit;
*/

insert into nci_admin_item_rel (p_item_id, p_item_ver_nr, c_item_id, c_item_ver_nr, rel_typ_id,
CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID)
select csi.item_id, csi.ver_nr, de.item_id, de.ver_nr, 65,
     nvl(accsi.created_by,v_dflt_usr),
               nvl(accsi.date_created,v_dflt_date) ,
               nvl(NVL (accsi.date_modified, accsi.date_created), v_dflt_date),
               nvl(accsi.modified_by,v_dflt_usr)
 from  sbr_m.ac_csi accsi, nci_clsfctn_schm_item csi,  admin_item de
where accsi.ac_idseq = de.nci_idseq and
  accsi.cs_csi_idseq = csi.cs_csi_idseq;
commit;


end;


procedure sp_migrate_lov
as
v_cnt integer;

begin

sp_load_status;
begin
      execute immediate 'DROP SEQUENCE od_seq_objkey';
      exception when others then
        null;
end;
begin
    execute immediate 'CREATE SEQUENCE od_seq_objkey INCREMENT BY 1 START WITH 1000 NOCYCLE CACHE 20 NOORDER';
exception when others then
 null;
end;
delete from obj_key  where obj_typ_id in (1,3,11,14,15,18,19,20,21,22,23,25,26);
commit;

-- Program Area where obj_typ_id = 14

insert into obj_key (obj_typ_id, obj_key_desc, obj_key_def, nci_cd,obj_key_cmnts, CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID)
select 14, pal_name, description, pal_name, comments,               nvl(created_by,v_dflt_usr),
               nvl(date_created,v_dflt_date) ,
               nvl(NVL (date_modified, date_created), v_dflt_date),
               nvl(modified_by,v_dflt_usr)
 from sbr_m.PROGRAM_AREAS_LOV;
commit;


  -- Name/designation where obj_typ_id = 11;

insert into obj_key (obj_typ_id, obj_key_desc, obj_key_def, nci_cd,obj_key_cmnts, CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID)
select 11, detl_name, description, detl_name, comments,   nvl(created_by,v_dflt_usr),
               nvl(date_created,v_dflt_date) ,
               nvl(NVL (date_modified, date_created), v_dflt_date),
               nvl(modified_by,v_dflt_usr) from sbr_m.DESIGNATION_TYPES_LOV;
commit;

-- DOcument type where obj_typ_id = 1;  --


-- Preferred Question Text ID needs to be static. Used in views.
insert into OBJ_KEY (OBJ_KEY_ID, OBJ_TYP_ID, OBJ_KEY_DESC, OBJ_KEY_DEF, NCI_CD) values (80,1,'Preferred Question Text', 'Preferred Question Text for Data Element','Preferred Question Text');
commit;

-- Added 12/17 for form management
insert into OBJ_KEY (OBJ_KEY_ID, OBJ_TYP_ID, OBJ_KEY_DESC, OBJ_KEY_DEF, NCI_CD) values (81,1,'Alternate Question Text', 'Alternate Question Text for Data Element','Alternate Question Text');
commit;

insert into obj_key (obj_typ_id, obj_key_desc, obj_key_def, nci_cd,obj_key_cmnts, CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID)
select 1, DCTL_NAME, description, DCTL_NAME, comments,   nvl(created_by,v_dflt_usr),
               nvl(date_created,v_dflt_date) ,
               nvl(NVL (date_modified, date_created), v_dflt_date),
               nvl(modified_by,v_dflt_usr) from sbr_m.document_TYPES_LOV where DCTL_NAME not like 'Preferred Question Text'
               and DCTL_NAME not like 'Alternate Question Text';
commit;


-- Classification Scheme Type where obj_typ_id = 3;  --

insert into obj_key (obj_typ_id, obj_key_desc, obj_key_def, nci_cd,obj_key_cmnts, CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID)
select 3, CSTL_NAME, description, CSTL_NAME, comments,   nvl(created_by,v_dflt_usr),
               nvl(date_created,v_dflt_date) ,
               nvl(NVL (date_modified, date_created), v_dflt_date),
               nvl(modified_by,v_dflt_usr) from sbr_m.CS_TYPES_LOV;
commit;

-- Classification Scheme Item Type where obj_typ_id = 20;  --

insert into obj_key (obj_typ_id, obj_key_desc, obj_key_def, nci_cd,obj_key_cmnts, CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID)
select 20, CSITL_NAME, description, CSITL_NAME, comments,  nvl(created_by,v_dflt_usr),
               nvl(date_created,v_dflt_date) ,
               nvl(NVL (date_modified, date_created), v_dflt_date),
               nvl(modified_by,v_dflt_usr) from sbr_m.CSI_TYPES_LOV;
commit;

-- Protocol Type where obj_typ_id = 19;  --

insert into obj_key (obj_typ_id, obj_key_desc,  nci_cd)
select distinct 19, TYPE, TYPE from sbrext_m.protocols_ext where type is not null ;
commit;



-- Concept Source where obj_typ_id = 23;  --

/*Insirt static typeID*/
SP_SOURCE_TYPE;

select max(obj_key_id)+1 into v_cnt  from OBJ_KEY where obj_typ_id = 23;
/*Insirt new type ID*/
for cur in (
select CONCEPT_SOURCE,
DESCRIPTION,
nvl(created_by,v_dflt_usr) created_by,
nvl(date_created,v_dflt_date) date_created,
nvl(NVL (date_modified, date_created), v_dflt_date) date_modified,
nvl(modified_by,v_dflt_usr) modified_by
from sbrext_m.concept_sources_lov_ext c
where  NOT EXISTS (select*from obj_key where trim(NCI_CD)=trim(c.CONCEPT_SOURCE) and obj_typ_id=23)
)
loop

 insert into obj_key (obj_key_id,
 obj_typ_id,
 obj_key_desc,
 obj_key_def,
 nci_cd,
 CREAT_USR_ID,
 CREAT_DT,
 LST_UPD_DT,
 LST_UPD_USR_ID)
VALUES( v_cnt, 23,
cur.CONCEPT_SOURCE,
cur.DESCRIPTION,
cur.CONCEPT_SOURCE,
cur.created_by,
cur.date_created ,
cur.date_modified,
cur.date_created);
v_cnt := v_cnt + 1;
end loop;
COMMIT;



-- NCI Derivation Type where obj_typ_id = 21;  --

insert into obj_key (obj_typ_id, obj_key_desc,  nci_cd, obj_key_def,  CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID)
select 21, CRTL_NAME,CRTL_NAME, DESCRIPTION ,   nvl(created_by,v_dflt_usr),
               nvl(date_created,v_dflt_date) ,
               nvl(NVL (date_modified, date_created), v_dflt_date),
               nvl(modified_by,v_dflt_usr) from sbr_m.complex_rep_type_lov ;
commit;



--- Data type

delete from data_typ;
commit;
insert into data_typ ( DTTYPE_NM, NCI_CD, DTTYPE_DESC, NCI_DTTYPE_CMNTS,
CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID,
DTTYPE_SCHM_REF, DTTYPE_ANNTTN)
select DTL_NAME, DTL_NAME, DESCRIPTION,COMMENTS,
  nvl(created_by,v_dflt_usr),
               nvl(date_created,v_dflt_date) ,
               nvl(NVL (date_modified, date_created), v_dflt_date),
               nvl(modified_by,v_dflt_usr), SCHEME_REFERENCE, ANNOTATION from sbr_m.datatypes_lov;
commit;

-- Format
delete from FMT;
commit;
insert into FMT ( FMT_NM, NCI_CD,FMT_DESC,FMT_CMNTS,
CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID)
select FORML_NAME, FORML_NAME,DESCRIPTION,COMMENTS,
  nvl(created_by,v_dflt_usr),
               nvl(date_created,v_dflt_date) ,
               nvl(NVL (date_modified, date_created), v_dflt_date),
               nvl(modified_by,v_dflt_usr) from sbr_m.formats_lov;
commit;

-- UOM
delete from UOM;
commit;
insert into UOM ( UOM_NM,NCI_CD, UOM_PREC,UOM_DESC,UOM_CMNTS,
CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID)
select UOML_NAME,UOML_NAME,PRECISION,
DESCRIPTION,COMMENTS,
  nvl(created_by,v_dflt_usr),
               nvl(date_created,v_dflt_date) ,
               nvl(NVL (date_modified, date_created), v_dflt_date),
               nvl(modified_by,v_dflt_usr) from sbr_m.unit_of_measures_lov;
commit;




-- Definition type where obj_typ_id = 15;  --

insert into obj_key (obj_typ_id, obj_key_desc, obj_key_def, nci_cd,obj_key_cmnts, CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID)
select 15, DEFL_NAME, description, DEFL_NAME, comments,   nvl(created_by,v_dflt_usr),
               nvl(date_created,v_dflt_date) ,
               nvl(NVL (date_modified, date_created), v_dflt_date),
               nvl(modified_by,v_dflt_usr) from sbrext_m.definition_types_lov_ext;


commit;





-- Origin where obj_typ_id = 18;  --

insert into obj_key (obj_typ_id, obj_key_desc, obj_key_def, nci_cd, CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID)
select 18, SRC_NAME, description, SRC_NAME,   nvl(created_by,v_dflt_usr),
               nvl(date_created,v_dflt_date) ,
               nvl(NVL (date_modified, date_created), v_dflt_date),
               nvl(modified_by,v_dflt_usr) from sbrext_m.sources_ext;


commit;

-- Form Category where obj_typ_id = 22;  --

insert into obj_key (obj_typ_id, obj_key_desc, obj_key_def, nci_cd, CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID, DISP_ORD)
select 22, QCDL_NAME, description, QCDL_NAME,    nvl(created_by,v_dflt_usr),
               nvl(date_created,v_dflt_date) ,
               nvl(NVL (date_modified, date_created), v_dflt_date),
               nvl(modified_by,v_dflt_usr), DISPLAY_ORDER from sbrext_m.QC_DISPLAY_LOV_EXT;


commit;


-- GEt standard data types from Excel spreadsheet

update data_typ set nci_dttype_typ_id = 1;
commit;
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'Alpha DVG';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'ALPHANUMERIC';
update data_typ set NCI_DTTYPE_MAP = 'Class' where DTTYPE_NM = 'anyClass';
update data_typ set NCI_DTTYPE_MAP = 'Bit String' where DTTYPE_NM = 'binary';
update data_typ set NCI_DTTYPE_MAP = 'Boolean' where DTTYPE_NM = 'BOOLEAN';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'CHARACTER';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'CLOB';
update data_typ set NCI_DTTYPE_MAP = 'Date' where DTTYPE_NM = 'DATE';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'Date Alpha DVG';
update data_typ set NCI_DTTYPE_MAP = 'Date-and-Time' where DTTYPE_NM = 'DATE/TIME';
update data_typ set NCI_DTTYPE_MAP = 'Date-and-Time' where DTTYPE_NM = 'DATETIME';
update data_typ set NCI_DTTYPE_MAP = 'Class' where DTTYPE_NM = 'Derived';
update data_typ set NCI_DTTYPE_MAP = 'Class' where DTTYPE_NM = 'HL7CDv3';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'HL7EDv3';
update data_typ set NCI_DTTYPE_MAP = 'Integer' where DTTYPE_NM = 'HL7INTv3';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'HL7PNv3';
update data_typ set NCI_DTTYPE_MAP = 'Real' where DTTYPE_NM = 'HL7REALv3';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'HL7STv3';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'HL7TELv3';
update data_typ set NCI_DTTYPE_MAP = 'Time' where DTTYPE_NM = 'HL7TSv3';
update data_typ set NCI_DTTYPE_MAP = 'Integer' where DTTYPE_NM = 'Integer';
update data_typ set NCI_DTTYPE_MAP = 'Real' where DTTYPE_NM = 'Real';
update data_typ set NCI_DTTYPE_MAP = 'Octet' where DTTYPE_NM = 'Octet';
update data_typ set NCI_DTTYPE_MAP = 'Floating-point' where DTTYPE_NM = 'Floating-point' ;
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'ISO21090ADPartv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'ISO21090ADv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'ISO21090ADXPALv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'ISO21090ADXPCNTv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'ISO21090ADXPCTYv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'ISO21090ADXPDALv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'ISO21090ADXPSTAv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'ISO21090ADXPv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'ISO21090ADXPZIPv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'ISO21090ANYv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'ISO21090BAGv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Boolean' where DTTYPE_NM = 'ISO21090BLv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'ISO21090CDv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'ISO21090DSETv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'ISO21090EDTEXTv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'ISO21090EDv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'ISO21090ENONv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'ISO21090ENPNv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'ISO21090ENTNv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'ISO21090ENXPv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'ISO21090IIv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Integer' where DTTYPE_NM = 'ISO21090INTNTNEGv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Integer' where DTTYPE_NM = 'ISO21090INTPOSv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Integer' where DTTYPE_NM = 'ISO21090INTv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'ISO21090IVLv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Time' where DTTYPE_NM = 'ISO21090PQTIMEv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Real' where DTTYPE_NM = 'ISO21090PQv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Real' where DTTYPE_NM = 'ISO21090QTYv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Real' where DTTYPE_NM = 'ISO21090REALv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Real' where DTTYPE_NM = 'ISO21090RTOv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'ISO21090STSIMv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'ISO21090STv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'ISO21090TELURLv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'ISO21090TELv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Date-and-Time' where DTTYPE_NM = 'ISO21090TSDATFLv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Date-and-Time' where DTTYPE_NM = 'ISO21090TSDTTIv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Time' where DTTYPE_NM = 'ISO21090TSv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Integer' where DTTYPE_NM = 'ISO21090Tv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Real' where DTTYPE_NM = 'ISO21090URGv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Boolean' where DTTYPE_NM = 'java.lang.Boolean';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'java.lang.Byte';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'java.lang.Character';
update data_typ set NCI_DTTYPE_MAP = 'Real' where DTTYPE_NM = 'java.lang.Double';
update data_typ set NCI_DTTYPE_MAP = 'Floating-point' where DTTYPE_NM = 'java.lang.Float';
update data_typ set NCI_DTTYPE_MAP = 'Integer' where DTTYPE_NM = 'java.lang.Integer';
update data_typ set NCI_DTTYPE_MAP = 'Integer' where DTTYPE_NM = 'java.lang.Integer[]';
update data_typ set NCI_DTTYPE_MAP = 'Integer' where DTTYPE_NM = 'java.lang.Long';
update data_typ set NCI_DTTYPE_MAP = 'Bit String' where DTTYPE_NM = 'java.lang.Object';
update data_typ set NCI_DTTYPE_MAP = 'Integer' where DTTYPE_NM = 'java.lang.Short';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'java.lang.String';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'java.lang.String[]';
update data_typ set NCI_DTTYPE_MAP = 'Date-and-Time' where DTTYPE_NM = 'java.sql.Timestamp';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'java.util.Collection';
update data_typ set NCI_DTTYPE_MAP = 'Date-and-Time' where DTTYPE_NM = 'java.util.Date';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'java.util.Map';
update data_typ set NCI_DTTYPE_MAP = 'Real' where DTTYPE_NM = 'NUMBER';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'Numeric Alpha DVG';
update data_typ set NCI_DTTYPE_MAP = 'Bit String' where DTTYPE_NM = 'OBJECT';
update data_typ set NCI_DTTYPE_MAP = 'Integer' where DTTYPE_NM = 'SAS Date';
update data_typ set NCI_DTTYPE_MAP = 'Integer' where DTTYPE_NM = 'SAS Time';
update data_typ set NCI_DTTYPE_MAP = 'Time' where DTTYPE_NM = 'TIME';
update data_typ set NCI_DTTYPE_MAP = 'Bit String' where DTTYPE_NM = 'UMLBinaryv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'UMLCodev1.0';
update data_typ set NCI_DTTYPE_MAP = 'Octet' where DTTYPE_NM = 'UMLOctetv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'UMLUidv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'UMLUriv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'UMLXMLv1.0';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'varchar';
update data_typ set NCI_DTTYPE_MAP = 'Boolean' where DTTYPE_NM = 'xsd:boolean';
update data_typ set NCI_DTTYPE_MAP = 'Date-and-Time' where DTTYPE_NM = 'xsd:dateTime';
update data_typ set NCI_DTTYPE_MAP = 'Character' where DTTYPE_NM = 'xsd:string';
commit;

update data_typ set NCI_DTTYPE_MAP = 'Character' where NCI_DTTYPE_MAP is null;
commit;

-- insert standard datatypes
insert into data_typ(dttype_nm, nci_dttype_typ_id)
select distinct NCI_DTTYPE_MAP, 2 from data_typ where NCI_DTTYPE_MAP is not null;
commit;

-- where the name is the same
update data_typ a set NCI_DFLT_LEGCY_ID = (select DTTYPE_ID from data_typ b where b.NCI_DTTYPE_TYP_ID = 1 and upper(b.DTTYPE_NM) = upper(a.DTTYPE_NM))
where NCI_DTTYPE_TYP_ID = 2 and NCI_DFLT_LEGCY_ID is null;
commit;

--Bit String	binary

update data_typ a set NCI_DFLT_LEGCY_ID = (select DTTYPE_ID from data_typ b where  upper(b.DTTYPE_NM) = 'BINARY')
where NCI_DTTYPE_TYP_ID = 2 and upper(a.DTTYPE_NM) = 'BIT STRING';
commit;

--Class	anyClass

update data_typ a set NCI_DFLT_LEGCY_ID = (select DTTYPE_ID from data_typ b where  upper(b.DTTYPE_NM) = 'ANYCLASS')
where NCI_DTTYPE_TYP_ID = 2 and upper(a.DTTYPE_NM) = 'CLASS';
commit;


--Date-and-Time	DATETIME

update data_typ a set NCI_DFLT_LEGCY_ID = (select DTTYPE_ID from data_typ b where  upper(b.DTTYPE_NM) = 'DATETIME')
where NCI_DTTYPE_TYP_ID = 2 and upper(a.DTTYPE_NM) = 'DATE-AND-TIME';
commit;

--Real

update data_typ a set NCI_DFLT_LEGCY_ID = (select DTTYPE_ID from data_typ b where  upper(b.DTTYPE_NM) = 'HL7REALV3')
where NCI_DTTYPE_TYP_ID = 2 and upper(a.DTTYPE_NM) = 'REAL';
commit;

--Octet

update data_typ a set NCI_DFLT_LEGCY_ID = (select DTTYPE_ID from data_typ b where  upper(b.DTTYPE_NM) = 'UMLOCTETV1.0')
where NCI_DTTYPE_TYP_ID = 2 and upper(a.DTTYPE_NM) = 'OCTET';
commit;

--Floating Point

update data_typ a set NCI_DFLT_LEGCY_ID = (select DTTYPE_ID from data_typ b where  upper(b.DTTYPE_NM) = 'JAVA.LANG.FLOAT')
where NCI_DTTYPE_TYP_ID = 2 and upper(a.DTTYPE_NM) = 'FLOATING-POINT';
commit;


/*
Standard	caDSR Legacy
Bit String	binary
Class	anyClass

Open questions
Floating-point	Floating-point
Octet	Octet
Real	Real
*/


delete from lang;
commit;

INSERT INTO LANG ( CNTRY_ISO_CD, LANG_ISO_CD, LANG_ID, LANG_NM,
LANG_DESC ) VALUES (
NULL, NULL, 1007, 'ICELANDIC', 'Icelandic');
INSERT INTO LANG ( CNTRY_ISO_CD, LANG_ISO_CD, LANG_ID, LANG_NM,
LANG_DESC ) VALUES (
NULL, NULL, 1000, 'ENGLISH', 'English');
commit;
INSERT INTO LANG ( CNTRY_ISO_CD, LANG_ISO_CD, LANG_ID, LANG_NM,
LANG_DESC ) VALUES (
NULL, NULL, 1004, 'SPANISH', 'Spanish');
commit;
commit;



 -- Address Type obj_typ_id = 25;

insert into obj_key (obj_typ_id, obj_key_desc, obj_key_def, nci_cd,obj_key_cmnts, CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID)
select 25, ATL_NAME, description, ATL_NAME, comments,   nvl(created_by,v_dflt_usr),
               nvl(date_created,v_dflt_date) ,
               nvl(NVL (date_modified, date_created), v_dflt_date),
               nvl(modified_by,v_dflt_usr) from sbr_m.ADDR_TYPES_LOV	;
commit;

 -- Communication Type obj_typ_id = 26;

insert into obj_key (obj_typ_id, obj_key_desc, obj_key_def, nci_cd,obj_key_cmnts, CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID)
select 26, CTL_NAME, description, CTL_NAME, comments,  nvl(created_by,v_dflt_usr),
               nvl(date_created,v_dflt_date) ,
               nvl(NVL (date_modified, date_created), v_dflt_date),
               nvl(modified_by,v_dflt_usr) from sbr_m.COMM_TYPES_LOV;
 commit;
--               insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (54,50);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (52,59);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (4,65);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (3,65);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (2,65);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (5,65);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (6,65);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (1,66);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (51,66);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (9,66);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (49,66);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (7,66);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (53,66);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (54,66);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (50,66);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (8,66);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (56,66);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (52,66);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (4,66);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (3,66);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (2,66);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (5,66);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (6,66);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (1,75);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (51,75);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (9,75);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (49,75);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (7,75);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (53,75);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (54,75);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (50,75);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (8,75);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (56,75);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (52,75);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (4,75);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (3,75);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (2,75);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (5,75);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (6,75);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (4,76);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (3,76);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (2,76);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (5,76);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (6,76);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (1,77);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (51,77);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (9,77);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (49,77);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (7,77);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (53,77);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (54,77);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (4,77);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (3,77);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (2,77);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (5,77);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (6,77);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (8,81);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (56,81);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (52,81);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (52,83);
--insert into NCI_AI_TYP_VALID_STUS (ADMIN_ITEM_TYP_ID, STUS_ID) values (52,84);
insert into NCI_AI_TYP_VALID_STUS (STUS_ID,ADMIN_ITEM_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_DT,LST_UPD_USR_ID)
select stus_id, obj_key_id,
              nvl(e.date_created,v_dflt_date) ,
  nvl(e.created_by,v_dflt_usr),
                nvl(NVL (e.date_modified, e.date_created), v_dflt_date),
               nvl(e.modified_by,v_dflt_usr)
from sbrext_m.ASL_ACTL_EXT e, stus_mstr s, obj_key o
where e.ASL_NAME = s.nci_stus and s.stus_typ_id = 2 and o.nci_cd = e.ACTL_NAME and o.obj_typ_id = 4;
commit;


insert into NCI_AI_TYP_VALID_STUS (STUS_ID,ADMIN_ITEM_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_DT,LST_UPD_USR_ID)
select stus_id, 53,               nvl(e.date_created,v_dflt_date) ,
  nvl(e.created_by,v_dflt_usr),
                nvl(NVL (e.date_modified, e.date_created), v_dflt_date),
               nvl(e.modified_by,v_dflt_usr)
from sbrext_m.ASL_ACTL_EXT e, stus_mstr s
where e.ASL_NAME = s.nci_stus and s.stus_typ_id = 2 and e.ACTL_NAME = 'VALUE_MEANING';
commit;

--Form
insert into NCI_AI_TYP_VALID_STUS (STUS_ID,ADMIN_ITEM_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_DT,LST_UPD_USR_ID)
select stus_id, 54,               nvl(e.date_created,v_dflt_date) ,
  nvl(e.created_by,v_dflt_usr),
                nvl(NVL (e.date_modified, e.date_created), v_dflt_date),
               nvl(e.modified_by,v_dflt_usr)
from sbrext_m.ASL_ACTL_EXT e, stus_mstr s
where e.ASL_NAME = s.nci_stus and s.stus_typ_id = 2 and e.ACTL_NAME = 'QUEST_CONTENT';
commit;

--Module
insert into NCI_AI_TYP_VALID_STUS (STUS_ID,ADMIN_ITEM_TYP_ID,CREAT_DT,CREAT_USR_ID,LST_UPD_DT,LST_UPD_USR_ID)
select stus_id, 52,              nvl(e.date_created,v_dflt_date) ,
  nvl(e.created_by,v_dflt_usr),
                nvl(NVL (e.date_modified, e.date_created), v_dflt_date),
               nvl(e.modified_by,v_dflt_usr)
from sbrext_m.ASL_ACTL_EXT e, stus_mstr s
where e.ASL_NAME = s.nci_stus and s.stus_typ_id = 2 and e.ACTL_NAME = 'QUEST_CONTENT';
commit;

/*
-- Adding DRAFT-new for all Admin_item_types

insert into NCI_AI_TYP_VALID_STUS (STUS_ID,ADMIN_ITEM_TYP_ID)
select 66, obj_key_id from
(select obj_key_id from vw_obj_key_4
minus
select admin_item_typ_id from NCI_AI_TYP_VALID_STUS where stus_id = 66);
commit;

*/

insert into NCI_AI_TYP_VALID_STUS (STUS_ID,ADMIN_ITEM_TYP_ID)
select stus_id,51 from vw_admin_stus where
nci_stus in (
--'APPRVD FOR TRIAL USE',
'DRAFT MOD',
'RELEASED',
--'RELEASED-NON-CMPLNT',
'RETIRED ARCHIVED');
--'RETIRED DELETED',
--'RETIRED PHASED OUT',
--'RETIRED WITHDRAWN');

commit;

end;

PROCEDURE            sp_create_form_ext
AS
    v_cnt   INTEGER;
BEGIN
    -- Create AI for TEmplate, Form, Protocol, Module



    DELETE FROM nci_form;

    COMMIT;

    DELETE FROM nci_protcl;

    COMMIT;

    DELETE FROM admin_item
          WHERE admin_item_typ_id IN (50,
                                      52,
                                      54,
                                      55);

    COMMIT;


    INSERT /*+ APPEND */
           INTO admin_item (NCI_IDSEQ,
                            ADMIN_ITEM_TYP_ID,
                            ADMIN_STUS_ID,
                            ADMIN_STUS_NM_DN,
                            EFF_DT,
                            CHNG_DESC_TXT,
                            CNTXT_ITEM_ID,
                            CNTXT_VER_NR,
                            CNTXT_NM_DN,
                            UNTL_DT,
                            CURRNT_VER_IND,
                            ITEM_LONG_NM,
                            ORIGIN,
                            ITEM_DESC,
                            ITEM_ID,
                            ITEM_NM,
                            UNRSLVD_ISSUE,
                            VER_NR,
                            CREAT_USR_ID,
                            CREAT_DT,
                            LST_UPD_DT,
                            LST_UPD_USR_ID)
        SELECT qc.qc_idseq,
               54,
               s.stus_id,
               s.nci_STUS,
               qc.begin_date,
               qc.change_note,
               cntxt.item_id,
               cntxt.ver_nr,
               cntxt.item_nm,
               qc.end_date,
               DECODE (UPPER (qc.latest_version_ind),  'YES', 1,  'NO', 0),
               qc.preferred_name,
               qc.origin,
               qc.preferred_definition,
               qc.qc_id,
               NVL (qc.long_name, qc.preferred_name),
               ac.unresolved_issue,
               qc.version,
     nvl(qc.created_by,v_dflt_usr),
               nvl(qc.date_created,v_dflt_date) ,
               nvl(NVL (qc.date_modified, qc.date_created), v_dflt_date),
               nvl(qc.modified_by,v_dflt_usr)
           FROM sbr_m.administered_components  ac,
               admin_item                   cntxt,
               stus_mstr                    s,
               sbrext_m.quest_contents_ext    qc
         WHERE     qc.conte_idseq = cntxt.nci_idseq
               AND TRIM (ac.asl_name) = TRIM (s.nci_STUS)
               AND ac.actl_name = 'QUEST_CONTENT'
               AND   cntxt.admin_item_typ_id = 8
               AND ac.ac_idseq = qc.qc_idseq
               AND qc.qtl_name IN ('TEMPLATE', 'CRF');

    COMMIT;

    DELETE FROM nci_form;

    COMMIT;


    INSERT INTO nci_form (item_id,
                          ver_nr,
                          catgry_id,
                          form_typ_id,
                          CREAT_USR_ID,
                          CREAT_DT,
                          LST_UPD_DT,
                          LST_UPD_USR_ID)
        SELECT qc_id,
               version,
               ok.obj_key_id,
               DECODE (qc.qtl_name,  'CRF', 70,  'TEMPLATE', 71),
     nvl(created_by,v_dflt_usr),
               nvl(date_created,v_dflt_date) ,
               nvl(NVL (date_modified, date_created), v_dflt_date),
               nvl(modified_by,v_dflt_usr)
          FROM sbrext_m.quest_contents_ext qc, obj_key ok
         WHERE     qc.qcdl_name = ok.nci_cd(+)
               AND ok.obj_typ_id(+) = 22
               AND qc.qtl_name IN ('TEMPLATE', 'CRF');

    COMMIT;

INSERT /*+ APPEND */
           INTO admin_item (NCI_IDSEQ,
                            ADMIN_ITEM_TYP_ID,
                            ADMIN_STUS_ID,
                            ADMIN_STUS_NM_DN,
                            EFF_DT,
                            CHNG_DESC_TXT,
                            CNTXT_ITEM_ID,
                            CNTXT_VER_NR,
                            CNTXT_NM_DN,
                            UNTL_DT,
                            CURRNT_VER_IND,
                            ITEM_LONG_NM,
                            ORIGIN,
                            ITEM_DESC,
                            ITEM_NM,
                            ITEM_ID,
                            UNRSLVD_ISSUE,
                            VER_NR,
                            CREAT_USR_ID,
                            CREAT_DT,
                            LST_UPD_DT,
                            LST_UPD_USR_ID)
        SELECT qc.qc_idseq,
               52,
               s.stus_id,
               s.NCI_STUS,
               qc.begin_date,
               qc.change_note,
               cntxt.item_id,
               cntxt.ver_nr,
               cntxt.item_nm,
               qc.end_date,
               DECODE (UPPER (qc.latest_version_ind),  'YES', 1,  'NO', 0),
               qc.preferred_name,
               qc.origin,
               qc.preferred_definition,
               substr(NVL (qc.long_name, qc.preferred_name),1,255),
               qc.qc_id,
               ac.unresolved_issue,
               qc.version,
     nvl(qc.created_by,v_dflt_usr),
               nvl(qc.date_created,v_dflt_date) ,
               nvl(NVL (qc.date_modified, qc.date_created), v_dflt_date),
               nvl(qc.modified_by,v_dflt_usr)
          FROM sbr_m.administered_components  ac,
               admin_item                   cntxt,
               stus_mstr                    s,
               sbrext_m.quest_contents_ext    qc
         WHERE     qc.conte_idseq = cntxt.nci_idseq
               AND TRIM (ac.asl_name) = TRIM (s.nci_STUS)
               AND ac.actl_name = 'QUEST_CONTENT'
               AND cntxt.admin_item_typ_id = 8
               AND ac.ac_idseq = qc.qc_idseq
               AND qc.qtl_name = 'MODULE';


    COMMIT;

-- Added 9/19
insert into nci_module (ITEM_ID, VER_NR,CREAT_USR_ID,
                            CREAT_DT,
                            LST_UPD_DT,
                            LST_UPD_USR_ID) select ITEM_ID, VER_NR,CREAT_USR_ID,
                            CREAT_DT,
                            LST_UPD_DT,
                            LST_UPD_USR_ID from admin_ITEM where admin_item_typ_id = 52;
commit;

    INSERT /*+ APPEND */
           INTO admin_item (NCI_IDSEQ,
                            ADMIN_ITEM_TYP_ID,
                            ADMIN_STUS_ID,
                            ADMIN_STUS_NM_DN,
                            EFF_DT,
                            CHNG_DESC_TXT,
                            CNTXT_ITEM_ID,
                            CNTXT_VER_NR,
                            CNTXT_NM_DN,
                            UNTL_DT,
                            CURRNT_VER_IND,
                            ITEM_LONG_NM,
                            ORIGIN,
                            ITEM_DESC,
                            ITEM_ID,
                            ITEM_NM,
                            UNRSLVD_ISSUE,
                            VER_NR,
                            CREAT_USR_ID,
                            CREAT_DT,
                            LST_UPD_DT,
                            LST_UPD_USR_ID)
        SELECT p.proto_IDSEQ,
               50,
               s.stus_id,
               s.nci_stus,
               p.begin_date,
               p.change_note,
               cntxt.item_id,
               cntxt.ver_nr,
               cntxt.item_nm,
               p.end_date,
               DECODE (UPPER (p.latest_version_ind),  'YES', 1,  'NO', 0),
               p.preferred_name,
               p.origin,
               p.preferred_definition,
               p.proto_id,
               NVL (p.long_name, p.preferred_name),
               ac.unresolved_issue,
               p.version,
     nvl(p.created_by,v_dflt_usr),
               nvl(p.date_created,v_dflt_date) ,
               nvl(NVL (p.date_modified, p.date_created), v_dflt_date),
               nvl(p.modified_by,v_dflt_usr)
          FROM sbr_m.administered_components ac, admin_item cntxt,
               stus_mstr s      ,sbrext_m.protocols_ext p
         WHERE     p.conte_idseq = cntxt.nci_idseq
               AND TRIM (ac.asl_name) = TRIM (s.nci_STUS)
               AND ac.actl_name = 'PROTOCOL'
               AND p.proto_IDSEQ = ac.ac_idseq
               AND cntxt.admin_item_typ_id = 8;


    COMMIT;



  INSERT INTO nci_protcl (item_id,
                            ver_nr,
                            PROTCL_TYP_ID,
                            PROTCL_ID,
                            LEAD_ORG,
                            PROTCL_PHASE,
                            creat_usr_id,
                            CREAT_DT,
                            LST_UPD_DT,
                            LST_UPD_USR_ID,
                            CHNG_TYP,
                            CHNG_NBR,
                            RVWD_DT,
                            RVWD_USR_ID,
                            APPRVD_DT,
                            APPRVD_USR_ID,
                            LEAD_ORG_ID)
        SELECT ai.item_id,
               ai.ver_nr,
               ok.obj_key_id,
               protocol_id,
               LEAD_ORG,
               PHASE,
nvl(cd.created_by,v_dflt_usr),
               nvl(cd.date_created,v_dflt_date) ,
               nvl(NVL (cd.date_modified, cd.date_created), v_dflt_date),
               nvl(cd.modified_by,v_dflt_usr),
                    CHANGE_TYPE,
               CHANGE_NUMBER,
               REVIEWED_DATE,
               REVIEWED_BY,
               APPROVED_DATE,
               APPROVED_BY,
               ORG.ENTTY_ID
          FROM sbrext_m.protocols_ext cd, admin_item ai, obj_key ok, nci_org org
         WHERE     ai.NCI_IDSEQ = cd.proto_IDSEQ
               AND TRIM (TYPE) = ok.nci_cd(+)
               AND ok.obj_typ_id(+) = 19
               AND ai.admin_item_typ_id = 50
               and cd.LEAD_ORG =org.ORG_NM(+);

    COMMIT;
END;

procedure sp_reorder_mod
as
i integer;
begin

for cur in (select distinct p_item_id, p_item_ver_nr from nci_admin_item_rel where rel_typ_id = 61 group by p_item_id, p_item_ver_nr, disp_ord having count(*) > 1) loop
i := 0;
for cur1 in (select * from nci_admin_item_rel where rel_typ_id = 61 and p_item_id = cur.p_item_id and p_item_ver_nr = cur.p_item_ver_nr order by disp_ord) loop
update nci_admin_item_rel set disp_ord  = i where rel_typ_id = 61 and p_item_id = cur.p_item_id and p_item_ver_nr = cur.p_item_ver_nr
and c_item_id = cur1.c_item_id and c_item_ver_nr = cur1.c_item_ver_nr;
i := i + 1;
end loop;
commit;
end loop;
end;

PROCEDURE            sp_create_form_question_rel
AS
    v_cnt   INTEGER;
BEGIN
    DELETE FROM nci_admin_item_rel_alt_key
          WHERE rel_typ_id = 63;

    COMMIT;

    INSERT /*+ APPEND */
           INTO nci_admin_item_rel_alt_key (P_ITEM_ID,
                                            P_ITEM_VER_NR,
                                            C_ITEM_ID,
                                            C_ITEM_VER_NR,
                                            --CNTXT_ITEM_ID, CNTXT_VER_NR,
                                            REL_TYP_ID,
                                            NCI_PUB_ID,
                                            NCI_IDSEQ,
                                            NCI_VER_NR,
                                            EDIT_IND,
                                            REQ_IND,
                                            DEFLT_VAL,
                                            ITEM_LONG_NM,
        DISP_ORD,
        ITEM_NM,
        PREF_NM_MIGRATED ,
        CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, LST_UPD_DT)
        SELECT  MOD.item_id,
                        MOD.ver_nr,
                        de.item_id,
                        de.ver_nr,
                        63,
                        QC_ID,
                        qc.QC_IDSEQ,
                        QC.VERSION,
                        DECODE (qa.editable_ind,  'Yes', 1,  'No', 0,  1),
                        DECODE (qa.mandatory_ind,  'Yes', 1,  'No', 0,  0),
                        qa.DEFAULT_VALUE,
                        LONG_NAME
          , qc.DISPLAY_ORDER,
          de.ITEM_LONG_NM,
          qc.preferred_name,
               nvl(qc.date_created,v_dflt_date) ,
          nvl(qc.created_by,v_dflt_usr),
               nvl(qc.modified_by,v_dflt_usr),
             nvl(NVL (qc.date_modified, qc.date_created), v_dflt_date)
          FROM admin_item                   de,
               admin_item                   MOD,
               sbrext_m.quest_contents_ext    qc,
               sbrext_m.QUEST_ATTRIBUTES_EXT  qa
         WHERE     de.nci_idseq = qc.De_idseq
               AND MOD.nci_idseq = qc.p_mod_idseq
               AND qc.qtl_name = 'QUESTION'
               AND de.admin_item_typ_id = 4
               AND MOD.admin_item_typ_id = 52
               AND qc.de_idseq IS NOT NULL
               AND qc.qc_idseq = qa.qc_idseq(+);

    COMMIT;



    INSERT /*+ APPEND */
           INTO nci_admin_item_rel_alt_key (P_ITEM_ID,
                                            P_ITEM_VER_NR,
                              --              C_ITEM_ID,
                               --             C_ITEM_VER_NR,
                                            --CNTXT_ITEM_ID, CNTXT_VER_NR,
                                            REL_TYP_ID,
                                            NCI_PUB_ID,
                                            NCI_IDSEQ,
                                            NCI_VER_NR,
                                            EDIT_IND,
                                            REQ_IND,
                                            DEFLT_VAL,
                                            ITEM_LONG_NM,
                                            ITEM_NM,
        DISP_ORD,
        CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, LST_UPD_DT)
        SELECT DISTINCT MOD.item_id,
                        MOD.ver_nr,
                    --    -10005,
                      --  1,
                        63,
                        QC_ID,
                        qc.QC_IDSEQ,
                        QC.VERSION,
                        DECODE (qa.editable_ind,  'Yes', 1,  'No', 0,1),
                        DECODE (qa.mandatory_ind,  'Yes', 1,  'No', 0, 0),
                        qa.DEFAULT_VALUE,
                        LONG_NAME
          , qc.PREFERRED_NAME
          , qc.DISPLAY_ORDER
          , nvl(qc.date_created,v_dflt_date) ,
          nvl(qc.created_by,v_dflt_usr),
               nvl(qc.modified_by,v_dflt_usr),
             nvl(NVL (qc.date_modified, qc.date_created), v_dflt_date)
          FROM admin_item                   MOD,
               sbrext_m.quest_contents_ext    qc,
               sbrext_m.QUEST_ATTRIBUTES_EXT  qa
         WHERE     MOD.nci_idseq = qc.p_mod_idseq
               AND qc.qtl_name = 'QUESTION'
               AND MOD.admin_item_typ_id = 52
               AND qc.de_idseq IS NULL
               AND qc.qc_idseq = qa.qc_idseq(+);

    COMMIT;
END;

PROCEDURE            sp_create_form_rel
AS
    v_cnt   INTEGER;
BEGIN
    DELETE FROM nci_admin_item_rel
          WHERE rel_typ_id IN (61, 60);

    COMMIT;


    -- new table for Protocol-form relationship
    -- Do not add audit columns

    INSERT INTO nci_admin_item_rel (P_ITEM_ID,
                                    P_ITEM_VER_NR,
                                    C_ITEM_ID,
                                    C_ITEM_VER_NR,
                                    --CNTXT_ITEM_ID, CNTXT_VER_NR,
                                    REL_TYP_ID)
        SELECT DISTINCT pro.item_id,
                        pro.ver_nr,
                        frm.item_id,
                        frm.ver_nr,
                        60
          --, qc.DISPLAY_ORDER
          FROM admin_item pro, admin_item frm, sbrext_m.protocol_qc_ext qc
         WHERE     pro.nci_idseq = qc.proto_idseq
               AND frm.nci_idseq = qc.qc_idseq
               AND pro.admin_item_typ_id = 50
               AND frm.admin_item_typ_id = 54;

    COMMIT;

    -- Form-module relationship
    INSERT INTO nci_admin_item_rel (P_ITEM_ID,
                                    P_ITEM_VER_NR,
                                    C_ITEM_ID,
                                    C_ITEM_VER_NR,
                                    --CNTXT_ITEM_ID, CNTXT_VER_NR,
                                    REL_TYP_ID,
                                    DISP_ORD,
                                    REP_NO,
                                    --DISP_LBL,
                                    CREAT_DT,
                                    CREAT_USR_ID,
                                    LST_UPD_USR_ID,
                                    LST_UPD_DT)
        SELECT DISTINCT frm.item_id,
                        frm.ver_nr,
                        MOD.item_id,
                        MOD.ver_nr,
                        61,
                        qc.DISPLAY_ORDER,
                        nvl(qc.REPEAT_NO,0),
                        qc.DATE_CREATED,
                        qc.CREATED_BY,
                        NVL (qc.MODIFIED_BY, qc.date_created),
                        DATE_MODIFIED
          FROM admin_item MOD, admin_item frm, sbrext_m.quest_contents_ext qc
         WHERE     MOD.nci_idseq = qc.qc_idseq
               AND frm.nci_idseq = qc.dn_crf_idseq
               AND qc.qtl_name = 'MODULE'
               AND MOD.admin_item_typ_id = 52
               AND frm.admin_item_typ_id = 54;

    COMMIT;
END;

 PROCEDURE            sp_create_form_ta
AS
    v_cnt   INTEGER;
BEGIN
    DELETE FROM nci_form_ta_rel;

    COMMIT;

    DELETE FROM nci_form_ta;

    COMMIT;


    --MODULE MODULE

    INSERT INTO NCI_FORM_TA (FORM_ITEM_ID, FORM_VER_NR, MOD_ITEM_ID, MOD_VER_NR, 
                            SRC_PUB_ID,
                             SRC_VER_NR,
                             TRGT_PUB_ID,
                             TRGT_VER_NR,
                             TA_INSTR,
                             SRC_TYP_NM,
                             TRGT_TYP_NM,
                             TA_IDSEQ,
                             CREAT_DT,
                             CREAT_USR_ID,
                             LST_UPD_USR_ID,
                             LST_UPD_DT)
        SELECT frm.p_item_id, frm.p_item_ver_nr, mod1.item_id, mod1.ver_nr, 
                mod1.item_id,
               mod1.ver_nr,
               mod2.item_id,
               mod2.ver_nr,
               TA_INSTRUCTION,
               S_QTL_NAME,
               T_QTL_NAME,
               TA_IDSEQ,
               nvl(ta.date_created,v_dflt_date) ,
          nvl(ta.created_by,v_dflt_usr),
               nvl(ta.modified_by,v_dflt_usr),
             nvl(NVL (ta.date_modified, ta.date_created), v_dflt_date)
          FROM sbrext_m.triggered_actions_ext  ta,
               admin_item                    mod1,
               admin_item                    mod2,
               nci_admin_item_rel   frm
         WHERE     mod1.admin_item_typ_id = 52
               AND mod2.admin_item_typ_id = 52
               AND ta.s_qc_idseq = mod1.nci_idseq
               AND ta.t_qc_idseq = mod2.nci_idseq and
               mod1.item_id = frm.c_item_id and mod1.ver_nr = frm.c_item_ver_nr;

    COMMIT;

    --MODULE QUESTION

     INSERT INTO NCI_FORM_TA (FORM_ITEM_ID, FORM_VER_NR, MOD_ITEM_ID, MOD_VER_NR, 
                      SRC_PUB_ID,
                             SRC_VER_NR,
                             TRGT_PUB_ID,
                             TRGT_VER_NR,
                             TA_INSTR,
                             SRC_TYP_NM,
                             TRGT_TYP_NM,
                             TA_IDSEQ,
                             CREAT_DT,
                             CREAT_USR_ID,
                             LST_UPD_USR_ID,
                             LST_UPD_DT)
        SELECT frm.p_item_id, frm.p_item_ver_nr, mod1.item_id, mod1.ver_nr, 
                mod1.item_id,
               mod1.ver_nr,
               quest.nci_pub_id,
               quest.nci_ver_nr,
               TA_INSTRUCTION,
               S_QTL_NAME,
               T_QTL_NAME,
               TA_IDSEQ,
               nvl(ta.date_created,v_dflt_date) ,
          nvl(ta.created_by,v_dflt_usr),
               nvl(ta.modified_by,v_dflt_usr),
             nvl(NVL (ta.date_modified, ta.date_created), v_dflt_date)
          FROM sbrext_m.triggered_actions_ext  ta,
               admin_item                    mod1,
               nci_admin_item_rel_alt_key    quest,
               nci_admin_item_rel frm
         WHERE     mod1.admin_item_typ_id = 52
               AND quest.rel_typ_id = 63
               AND ta.s_qc_idseq = mod1.nci_idseq
               AND ta.t_qc_idseq = quest.nci_idseq
              and               mod1.item_id = frm.c_item_id and mod1.ver_nr = frm.c_item_ver_nr; 

    COMMIT;


    /*-- QUESTION QUESTION


    INSERT INTO NCI_FORM_TA (SRC_PUB_ID,
                             SRC_VER_NR,
                             TRGT_PUB_ID,
                             TRGT_VER_NR,
                             TA_INSTR,
                             SRC_TYP_NM,
                             TRGT_TYP_NM,
                             TA_IDSEQ,
                             CREAT_DT,
                             CREAT_USR_ID,
                             LST_UPD_USR_ID,
                             LST_UPD_DT)
        SELECT quest1.nci_pub_id,
               quest1.nci_ver_nr,
               quest2.nci_pub_id,
               quest2.nci_ver_nr,
               TA_INSTRUCTION,
               S_QTL_NAME,
               T_QTL_NAME,
               TA_IDSEQ,
               nvl(ta.date_created,v_dflt_date) ,
          nvl(ta.created_by,v_dflt_usr),
               nvl(ta.modified_by,v_dflt_usr),
             nvl(NVL (ta.date_modified, ta.date_created), v_dflt_date)
          FROM sbrext_m.triggered_actions_ext  ta,
               nci_admin_item_rel_alt_key    quest1,
               nci_admin_item_rel_alt_key    quest2
         WHERE     --quest1.rel_typ_id = 63
                   --and quest2.rel_typ_id = 63 and
                   ta.s_qc_idseq = quest1.nci_idseq
               AND ta.t_qc_idseq = quest2.nci_idseq;

    COMMIT;
*/

    --VALID_VALUE QUESTION


      INSERT INTO NCI_FORM_TA (FORM_ITEM_ID, FORM_VER_NR, MOD_ITEM_ID, MOD_VER_NR, 
                      SRC_PUB_ID,
                              SRC_VER_NR,
                             TRGT_PUB_ID,
                             TRGT_VER_NR,
                             TA_INSTR,
                             SRC_TYP_NM,
                             TRGT_TYP_NM,
                             TA_IDSEQ,
                             CREAT_DT,
                             CREAT_USR_ID,
                             LST_UPD_USR_ID,
                             LST_UPD_DT)
        SELECT frmmod.p_item_id, frmmod.p_item_ver_nr, frmmod.c_item_id, frmmod.c_item_ver_nr,
        vv.nci_pub_id,
               vv.nci_ver_nr,
               quest.nci_pub_id,
               quest.nci_ver_nr,
               TA_INSTRUCTION,
               S_QTL_NAME,
               T_QTL_NAME,
               TA_IDSEQ,
nvl(ta.date_created,v_dflt_date) ,
          nvl(ta.created_by,v_dflt_usr),
               nvl(ta.modified_by,v_dflt_usr),
             nvl(NVL (ta.date_modified, ta.date_created), v_dflt_date)
             FROM sbrext_m.triggered_actions_ext  ta,
               nci_quest_Valid_value         vv,
               nci_admin_item_rel_alt_key    quest,
               nci_admin_item_rel frmmod
         WHERE     quest.rel_typ_id = 63
         and    quest.p_item_id = frmmod.c_item_id
         and quest.p_item_ver_nr = frmmod.c_item_ver_nr
               AND ta.s_qc_idseq = vv.nci_idseq
               AND ta.t_qc_idseq = quest.nci_idseq;

    COMMIT;

    --VALID_VALUE MODULE


     INSERT INTO NCI_FORM_TA (FORM_ITEM_ID, FORM_VER_NR, MOD_ITEM_ID, MOD_VER_NR, 
                      SRC_PUB_ID,
                              SRC_VER_NR,
                             TRGT_PUB_ID,
                             TRGT_VER_NR,
                             TA_INSTR,
                             SRC_TYP_NM,
                             TRGT_TYP_NM,
                             TA_IDSEQ,
                             CREAT_DT,
                             CREAT_USR_ID,
                             LST_UPD_USR_ID,
                             LST_UPD_DT)
           SELECT frm.p_item_id, frm.p_item_ver_nr, mod.item_id, mod.ver_nr,
       vv.nci_pub_id,
               vv.nci_ver_nr,
               MOD.item_id,
               MOD.ver_nr,
               TA_INSTRUCTION,
               S_QTL_NAME,
               T_QTL_NAME,
               TA_IDSEQ,
               nvl(ta.date_created,v_dflt_date) ,
          nvl(ta.created_by,v_dflt_usr),
               nvl(ta.modified_by,v_dflt_usr),
             nvl(NVL (ta.date_modified, ta.date_created), v_dflt_date)
          FROM sbrext_m.triggered_actions_ext  ta,
               nci_quest_Valid_value         vv,
               admin_item                    MOD,
               nci_admin_item_rel  frm
         WHERE     MOD.admin_item_typ_id = 52
               AND ta.s_qc_idseq = vv.nci_idseq
               AND ta.t_qc_idseq = MOD.nci_idseq and
               mod.item_id = frm.c_item_id and mod.ver_nr = frm.c_item_ver_nr;

    COMMIT;

    INSERT INTO NCI_FORM_TA_REL (TA_ID,
                                 NCI_PUB_ID,
                                 NCI_VER_NR,
                                 CREAT_DT,
                                 CREAT_USR_ID,
                                 LST_UPD_USR_ID,
                                 LST_UPD_DT)
        SELECT ta.ta_id,
               ai.item_id,
               ai.ver_nr,
               nvl(t.date_created,v_dflt_date) ,
          nvl(t.created_by,v_dflt_usr),
               nvl(t.modified_by,v_dflt_usr),
             nvl(NVL (t.date_modified, t.date_created), v_dflt_date)
          FROM nci_form_ta ta, sbrext_m.ta_proto_csi_ext t, admin_item ai
         WHERE     ta.ta_idseq = t.ta_idseq
               AND t.proto_idseq = ai.nci_idseq
               AND t.proto_idseq IS NOT NULL;

    COMMIT;
END;

 PROCEDURE            sp_create_form_vv_inst
AS
    v_cnt   INTEGER;
BEGIN
    DELETE FROM NCI_QUEST_VALID_VALUE;

    COMMIT;

    INSERT INTO NCI_QUEST_VALID_VALUE (NCI_PUB_ID,
                                       Q_PUB_ID,
                                       Q_VER_NR,
                                       VM_NM,
                                       VM_DEF,
                                       VALUE,
                                       NCI_IDSEQ,
                                       DESC_TXT,
                                       MEAN_TXT,
                                       VAL_MEAN_ITEM_ID,
                                       VAL_MEAN_VER_NR,
                                       CREAT_USR_ID,
                                       CREAT_DT,
                                       LST_UPD_DT,
                                       LST_UPD_USR_ID, DISP_ORD)
        SELECT qc.qc_id,
               qc1.qc_id,
               qc1.VERSION,
               qc.preferred_name,
               qc.preferred_definition,
               qc.long_name,
               qc.qc_idseq,
               vv.description_text,
               vv.meaning_text,
               vm.vm_id,
               vm.version,
          nvl(qc.created_by,v_dflt_usr),
               nvl(qc.date_created,v_dflt_date) ,
             nvl(NVL (qc.date_modified, qc.date_created), v_dflt_date),
               nvl(qc.modified_by,v_dflt_usr), qc.DISPLAY_ORDER
                       FROM sbrext_m.quest_contents_ext    qc,
               sbrext_m.quest_contents_ext    qc1,
               sbrext_m.valid_values_att_ext  vv,
               sbrext_m.vd_pvs  vp,
                sbrext_m.permissible_Values pv,
                sbrext_m.value_meanings vm
         WHERE     qc.qtl_name = 'VALID_VALUE'
               AND qc1.qtl_name = 'QUESTION'
               AND qc1.qc_idseq = qc.p_qst_idseq
               AND qc.qc_idseq = vv.qc_idseq(+)
                and vp.pv_idseq = pv.pv_idseq (+) and pv.vm_idseq = vm.vm_idseq (+)
                and qc.vp_idseq = vp.vp_idseq (+);

    COMMIT;

    -- Added for enumerated valid values. Has to be here as Question VV is inserted here.
      update nci_admin_item_rel_alt_key q set deflt_val_id = (Select nci_pub_id from nci_quest_valid_value vv,
    (select * from  sbrext_m.QUEST_ATTRIBUTES_EXT where vv_idseq is not null) qa where q.nci_idseq = qa.qc_idseq and qa.vv_idseq = vv.nci_idseq and qa.vv_idseq is not null)
    where q.nci_idseq in (select qc_idseq from (select * from  sbrext_m.QUEST_ATTRIBUTES_EXT where vv_idseq is not null) temp1);

    commit;

    DELETE FROM NCI_QUEST_VV_REP;

    COMMIT;

    -- Changed as per tracker 863
    --added CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, LST_UPD_DT

    INSERT INTO NCI_QUEST_VV_REP (QUEST_PUB_ID,
                                  QUEST_VER_NR,
                                  VV_PUB_ID,
                                  VV_VER_NR,
                                  VAL,
                                  EDIT_IND,
                                  REP_SEQ,
                                  DEFLT_VAL_ID
								  /*,
								  CREAT_USR_ID,
								  CREAT_DT,
                                  LST_UPD_USR_ID,
                                  LST_UPD_DT*/)
        SELECT distinct q.NCI_PUB_ID,
               q.NCI_VER_NR,
               vv.NCI_PUB_ID,
               vv.NCI_VER_NR,
               qvv.VALUE,
               DECODE (editable_ind,  'Yes', 1,  'No', 0),
               repeat_sequence,
               vv.nci_pub_id
			/*   ,
			   nvl(qvv.created_by,v_dflt_usr),
               nvl(qvv.date_created,v_dflt_date) ,
			   nvl(qvv.modified_by,v_dflt_usr),
               nvl(NVL (qvv.date_modified, date_created), v_dflt_date)*/

          FROM sbrext_m.quest_vv_ext         qvv,
               NCI_ADMIN_ITEM_REL_ALT_KEY  q,
               NCI_QUEST_VALID_VALUE       vv
         WHERE     qvv.quest_idseq = q.NCI_IDSEQ
               AND qvv.vv_idseq = vv.NCI_IDSEQ(+);




    COMMIT;


END;

 procedure            sp_create_form_vv_inst_2
as
v_cnt integer;
begin

delete from nci_instr;
commit;

insert into NCI_INSTR
(NCI_PUB_ID, NCI_LVL, NCI_TYP, NCI_VER_NR, SEQ_NR,INSTR_LNG, INSTR_SHRT, INSTR_DEF,
CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID)
select ai.item_id, 'FORM', 'INSTRUCTION',ai.VER_NR, display_order, qc.LONG_NAME,qc.preferred_name, qc.preferred_definition,
    nvl(qc.created_by,v_dflt_usr),
               nvl(qc.date_created,v_dflt_date) ,
             nvl(NVL (qc.date_modified, qc.date_created), v_dflt_date),
               nvl(qc.modified_by,v_dflt_usr)
from sbrext_m.quest_contents_ext qc, admin_item ai where qc.qtl_name = 'FORM_INSTR' and
qc.dn_crf_idseq = ai.nci_idseq;

commit;


insert into NCI_INSTR
(NCI_PUB_ID, NCI_LVL, NCI_TYP, NCI_VER_NR, SEQ_NR,INSTR_LNG, INSTR_SHRT, INSTR_DEF,
CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID)
select ai.item_id, 'FORM', 'FOOTER',ai.VER_NR, display_order, qc.LONG_NAME,qc.preferred_name, qc.preferred_definition,
    nvl(qc.created_by,v_dflt_usr),
               nvl(qc.date_created,v_dflt_date) ,
             nvl(NVL (qc.date_modified, qc.date_created), v_dflt_date),
               nvl(qc.modified_by,v_dflt_usr)
        from sbrext_m.quest_contents_ext qc, admin_item ai where qc.qtl_name = 'FOOTER' and
qc.dn_crf_idseq = ai.nci_idseq;

commit;

insert into NCI_INSTR
(NCI_PUB_ID, NCI_LVL, NCI_TYP, NCI_VER_NR, SEQ_NR,INSTR_LNG, INSTR_SHRT, INSTR_DEF,
CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID)
select ai.item_id, 'MODULE', 'INSTRUCTION',ai.VER_NR, display_order, qc.LONG_NAME,qc.preferred_name, qc.preferred_definition,
    nvl(qc.created_by,v_dflt_usr),
               nvl(qc.date_created,v_dflt_date) ,
             nvl(NVL (qc.date_modified, qc.date_created), v_dflt_date),
               nvl(qc.modified_by,v_dflt_usr)
        from sbrext_m.quest_contents_ext qc, admin_item ai where qc.qtl_name = 'MODULE_INSTR' and
qc.p_mod_idseq = ai.nci_idseq;

commit;

insert into NCI_INSTR
(NCI_PUB_ID, NCI_LVL, NCI_TYP, NCI_VER_NR, SEQ_NR,INSTR_LNG, INSTR_SHRT, INSTR_DEF,
CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID)
select ai.nci_pub_id, 'QUESTION', 'INSTRUCTION',ai.NCI_VER_NR, display_order, qc.LONG_NAME,qc.preferred_name, qc.preferred_definition,
    nvl(qc.created_by,v_dflt_usr),
               nvl(qc.date_created,v_dflt_date) ,
             nvl(NVL (qc.date_modified, qc.date_created), v_dflt_date),
               nvl(qc.modified_by,v_dflt_usr)
        from sbrext_m.quest_contents_ext qc, Nci_admin_item_rel_alt_key ai where qc.qtl_name = 'QUESTION_INSTR' and ai.rel_typ_id = 63 and
qc.p_qst_idseq = ai.nci_idseq;

commit;


insert into NCI_INSTR
(NCI_PUB_ID, NCI_LVL, nci_ver_nr, SEQ_NR,INSTR_LNG, INSTR_SHRT, INSTR_DEF, NCI_TYP, CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID)
select ai.nci_pub_id, 'VALUE',1, display_order, qc.LONG_NAME,qc.preferred_name, qc.preferred_definition, 'INSTRUCTION',
    nvl(qc.created_by,v_dflt_usr),
               nvl(qc.date_created,v_dflt_date) ,
             nvl(NVL (qc.date_modified, qc.date_created), v_dflt_date),
               nvl(qc.modified_by,v_dflt_usr)
        from sbrext_m.quest_contents_ext qc, Nci_QUEST_VALID_VALUE ai where qc.qtl_name = 'VALUE_INSTR' and
qc.p_val_idseq = ai.nci_idseq ;
commit;

/*
insert into NCI_QUEST_VALID_VALUE
(NCI_PUB_ID, Q_PUB_ID, QVV_VM_NM, QVV_VM_LNM, QVV_VALUE, QVV_CMNTS, QVV_EDIT_IND, QVV_SEQ_NBR)
select qc.qc_id, qc1.qc_id, qc.preferred_name, qc.preferred_definition
from  sbrext_m.quest_contents_ext qc, sbrext_m.quest_contents_ext qc1
where qc.qtl_name = 'VALID_VALUE' and and qc1.qtl_name = 'QUESTION' and qc1.qc_idseq = qc.p_qst_idseq;

*/

end;

 procedure            sp_create_form_vv_inst_new
as
v_cnt integer;
begin


update nci_form f set HDR_INSTR = (select qc.preferred_definition from sbrext_m.quest_contents_ext qc, admin_item ai where qc.qtl_name = 'FORM_INSTR' and
ai.item_id = f.item_id and ai.ver_nr = f.ver_nr and ai.nci_idseq = qc.dn_crf_idseq and qc.qc_id in
(select min(qc_id)  from sbrext_m.quest_contents_ext qc1 where qc1.qtl_name = 'FORM_INSTR' group by dn_crf_idseq));
commit;

update nci_form f set FTR_INSTR = (select qc.preferred_definition from sbrext_m.quest_contents_ext qc, admin_item ai where qc.qtl_name = 'FOOTER' and
ai.item_id = f.item_id and ai.ver_nr = f.ver_nr and ai.nci_idseq = qc.dn_crf_idseq and qc.qc_id in
(select min(qc_id)  from sbrext_m.quest_contents_ext qc1 where qc1.qtl_name = 'FOOTER' group by dn_crf_idseq));
commit;


delete from temp_import;
commit;

insert into temp_import (ITEM_ID, VER_NR, QC_ID, PREFERRED_DEFINITION, REP_NO) select  ai.item_id, ai.ver_nr,qc_id, qc.preferred_definition, display_order  from sbrext_m.quest_contents_ext qc, admin_item ai
where qc.qtl_name = 'MODULE_INSTR' and ai.nci_idseq = qc.p_mod_idseq and (qc.p_mod_idseq, display_order) in (select p_mod_idseq, min(display_order)
from sbrext_m.quest_contents_ext qc1 where qc1.qtl_name = 'MODULE_INSTR' group by p_mod_idseq);
commit;

delete from temp_import t1 where (qc_id) not in (select min(qc_id)from temp_import group by item_id, ver_nr);
commit;



update nci_admin_item_rel m set INSTR = (select preferred_definition from temp_import t where
t.item_id = m.c_item_id and t.ver_nr = m.c_item_ver_nr )
where m.rel_typ_id = 61;
commit;


delete from temp_import;
commit;

insert into temp_import (ITEM_ID, VER_NR, qc_id, PREFERRED_DEFINITION) select  ai.nci_pub_id, ai.nci_ver_nr,qc.qc_id, qc.preferred_definition  from sbrext_m.quest_contents_ext qc, nci_admin_item_rel_alt_key ai
where qc.qtl_name = 'QUESTION_INSTR' and ai.nci_idseq = qc.p_qst_idseq and (qc.p_qst_idseq, display_order) in (select p_qst_idseq, min(display_order)
 from sbrext_m.quest_contents_ext qc1 where qc1.qtl_name = 'QUESTION_INSTR' group by p_qst_idseq);
commit;

delete from temp_import t1 where (qc_id) not in (select min(qc_id)from temp_import group by item_id, ver_nr);
commit;

update nci_admin_item_rel_alt_key m set INSTR = (select preferred_definition from temp_import t where
t.item_id = m.nci_pub_id and t.ver_nr = m.nci_ver_nr )
where m.rel_typ_id = 63;
commit;



delete from temp_import;
commit;

insert into temp_import (ITEM_ID, VER_NR, qc_id, PREFERRED_DEFINITION) select  ai.nci_pub_id, ai.nci_ver_nr,qc.qc_id,qc.preferred_definition  from sbrext_m.quest_contents_ext qc, nci_quest_valid_value ai
where qc.qtl_name = 'VALUE_INSTR' and ai.nci_idseq = qc.p_val_idseq and  (qc.p_val_idseq, display_order) in (select p_val_idseq, min(display_order)
 from sbrext_m.quest_contents_ext qc1 where qc1.qtl_name = 'VALUE_INSTR' group by p_val_idseq);
commit;


delete from temp_import t1 where (qc_id) not in (select min(qc_id)from temp_import group by item_id, ver_nr);
commit;

update nci_quest_valid_value m set INSTR = (select preferred_definition from temp_import t where
t.item_id = m.nci_pub_id and t.ver_nr = m.nci_ver_nr );
commit;




end;

PROCEDURE            sp_create_pv
AS
    v_cnt   INTEGER;
BEGIN
    DELETE FROM nci_val_mean;

    COMMIT;

    -- Value Meaning
    DELETE FROM admin_item
          WHERE admin_item_typ_id = 53;

    COMMIT;


    -- Value Meaning as AI
    INSERT INTO admin_item (NCI_IDSEQ,
                            ADMIN_ITEM_TYP_ID,
                            ADMIN_STUS_ID,
                            ADMIN_STUS_NM_DN,
                            EFF_DT,
                            CHNG_DESC_TXT,
                            CNTXT_ITEM_ID,
                            CNTXT_VER_NR,
                            CNTXT_NM_DN,
                            UNTL_DT,
                            CURRNT_VER_IND,
                            ITEM_LONG_NM,
                            ORIGIN,
                            ITEM_DESC,
                            ITEM_ID,
                            ITEM_NM,
                            --STEWRD_ORG_ID
                            VER_NR,
                            CREAT_USR_ID,
                            CREAT_DT,
                            LST_UPD_DT,
                            LST_UPD_USR_ID,
                            DEF_SRC)
        SELECT ac.vm_idseq,
               53,
               s.stus_id,
               s.nci_stus,
               ac.begin_date,
               ac.change_note,
               --conte_idseq,
               cntxt.item_id,
               cntxt.ver_nr,
               cntxt.item_nm,
               ac.end_date,
               DECODE (UPPER (ac.latest_version_ind),  'YES', 1,  'NO', 0),
               ac.preferred_name,
               ac.origin,
               ac.preferred_definition,
               ac.vm_id,
               NVL (ac.long_name, ac.preferred_name),
               --stewa_idseq,
               ac.version,
                  nvl(ac.created_by,v_dflt_usr),
               nvl(ac.date_created,v_dflt_date) ,
               nvl(NVL (ac.date_modified, ac.date_created), v_dflt_date),
               nvl(ac.modified_by,v_dflt_usr),
               ac.definition_source
          FROM admin_item cntxt, stus_mstr s, sbr_m.value_meanings ac
         WHERE     ac.conte_idseq = cntxt.nci_idseq
               AND TRIM (ac.asl_name) = TRIM (s.nci_STUS)
               AND --ac.end_date is null and
                   cntxt.admin_item_typ_id = 8;

    COMMIT;


    INSERT INTO NCI_VAL_MEAN (item_id,
                              ver_nr,
                              VM_DESC_TXT,
                              VM_CMNTS,
                              CREAT_USR_ID,
                              CREAT_DT,
                              LST_UPD_DT,
                              LST_UPD_USR_ID)
        SELECT ai.item_id,
               ai.ver_nr,
               description,
               comments,
                nvl(cd.created_by,v_dflt_usr),
               nvl(cd.date_created,v_dflt_date) ,
               nvl(NVL (cd.date_modified, cd.date_created), v_dflt_date),
               nvl(cd.modified_by,v_dflt_usr)
        FROM sbr_m.value_meanings cd, admin_item ai
         WHERE ai.NCI_IDSEQ = cd.VM_IDSEQ;

    COMMIT;
END;

 PROCEDURE            sp_create_pv_2
AS
    v_cnt   INTEGER;
BEGIN
    DELETE FROM perm_val;

    COMMIT;

    DELETE FROM conc_dom_val_mean;

    COMMIT;

    -- Value Meaning - Conceptual Domain relationship
    INSERT INTO conc_dom_val_mean (conc_dom_item_id,
                                   conc_dom_ver_nr,
                                   nci_val_mean_item_id,
                                   nci_val_mean_ver_nr,
                                   CREAT_USR_ID,
                                   CREAT_DT,
                                   LST_UPD_DT,
                                   LST_UPD_USR_ID)
        SELECT cd.item_id,
               cd.ver_nr,
               vm.item_id,
               vm.ver_nr,
                          nvl(cvm.created_by,v_dflt_usr),
               nvl(cvm.date_created,v_dflt_date) ,
               nvl(NVL (cvm.date_modified, cvm.date_created), v_dflt_date),
               nvl(cvm.modified_by,v_dflt_usr)
          FROM admin_item cd, admin_item vm, sbr_m.cd_vms cvm
         WHERE cvm.cd_idseq = cd.nci_idseq AND cvm.vm_idseq = vm.nci_idseq;

    COMMIT;

    -- Permissible Values

    INSERT INTO perm_val (PERM_VAL_BEG_DT,
                          PERM_VAL_END_DT,
                          PERM_VAL_NM,
                          PERM_VAL_DESC_TXT,
                          VAL_DOM_ITEM_ID,
                          VAL_DOM_VER_NR,
                          CREAT_DT,
                          CREAT_USR_ID,
                          LST_UPD_DT,
                          LST_UPD_USR_ID,
                          NCI_VAL_MEAN_ITEM_ID,
                          NCI_VAL_MEAN_VER_NR,
                          NCI_IDSEQ, NCI_ORIGIN_ID, NCI_ORIGIN)
        SELECT pvs.BEGIN_DATE,
               pvs.END_DATE,
               VALUE,
               SHORT_MEANING,
               vd.item_id,
               vd.ver_nr,
               --MEANING_DESCRIPTION,  HIGH_VALUE_NUM, LOW_VALUE_NUM,
               nvl(pvs.date_created,v_dflt_date) ,
                             nvl(pvs.created_by,v_dflt_usr),
               nvl(NVL (pvs.date_modified, pvs.date_created), v_dflt_date),
               nvl(pvs.modified_by,v_dflt_usr),
               vm.item_id,
               vm.ver_nr,
               pvs.vp_idseq,
               ok.OBJ_KEY_ID,
               decode(ok.obj_key_id, null,pvs.origin, null)
          FROM sbr_m.permissible_Values  pv,
               admin_item              vm,
               admin_item              vd,
               sbr_m.vd_pvs              pvs,
               obj_key  ok
         WHERE     pv.pv_idseq = pvs.pv_idseq
               AND pvs.vd_idseq = vd.nci_idseq
               AND pv.vm_idseq = vm.nci_idseq
      and ok.obj_typ_id (+)= 18
               and pvs.origin =  ok.nci_cd (+) ;

    COMMIT;

END;

 procedure            sp_migrate_change_log
as
v_cnt integer;
begin

for cur in (select ac_idseq from sbr_m.administered_components) loop
insert /*+ APPEND */ into nci_change_history (ACCH_IDSEQ,
AC_IDSEQ,CHANGE_DATETIMESTAMP,CHANGE_ACTION,CHANGED_BY,
CHANGED_TABLE,CHANGED_TABLE_IDSEQ,CHANGED_COLUMN,OLD_VALUE,NEW_VALUE)
select ACCH_IDSEQ,
AC_IDSEQ,CHANGE_DATETIMESTAMP,CHANGE_ACTION,CHANGED_BY,
CHANGED_TABLE,CHANGED_TABLE_IDSEQ,CHANGED_COLUMN,OLD_VALUE,NEW_VALUE
from sbrext_m.AC_CHANGE_HISTORY_EXT
where ac_idseq = cur.ac_idseq;
commit;
end loop;
end;

 procedure sp_org_contact
as
v_cnt integer;
begin


insert into nci_entty(NCI_IDSEQ, ENTTY_TYP_ID,CREAT_USR_ID,CREAT_DT,LST_UPD_USR_ID,LST_UPD_DT)
 select org_idseq, 72,
 nvl(created_by,v_dflt_usr),
                nvl(date_created,v_dflt_date) ,
               nvl(modified_by,v_dflt_usr),
             nvl(NVL (date_modified, date_created), v_dflt_date)
from sbr_m.organizations;
commit;

insert into nci_org (ENTTY_ID, RAI,ORG_NM,RA_IND,MAIL_ADDR,CREAT_USR_ID,CREAT_DT,LST_UPD_USR_ID,LST_UPD_DT)
select e.ENTTY_ID, RAI,NAME,RA_IND,MAIL_ADDRESS,
nvl(created_by,v_dflt_usr),
                nvl(date_created,v_dflt_date) ,
               nvl(modified_by,v_dflt_usr),
             nvl(NVL (date_modified, date_created), v_dflt_date)
from sbr_m.organizations o, nci_entty e where e.nci_idseq = o.org_idseq;
commit;

insert into nci_entty(NCI_IDSEQ, ENTTY_TYP_ID,CREAT_USR_ID,CREAT_DT,LST_UPD_USR_ID,LST_UPD_DT)
 select per_idseq, 73,
 nvl(created_by,v_dflt_usr),
                nvl(date_created,v_dflt_date) ,
               nvl(modified_by,v_dflt_usr),
             nvl(NVL (date_modified, date_created), v_dflt_date)
from sbr_m.persons;
commit;


insert into nci_prsn(ENTTY_ID,LAST_NM,FIRST_NM,RNK_ORD,PRNT_ORG_ID,MI,POS,
 CREAT_USR_ID,CREAT_DT,LST_UPD_USR_ID,LST_UPD_DT)
 select e.entty_id, LNAME,FNAME,RANK_ORDER,o.entty_id,MI,POSITION,
nvl(created_by,v_dflt_usr),
                nvl(date_created,v_dflt_date) ,
               nvl(modified_by,v_dflt_usr),
             nvl(NVL (date_modified, date_created), v_dflt_date)
 from sbr_m.persons p, nci_entty e, nci_entty o where e.entty_typ_id = 73 and o.entty_typ_id (+)= 72 and e.nci_idseq = p.per_idseq and p.org_idseq = o.nci_idseq (+)  ;
commit;

insert into nci_entty_comm (ENTTY_ID,COMM_TYP_ID,RNK_ORD,CYB_ADDR,CREAT_DT,CREAT_USR_ID,LST_UPD_DT,LST_UPD_USR_ID)
select o.entty_id, ok.obj_key_id, RANK_ORDER,CYBER_ADDRESS,
               nvl(date_created,v_dflt_date) ,
nvl(created_by,v_dflt_usr),
             nvl(NVL (date_modified, date_created), v_dflt_date),
               nvl(modified_by,v_dflt_usr)
from sbr_m.CONTACT_COMMS c, obj_key ok, nci_entty o where
ORG_IDSEQ is not null and c.org_idseq = o.nci_idseq and ok.nci_cd = CTL_NAME and ok.obj_typ_id = 26;
commit;

insert into nci_entty_comm (ENTTY_ID,COMM_TYP_ID,RNK_ORD,CYB_ADDR,CREAT_DT,CREAT_USR_ID,LST_UPD_DT,LST_UPD_USR_ID)
select o.entty_id, ok.obj_key_id, RANK_ORDER,CYBER_ADDRESS,
               nvl(date_created,v_dflt_date) ,
nvl(created_by,v_dflt_usr),
             nvl(NVL (date_modified, date_created), v_dflt_date),
               nvl(modified_by,v_dflt_usr)
from sbr_m.CONTACT_COMMS c, obj_key ok, nci_entty o where
per_IDSEQ is not null and c.per_idseq = o.nci_idseq and ok.nci_cd = CTL_NAME and ok.obj_typ_id = 26 ;
commit;


insert into nci_entty_addr (ENTTY_ID,ADDR_TYP_ID,RNK_ORD,ADDR_LINE1,ADDR_LINE2,CITY,STATE_PROV,POSTAL_CD,CNTRY,
CREAT_DT,CREAT_USR_ID,LST_UPD_DT,LST_UPD_USR_ID)
select o.entty_id, ok.obj_key_id, RANK_ORDER,ADDR_LINE1,ADDR_LINE2,CITY,STATE_PROV,POSTAL_CODE,COUNTRY,
               nvl(date_created,v_dflt_date) ,
nvl(created_by,v_dflt_usr),
             nvl(NVL (date_modified, date_created), v_dflt_date),
               nvl(modified_by,v_dflt_usr)
from sbr_m.CONTACT_ADDRESSES c, obj_key ok, nci_entty o where
ORG_IDSEQ is not null and c.org_idseq = o.nci_idseq and ok.nci_cd = ATL_NAME and ok.obj_typ_id = 25;
commit;


insert into nci_entty_addr (ENTTY_ID,ADDR_TYP_ID,RNK_ORD,ADDR_LINE1,ADDR_LINE2,CITY,STATE_PROV,POSTAL_CD,CNTRY,
CREAT_DT,CREAT_USR_ID,LST_UPD_DT,LST_UPD_USR_ID)
select o.entty_id, ok.obj_key_id, RANK_ORDER,ADDR_LINE1,ADDR_LINE2,CITY,STATE_PROV,POSTAL_CODE,COUNTRY,
               nvl(date_created,v_dflt_date) ,
nvl(created_by,v_dflt_usr),
             nvl(NVL (date_modified, date_created), v_dflt_date),
               nvl(modified_by,v_dflt_usr)
    from sbr_m.CONTACT_ADDRESSES c, obj_key ok, nci_entty o where
PER_IDSEQ is not null and c.per_idseq = o.nci_idseq and ok.nci_cd = ATL_NAME and ok.obj_typ_id = 25;
commit;


end;


 procedure sp_post_upd
as
v_cnt integer;
begin
update admin_item set (REGSTR_STUS_ID, REGSTR_STUS_NM_DN) =
(select s.stus_id, s.NCI_STUS
from sbr_m.ac_registrations ar, stus_mstr s where
upper(ar.REGISTRATION_STATUS) = upper(s.stus_nm) and ar.ac_idseq = admin_item.nci_idseq
and ar.registration_status is not null);
commit;

--update admin_item set REGSTR_STUS_ID = 10, REGSTR_STUS_NM_DN = 'Historical' where REGSTR_STUS_ID is null;
--commit;

update admin_item set (ORIGIN_ID, ORIGIN_ID_DN) =
(Select obj_key_id, obj_key_desc from obj_key ok, sbr_m.administered_components ac where ac.public_id = admin_item.item_id
and admin_item.ver_nr = ac.version and ac.origin = ok.obj_key_desc and ok.obj_typ_id = 18);
commit;

update admin_item set (ORIGIN) =
(Select origin from sbr_m.administered_components ac where ac.public_id = admin_item.item_id
and admin_item.ver_nr = ac.version and origin not in (select obj_key_desc from obj_key where obj_typ_id = 18));
commit;

update perm_val set (PRNT_CNCPT_ITEM_ID, PRNT_CNCPT_VER_NR) = (
select
public_id, version from sbr_m.administered_components ac, sbr_m.vd_pvs pvs, admin_item vd where pvs.pv_idseq = perm_val.nci_idseq and ac.ac_idseq = pvs.con_idseq and
pvs.con_idseq is not null and vd.nci_idseq = pvs.vd_idseq and vd.item_id = perm_val.val_dom_item_id and vd.ver_nr = perm_val.val_dom_ver_nr)
where nci_idseq in (select pv_idseq from sbr_m.vd_pvs where con_idseq is not null);
commit;


update admin_item ai set submt_org_id = (select distinct entty_id from nci_entty e, sbr_m.ac_contacts a where e.nci_idseq = a.org_idseq and a.org_idseq is not null
and ai.nci_idseq = a.ac_idseq and rank_order = 1)
where nci_idseq in (select ac_idseq from sbr_m.ac_contacts where org_idseq is not null and rank_order = 1);
commit;


update admin_item ai set stewrd_org_id = (select entty_id from nci_entty e, sbr_m.ac_contacts a where e.nci_idseq = a.org_idseq and a.org_idseq is not null
and ai.nci_idseq = a.ac_idseq and rank_order = 2)
where nci_idseq in (select ac_idseq from sbr_m.ac_contacts where org_idseq is not null and rank_order = 2);
commit;

update admin_item ai set submt_cntct_id = (select entty_id from nci_entty e, sbr_m.ac_contacts a where e.nci_idseq = a.per_idseq and a.per_idseq is not null
and ai.nci_idseq = a.ac_idseq and rank_order = 2)
where nci_idseq in (select ac_idseq from sbr_m.ac_contacts where per_idseq is not null and rank_order = 2);
commit;


update admin_item ai set stewrd_cntct_id = (select entty_id from nci_entty e, sbr_m.ac_contacts a where e.nci_idseq = a.per_idseq and a.per_idseq is not null
and ai.nci_idseq = a.ac_idseq and rank_order = 1)
where nci_idseq in (select ac_idseq from sbr_m.ac_contacts where per_idseq is not null and rank_order = 1);
commit;

insert into ref_doc (NCI_REF_ID,FILE_NM,NCI_MIME_TYPE,NCI_DOC_SIZE,
NCI_CHARSET,NCI_DOC_LST_UPD_DT,BLOB_COL,
CREAT_USR_ID,CREAT_DT,LST_UPD_USR_ID,LST_UPD_DT)
select r.ref_id, rb.NAME,MIME_TYPE,DOC_SIZE,
DAD_CHARSET,LAST_UPDATED,BLOB_CONTENT,
    nvl(created_by,v_dflt_usr),
               nvl(date_created,v_dflt_date) ,
               nvl(modified_by,v_dflt_usr),
             nvl(NVL (date_modified, date_created), v_dflt_date)
        from ref r, sbr_m.reference_blobs rb where r.nci_idseq = rb.rd_idseq;
commit;

update admin_item set creat_usr_id_x = creat_usr_id where creat_usr_id in (select cntct_secu_id from cntct);
commit;
update admin_item set lst_upd_usr_id_x = lst_upd_usr_id where lst_upd_usr_id in (select cntct_secu_id from cntct);
 commit;



--update admin_item set regstr_stus_id = 9 where regstr_stus_id is null; -- Tracker 806
--commit;

/* Tracker 950
APPRVD FOR TRIAL USE	APPLICATION
DRAFT MOD	APPLICATION
DRAFT NEW	APPLICATION
RELEASED	APPLICATION
RELEASED-NON-CMPLNT	INCOMPLETE
RETIRED ARCHIVED	RETIRED
RETIRED DELETED	RETIRED
RETIRED PHASED OUT	RETIRED
RETIRED WITHDRAWN	RETIRED
*/
update admin_item set regstr_stus_id = 11, regstr_stus_nm_dn = 'RETIRED' where regstr_stus_id is null and admin_stus_id in (77,78,79,81);
commit;

update admin_item set regstr_stus_id = 6, regstr_stus_nm_dn = 'INCOMPLETE' where regstr_stus_id is null and admin_stus_id in (76);
commit;


update admin_item set regstr_stus_id = 9, regstr_stus_nm_dn = 'APPLICATION' where regstr_stus_id is null; -- Tracker 806
commit;
end;
 function get_stus_mstr_id (STATUS_NAME VARCHAR2, STATUS_TYPE_ID number) return number is
v_status_id number;
v_status_name stus_mstr.STUS_NM%TYPE;
v_status_max_id number;
v_status_type_id number;
BEGIN
v_status_type_id := STATUS_TYPE_ID;
v_status_name := STATUS_NAME;

select max(STUS_ID) into v_status_max_id from stus_mstr;
BEGIN
select STUS_ID into v_status_id
from stus_mstr where STUS_NM = v_status_name and STUS_TYP_ID = v_status_type_id;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
	v_status_id := v_status_max_id + 1;
END;

RETURN v_status_id;
END;

function is_stus_mstr_exist (STATUS_NAME VARCHAR2, STATUS_TYPE_ID number) return varchar2 is
v_status_id number;
v_status_name stus_mstr.STUS_NM%TYPE;
v_found varchar2(5);
v_status_type_id number;
--RETURN varchar2 'TRUE' if a status is found, and 'FALSE' if not
BEGIN
v_status_type_id := STATUS_TYPE_ID;
v_status_name := STATUS_NAME;
v_found := 'TRUE';

BEGIN
select STUS_ID into v_status_id
from stus_mstr where STUS_NM = v_status_name and STUS_TYP_ID = v_status_type_id;
EXCEPTION
	WHEN NO_DATA_FOUND THEN
	v_found := 'FALSE';
END;

RETURN v_found;
END;
procedure SP_SOURCE_TYPE as
BEGIN
--SQL Statement which produced this data:
--
--  select*from OBJ_KEY where obj_typ_id=23;
--
Insert into OBJ_KEY
   (OBJ_KEY_ID, OBJ_KEY_DESC, OBJ_TYP_ID, OBJ_KEY_CD, OBJ_KEY_DEF,
    CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE, LST_DEL_DT,
    S2P_TRN_DT, LST_UPD_DT, OBJ_KEY_CMNTS, NCI_CD, DISP_ORD)
 Values
   (201, 'UMLS_CUI', 23, NULL, NULL,
    TO_DATE('10/6/2006 3:48:06 PM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBREXT', 'ONEDATA', 0, TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'),
    TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('10/6/2006 3:48:06 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, 'UMLS_CUI', NULL);
Insert into OBJ_KEY
   (OBJ_KEY_ID, OBJ_KEY_DESC, OBJ_TYP_ID, OBJ_KEY_CD, OBJ_KEY_DEF,
    CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE, LST_DEL_DT,
    S2P_TRN_DT, LST_UPD_DT, OBJ_KEY_CMNTS, NCI_CD, DISP_ORD)
 Values
   (202, 'UWD_VA_CODE', 23, NULL, NULL,
    TO_DATE('10/6/2006 3:48:06 PM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBREXT', 'ONEDATA', 0, TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'),
    TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('10/6/2006 3:48:06 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, 'UWD_VA_CODE', NULL);
Insert into OBJ_KEY
   (OBJ_KEY_ID, OBJ_KEY_DESC, OBJ_TYP_ID, OBJ_KEY_CD, OBJ_KEY_DEF,
    CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE, LST_DEL_DT,
    S2P_TRN_DT, LST_UPD_DT, OBJ_KEY_CMNTS, NCI_CD, DISP_ORD)
 Values
   (203, 'VA_NDF_CODE', 23, NULL, NULL,
    TO_DATE('10/6/2006 3:48:06 PM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBREXT', 'ONEDATA', 0, TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'),
    TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('10/6/2006 3:48:06 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, 'VA_NDF_CODE', NULL);
Insert into OBJ_KEY
   (OBJ_KEY_ID, OBJ_KEY_DESC, OBJ_TYP_ID, OBJ_KEY_CD, OBJ_KEY_DEF,
    CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE, LST_DEL_DT,
    S2P_TRN_DT, LST_UPD_DT, OBJ_KEY_CMNTS, NCI_CD, DISP_ORD)
 Values
   (204, 'ZEBRAFISH_CODE', 23, NULL, NULL,
    TO_DATE('8/18/2020', 'MM/DD/YYYY'), 'ONEDATA', 'ONEDATA', 0, TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'),
    TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('8/18/2020', 'MM/DD/YYYY'), NULL, 'ZEBRAFISH_CODE', NULL);
Insert into OBJ_KEY
   (OBJ_KEY_ID, OBJ_KEY_DESC, OBJ_TYP_ID, OBJ_KEY_CD, OBJ_KEY_DEF,
    CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE, LST_DEL_DT,
    S2P_TRN_DT, LST_UPD_DT, OBJ_KEY_CMNTS, NCI_CD, DISP_ORD)
 Values
   (205, 'CTCAE_CODE', 23, NULL, NULL,
    TO_DATE('11/2/2011 9:19:34 AM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBREXT', 'ONEDATA', 0, TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'),
    TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('11/2/2011 9:19:34 AM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, 'CTCAE_CODE', NULL);
Insert into OBJ_KEY
   (OBJ_KEY_ID, OBJ_KEY_DESC, OBJ_TYP_ID, OBJ_KEY_CD, OBJ_KEY_DEF,
    CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE, LST_DEL_DT,
    S2P_TRN_DT, LST_UPD_DT, OBJ_KEY_CMNTS, NCI_CD, DISP_ORD)
 Values
   (206, 'HL7_CODE', 23, NULL, NULL,
    TO_DATE('11/2/2011 9:19:34 AM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBREXT', 'ONEDATA', 0, TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'),
    TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('11/2/2011 9:19:34 AM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, 'HL7_CODE', NULL);
Insert into OBJ_KEY
   (OBJ_KEY_ID, OBJ_KEY_DESC, OBJ_TYP_ID, OBJ_KEY_CD, OBJ_KEY_DEF,
    CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE, LST_DEL_DT,
    S2P_TRN_DT, LST_UPD_DT, OBJ_KEY_CMNTS, NCI_CD, DISP_ORD)
 Values
   (207, 'HUGO_CODE', 23, NULL, NULL,
    TO_DATE('11/2/2011 9:19:34 AM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBREXT', 'ONEDATA', 0, TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'),
    TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('11/2/2011 9:19:34 AM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, 'HUGO_CODE', NULL);
Insert into OBJ_KEY
   (OBJ_KEY_ID, OBJ_KEY_DESC, OBJ_TYP_ID, OBJ_KEY_CD, OBJ_KEY_DEF,
    CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE, LST_DEL_DT,
    S2P_TRN_DT, LST_UPD_DT, OBJ_KEY_CMNTS, NCI_CD, DISP_ORD)
 Values
   (208, 'ICD-10_CODE', 23, NULL, NULL,
    TO_DATE('11/2/2011 9:19:34 AM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBREXT', 'ONEDATA', 0, TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'),
    TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('11/2/2011 9:19:34 AM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, 'ICD-10_CODE', NULL);
Insert into OBJ_KEY
   (OBJ_KEY_ID, OBJ_KEY_DESC, OBJ_TYP_ID, OBJ_KEY_CD, OBJ_KEY_DEF,
    CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE, LST_DEL_DT,
    S2P_TRN_DT, LST_UPD_DT, OBJ_KEY_CMNTS, NCI_CD, DISP_ORD)
 Values
   (209, 'ICD-9_CM_CODE', 23, NULL, NULL,
    TO_DATE('11/2/2011 9:19:34 AM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBREXT', 'ONEDATA', 0, TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'),
    TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('11/2/2011 9:19:34 AM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, 'ICD-9_CM_CODE', NULL);
Insert into OBJ_KEY
   (OBJ_KEY_ID, OBJ_KEY_DESC, OBJ_TYP_ID, OBJ_KEY_CD, OBJ_KEY_DEF,
    CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE, LST_DEL_DT,
    S2P_TRN_DT, LST_UPD_DT, OBJ_KEY_CMNTS, NCI_CD, DISP_ORD)
 Values
   (210, 'IDC-10_CM_CODE', 23, NULL, NULL,
    TO_DATE('11/2/2011 9:19:34 AM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBREXT', 'ONEDATA', 0, TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'),
    TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('11/2/2011 9:19:34 AM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, 'IDC-10_CM_CODE', NULL);
Insert into OBJ_KEY
   (OBJ_KEY_ID, OBJ_KEY_DESC, OBJ_TYP_ID, OBJ_KEY_CD, OBJ_KEY_DEF,
    CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE, LST_DEL_DT,
    S2P_TRN_DT, LST_UPD_DT, OBJ_KEY_CMNTS, NCI_CD, DISP_ORD)
 Values
   (211, 'NPO_CODE', 23, NULL, NULL,
    TO_DATE('11/2/2011 9:19:34 AM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBREXT', 'ONEDATA', 0, TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'),
    TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('11/2/2011 9:19:34 AM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, 'NPO_CODE', NULL);
Insert into OBJ_KEY
   (OBJ_KEY_ID, OBJ_KEY_DESC, OBJ_TYP_ID, OBJ_KEY_CD, OBJ_KEY_DEF,
    CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE, LST_DEL_DT,
    S2P_TRN_DT, LST_UPD_DT, OBJ_KEY_CMNTS, NCI_CD, DISP_ORD)
 Values
   (212, 'OBI_CODE', 23, NULL, NULL,
    TO_DATE('11/2/2011 9:19:34 AM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBREXT', 'ONEDATA', 0, TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'),
    TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('11/2/2011 9:19:34 AM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, 'OBI_CODE', NULL);
Insert into OBJ_KEY
   (OBJ_KEY_ID, OBJ_KEY_DESC, OBJ_TYP_ID, OBJ_KEY_CD, OBJ_KEY_DEF,
    CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE, LST_DEL_DT,
    S2P_TRN_DT, LST_UPD_DT, OBJ_KEY_CMNTS, NCI_CD, DISP_ORD)
 Values
   (213, 'RADLEX_CODE', 23, NULL, NULL,
    TO_DATE('11/2/2011 9:19:34 AM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBREXT', 'ONEDATA', 0, TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'),
    TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('11/2/2011 9:19:34 AM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, 'RADLEX_CODE', NULL);
Insert into OBJ_KEY
   (OBJ_KEY_ID, OBJ_KEY_DESC, OBJ_TYP_ID, OBJ_KEY_CD, OBJ_KEY_DEF,
    CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE, LST_DEL_DT,
    S2P_TRN_DT, LST_UPD_DT, OBJ_KEY_CMNTS, NCI_CD, DISP_ORD)
 Values
   (214, 'UMLS_SEMNET_CODE', 23, NULL, NULL,
    TO_DATE('11/2/2011 9:19:34 AM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBREXT', 'ONEDATA', 0, TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'),
    TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('11/2/2011 9:19:34 AM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, 'UMLS_SEMNET_CODE', NULL);
Insert into OBJ_KEY
   (OBJ_KEY_ID, OBJ_KEY_DESC, OBJ_TYP_ID, OBJ_KEY_CD, OBJ_KEY_DEF,
    CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE, LST_DEL_DT,
    S2P_TRN_DT, LST_UPD_DT, OBJ_KEY_CMNTS, NCI_CD, DISP_ORD)
 Values
   (215, 'GO_CODE', 23, NULL, NULL,
    TO_DATE('10/6/2006 3:48:06 PM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBREXT', 'ONEDATA', 0, TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'),
    TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('10/6/2006 3:48:06 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, 'GO_CODE', NULL);
Insert into OBJ_KEY
   (OBJ_KEY_ID, OBJ_KEY_DESC, OBJ_TYP_ID, OBJ_KEY_CD, OBJ_KEY_DEF,
    CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE, LST_DEL_DT,
    S2P_TRN_DT, LST_UPD_DT, OBJ_KEY_CMNTS, NCI_CD, DISP_ORD)
 Values
   (216, 'LOINC_CODE', 23, NULL, NULL,
    TO_DATE('10/6/2006 3:48:06 PM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBREXT', 'ONEDATA', 0, TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'),
    TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('10/6/2006 3:48:06 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, 'LOINC_CODE', NULL);
Insert into OBJ_KEY
   (OBJ_KEY_ID, OBJ_KEY_DESC, OBJ_TYP_ID, OBJ_KEY_CD, OBJ_KEY_DEF,
    CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE, LST_DEL_DT,
    S2P_TRN_DT, LST_UPD_DT, OBJ_KEY_CMNTS, NCI_CD, DISP_ORD)
 Values
   (217, 'MEDDRA_CODE', 23, NULL, NULL,
    TO_DATE('10/6/2006 3:48:06 PM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBREXT', 'ONEDATA', 0, TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'),
    TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('10/6/2006 3:48:06 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, 'MEDDRA_CODE', NULL);
Insert into OBJ_KEY
   (OBJ_KEY_ID, OBJ_KEY_DESC, OBJ_TYP_ID, OBJ_KEY_CD, OBJ_KEY_DEF,
    CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE, LST_DEL_DT,
    S2P_TRN_DT, LST_UPD_DT, OBJ_KEY_CMNTS, NCI_CD, DISP_ORD)
 Values
   (218, 'NCI_CONCEPT_CODE', 23, NULL, NULL,
    TO_DATE('10/6/2006 3:48:06 PM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBREXT', 'ONEDATA', 0, TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'),
    TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('10/6/2006 3:48:06 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, 'NCI_CONCEPT_CODE', NULL);
Insert into OBJ_KEY
   (OBJ_KEY_ID, OBJ_KEY_DESC, OBJ_TYP_ID, OBJ_KEY_CD, OBJ_KEY_DEF,
    CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE, LST_DEL_DT,
    S2P_TRN_DT, LST_UPD_DT, OBJ_KEY_CMNTS, NCI_CD, DISP_ORD)
 Values
   (219, 'NCI_META_CUI', 23, NULL, NULL,
    TO_DATE('10/6/2006 3:48:06 PM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBREXT', 'ONEDATA', 0, TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'),
    TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('10/6/2006 3:48:06 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, 'NCI_META_CUI', NULL);
Insert into OBJ_KEY
   (OBJ_KEY_ID, OBJ_KEY_DESC, OBJ_TYP_ID, OBJ_KEY_CD, OBJ_KEY_DEF,
    CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE, LST_DEL_DT,
    S2P_TRN_DT, LST_UPD_DT, OBJ_KEY_CMNTS, NCI_CD, DISP_ORD)
 Values
   (220, 'NCI_MO_CODE', 23, NULL, NULL,
    TO_DATE('10/6/2006 3:48:06 PM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBREXT', 'ONEDATA', 0, TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'),
    TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('10/6/2006 3:48:06 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, 'NCI_MO_CODE', NULL);
Insert into OBJ_KEY
   (OBJ_KEY_ID, OBJ_KEY_DESC, OBJ_TYP_ID, OBJ_KEY_CD, OBJ_KEY_DEF,
    CREAT_DT, CREAT_USR_ID, LST_UPD_USR_ID, FLD_DELETE, LST_DEL_DT,
    S2P_TRN_DT, LST_UPD_DT, OBJ_KEY_CMNTS, NCI_CD, DISP_ORD)
 Values
   (221, 'SNOMED_CODE', 23, NULL, NULL,
    TO_DATE('10/6/2006 3:48:06 PM', 'MM/DD/YYYY HH:MI:SS AM'), 'SBREXT', 'ONEDATA', 0, TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'),
    TO_DATE('6/17/2021 12:49:10 PM', 'MM/DD/YYYY HH:MI:SS AM'), TO_DATE('10/6/2006 3:48:06 PM', 'MM/DD/YYYY HH:MI:SS AM'), NULL, 'SNOMED_CODE', NULL);
COMMIT;

END;
END;
/


DROP PACKAGE BODY ONEDATA_WA.NCI_CADSR_PUSH;

CREATE OR REPLACE PACKAGE body ONEDATA_WA.nci_caDSR_push AS


 function getShortDef(v_def in varchar2) return varchar
 is
 begin
    if length(v_def) >= 2000 then
        return substr(v_def,1,1996) || ' ...';
    else
        return v_def;
    end if;
 end;

 procedure spPushLov (vDays in Integer)
as
v_cnt integer;
begin

v_cnt := 1;

---- Registration Status


update sbr.reg_status_lov set (description, comments, display_order, date_modified, modified_by) =
    (select stus_Desc, nci_cmnts, nci_disp_ordr, lst_upd_dt, lst_upd_usr_id
    from stus_mstr
    where stus_typ_id = 1
    and   lst_upd_dt >=  sysdate - vDays
    and   upper(nci_stus) =upper(registration_status))
where upper(registration_status) in (select upper(nci_stus) from stus_mstr
    where stus_typ_id =1
    and   lst_upd_dt >=  sysdate - vDays );


insert into sbr.reg_status_lov (registration_status,description, comments,created_by, date_created, date_modified, modified_by, display_order)
select nci_stus, stus_desc, nci_cmnts,  CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID, NCI_DISP_ORDR
from stus_mstr
where stus_typ_id = 1
and   upper(nci_stus) not in (select upper(registration_status) from sbr.reg_status_lov)
and   creat_dt >= sysdate - vDays;

--- Administrative Status

update sbr.ac_status_lov set (description, comments, display_order, date_modified, modified_by) =
    (select  stus_Desc, nci_cmnts, nci_disp_ordr, lst_upd_dt, lst_upd_usr_id from stus_mstr
    where stus_typ_id = 2
    and   lst_upd_dt >=  sysdate - vDays
    and   upper(nci_stus)= upper(asl_name))
where upper(asl_name) in
    (select upper(nci_stus) from stus_mstr
    where stus_typ_id =2
    and   lst_upd_dt >=  sysdate - vDays );

insert into sbr.ac_status_lov (asl_name,description, comments,created_by, date_created, date_modified, modified_by, display_order)
select nci_stus, stus_desc, nci_cmnts,  CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID, NCI_DISP_ORDR
from stus_mstr
where stus_typ_id = 2
and upper(nci_stus) not in (select upper(asl_name) from sbr.ac_status_lov)
and creat_dt >= sysdate - vDays;
commit;


--- Program Area

update sbr.PROGRAM_AREAS_LOV  set (description, comments, date_modified, modified_by) =
    (select  obj_key_def, obj_key_cmnts, LST_UPD_DT,LST_UPD_USR_ID
    from obj_key
    where obj_typ_id = 14
    and   lst_upd_dt >= sysdate - vDays
    and   upper(nci_cd) = upper(pal_name))
where upper(pal_name) in
    (select upper(nci_cd)
    from obj_key
    where obj_typ_id = 14
    and   lst_upd_dt >=  sysdate - vDays );

insert into sbr.PROGRAM_AREAS_LOV( pal_name, description, comments, created_by, date_created, date_modified, modified_by)
select nci_cd, obj_key_def, obj_key_cmnts, CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID
from obj_key
where obj_typ_id = 14
and   creat_dt > sysdate - vdays
and   upper(nci_cd) not in (select upper(pal_name) from sbr.PROGRAM_AREAS_LOV);


--- Name/Designation Type

update sbr.DESIGNATION_TYPES_LOV set (description,comments, date_modified, modified_by) =
    (select obj_key_def, obj_key_cmnts, LST_UPD_DT,LST_UPD_USR_ID
    from obj_key
    where obj_typ_id = 11
    and   lst_upd_dt > sysdate - vdays
    and   upper(detl_name) = upper(nci_cd))
where upper(detl_name) in
    (select upper(nci_cd)
    from obj_key
    where obj_typ_id = 11
    and lst_upd_dt >=  sysdate - vDays );

insert into sbr.DESIGNATION_TYPES_LOV (detl_name, description,comments, created_by, date_created, date_modified, modified_by)
select nci_cd, obj_key_def, obj_key_cmnts, CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID
from obj_key
where obj_typ_id = 11
and creat_dt > sysdate - vdays
and upper(nci_cd) not in (select upper(detl_name) from sbr.DESIGNATION_TYPES_LOV);

-- DOcument type - Type ID 1

update sbr.document_TYPES_LOV set ( description,comments, date_modified, modified_by) =
    (select  obj_key_def, obj_key_cmnts,  LST_UPD_DT,LST_UPD_USR_ID
    from obj_key
    where obj_typ_id = 1
    and lst_upd_dt > sysdate - vdays
    and upper(dctl_name) = upper(nci_cd))
    where upper(dctl_name) in
        (select upper(nci_cd)
        from obj_key
        where obj_typ_id = 1
        and   lst_upd_dt >=  sysdate - vDays );

insert into sbr.document_TYPES_LOV (dctl_name, description,comments, created_by, date_created, date_modified, modified_by)
select nci_cd, obj_key_def, obj_key_cmnts, CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID
from obj_key
where obj_typ_id = 1
and   creat_dt > sysdate - vdays
and   upper(nci_cd) not in (select upper(dctl_name) from sbr.document_TYPES_LOV);


-- Classification Scheme Type - Type Id 3

update sbr.CS_TYPES_LOV set ( description,comments, date_modified, modified_by) =
    (select obj_key_def, obj_key_cmnts,  LST_UPD_DT,LST_UPD_USR_ID
    from obj_key
    where obj_typ_id = 3
    and   lst_upd_dt > sysdate - vdays
    and   upper(CSTL_NAME) = upper(nci_cd))
    where upper(cstl_name) in
        (select upper(nci_cd)
        from obj_key
        where obj_typ_id = 3
        and   lst_upd_dt >=  sysdate - vDays );

insert into sbr.CS_TYPES_LOV (CSTL_NAME, description,comments, created_by, date_created, date_modified, modified_by)
select nci_cd, obj_key_def, obj_key_cmnts, CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID
from obj_key
where obj_typ_id = 3
and   creat_dt > sysdate - vdays
and   upper(nci_cd) not in (select upper(cstl_name) from sbr.CS_TYPES_LOV);


-- Classification Scheme Item Type - Type ID 20

update sbr.CSI_TYPES_LOV set (description,comments, date_modified, modified_by) =
    (select obj_key_def, obj_key_cmnts,  LST_UPD_DT,LST_UPD_USR_ID
    from obj_key
    where obj_typ_id = 20
    and   lst_upd_dt > sysdate - vdays
    and   upper(CSITL_NAME) = upper(nci_cd))
where upper(csitl_name) in
    (select upper(nci_cd)
    from obj_key
    where obj_typ_id = 20
    and lst_upd_dt >=  sysdate - vDays );

insert into sbr.CSI_TYPES_LOV (CSITL_NAME, description,comments, created_by, date_created, date_modified, modified_by)
select nci_cd, obj_key_def, obj_key_cmnts, CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID
from obj_key
where obj_typ_id = 20
and creat_dt > sysdate - vdays
and upper(nci_cd) not in (select upper(csitl_name) from sbr.CSI_TYPES_LOV);


-- Concept Source - Type ID 23

update sbrext.concept_sources_lov_ext set (description, date_modified, modified_by) =
    (select obj_key_def,  LST_UPD_DT,LST_UPD_USR_ID
    from obj_key
    where obj_typ_id = 23
    and lst_upd_dt > sysdate - vdays
    and upper(CONCEPT_SOURCE) = upper(nci_cd))
where upper(concept_source) in
    (select upper(nci_cd)
    from obj_key
    where obj_typ_id = 23
    and lst_upd_dt >=  sysdate - vDays );

insert into sbrext.concept_sources_lov_ext (CONCEPT_SOURCE, description, created_by, date_created, date_modified, modified_by)
select nci_cd, obj_key_def,  CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID
from obj_key
where obj_typ_id = 23
and   creat_dt > sysdate - vdays
and   upper(nci_cd) not in (select upper(CONCEPT_SOURCE) from sbrext.concept_sources_lov_ext);


-- NCI Derivation Type - Type 21

update sbr.complex_rep_type_lov set (description, date_modified, modified_by) =
    (select obj_key_def, LST_UPD_DT,LST_UPD_USR_ID
    from obj_key
    where obj_typ_id = 21
    and   lst_upd_dt > sysdate - vdays
    and   upper(CRTL_NAME) = upper(nci_cd))
where upper(crtl_name) in
    (select upper(nci_cd)
    from obj_key
    where obj_typ_id = 21
    and   lst_upd_dt >=  sysdate - vDays );


insert into sbr.complex_rep_type_lov (CRTL_NAME, description, created_by, date_created, date_modified, modified_by)
select nci_cd, obj_key_def, CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID
from obj_key
where obj_typ_id = 21
and   creat_dt > sysdate - vdays
and   upper(nci_cd) not in (select upper(CRTL_NAME) from sbr.complex_rep_type_lov);


--- Data type

update sbr.datatypes_lov set (DESCRIPTION,COMMENTS, date_modified, modified_by, SCHEME_REFERENCE, ANNOTATION) =
    (select DTTYPE_DESC, NCI_DTTYPE_CMNTS, LST_UPD_DT,LST_UPD_USR_ID, DTTYPE_SCHM_REF, DTTYPE_ANNTTN
    from data_typ
    where lst_upd_Dt >= sysdate - vDays
    and   nci_dttype_typ_id = 1
    and   upper(dtl_name) = upper(NCI_CD))
where upper(dtl_name) in
    (select upper(nci_cd)
    from data_typ
    where nci_dttype_typ_id=1
    and lst_upd_dt >=  sysdate - vDays );

insert into sbr.datatypes_lov (dtl_name, DESCRIPTION,COMMENTS, date_modified, modified_by, SCHEME_REFERENCE, ANNOTATION)
select  NCI_CD, DTTYPE_DESC, NCI_DTTYPE_CMNTS, LST_UPD_DT,LST_UPD_USR_ID, DTTYPE_SCHM_REF, DTTYPE_ANNTTN
from data_typ
where lst_upd_Dt >= sysdate - vDays
and   nci_dttype_typ_id = 1
and   upper(nci_cd) not in (select upper(dtl_name) from sbr.datatypes_lov);


/*insert into data_typ ( DTTYPE_NM, NCI_CD, DTTYPE_DESC, NCI_DTTYPE_CMNTS,
CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID,
DTTYPE_SCHM_REF, DTTYPE_ANNTTN)
select DTL_NAME, DTL_NAME, DESCRIPTION,COMMENTS,
created_by, date_created,date_modified, modified_by,
SCHEME_REFERENCE, ANNOTATION from sbr.datatypes_lov;
*/
-- Format


insert into sbr.formats_lov (FORML_NAME,DESCRIPTION,COMMENTS, created_by, date_created,date_modified, modified_by)
select NCI_CD,FMT_DESC,FMT_CMNTS, CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID
from fmt
where creat_dt >= sysdate - vDays
and upper(nci_cd) not in (select upper(forml_name) from sbr.formats_lov);

/*insert into FMT ( FMT_NM, NCI_CD,FMT_DESC,FMT_CMNTS,
CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID)
select FORML_NAME, FORML_NAME,DESCRIPTION,COMMENTS,
created_by, date_created,date_modified, modified_by from sbr.formats_lov;
*/

-- UOM

insert into sbr.unit_of_measures_lov (UOML_NAME,PRECISION, DESCRIPTION,COMMENTS, created_by, date_created,date_modified, modified_by)
select NCI_CD, UOM_PREC,UOM_DESC,UOM_CMNTS, CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID
from UOM
where creat_dt >= sysdate - vDays
and upper(NCI_CD) not in (select upper(UOML_NAME) from sbr.unit_of_measures_lov);


-- Definition type - type id 15

update sbrext.definition_types_lov_ext set (DEFL_NAME, description,comments, date_modified, modified_by) =
    (select nci_cd, obj_key_def, obj_key_cmnts, LST_UPD_DT,LST_UPD_USR_ID
    from obj_key
    where obj_typ_id = 15
    and   lst_upd_dt > sysdate - vdays
    and   upper(DEFL_NAME) = upper(nci_cd))
where upper(defl_name) in
    (select upper(nci_cd)
    from obj_key
    where obj_typ_id = 15
    and   lst_upd_dt >=  sysdate - vDays );



insert into sbrext.definition_types_lov_ext (DEFL_NAME, description,comments, created_by, date_created, date_modified, modified_by)
select nci_cd, obj_key_def, obj_key_cmnts, CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID
from obj_key
where obj_typ_id = 15
and   creat_dt > sysdate - vdays
and   upper(nci_cd) not in (select upper(DEFL_NAME) from sbrext.definition_types_lov_ext);


/*insert into obj_key (obj_typ_id, obj_key_desc, obj_key_def, nci_cd,obj_key_cmnts, CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID)
select 15, DEFL_NAME, description, DEFL_NAME, comments, created_by, date_created,
                    date_modified, modified_by from sbrext.definition_types_lov_ext;
*/

-- Origin - Type id 18

update sbrext.sources_ext set (SRC_NAME, description, date_modified, modified_by) =
    (select nci_cd, obj_key_def, LST_UPD_DT,LST_UPD_USR_ID
    from obj_key
    where obj_typ_id = 18
    and   lst_upd_dt > sysdate - vdays
    and   upper(SRC_NAME) = upper(nci_cd))
where upper(src_name) in
    (select upper(nci_cd)
    from obj_key
    where obj_typ_id = 18
    and lst_upd_dt >=  sysdate - vDays );

insert into sbrext.sources_ext (SRC_NAME, description, created_by, date_created, date_modified, modified_by)
select nci_cd, obj_key_def, CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID
from obj_key
where obj_typ_id = 18
and creat_dt > sysdate - vdays
and upper(nci_cd) not in (select upper(SRC_NAME) from sbrext.sources_ext);


/*insert into obj_key (obj_typ_id, obj_key_desc, obj_key_def, nci_cd, CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID)
select 18, SRC_NAME, description, SRC_NAME,  created_by, date_created,
                    date_modified, modified_by from sbrext.sources_ext;

*/


-- Form Category - Type id 22

update sbrext.QC_DISPLAY_LOV_EXT set (QCDL_NAME, description, date_modified, modified_by) =
    (select nci_cd, obj_key_def, LST_UPD_DT,LST_UPD_USR_ID
    from obj_key
    where obj_typ_id = 22
    and   lst_upd_dt > sysdate - vdays
    and   upper(QCDL_NAME) = upper(nci_cd))
where upper(qcdl_name) in
    (select upper(nci_cd)
    from obj_key
    where obj_typ_id = 22
    and lst_upd_dt >=  sysdate - vDays );

insert into sbrext.QC_DISPLAY_LOV_EXT (QCDL_NAME, description, created_by, date_created, date_modified, modified_by, display_order)
select nci_cd, obj_key_def, CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID, 1
from obj_key
where obj_typ_id = 22
and   creat_dt > sysdate - vdays
and   upper(nci_cd) not in (select upper(QCDL_NAME) from sbrext.QC_DISPLAY_LOV_EXT);
commit;


-- Address Type id 25

update sbr.ADDR_TYPES_LOV set (ATL_NAME, description, comments, date_modified, modified_by) =
    (select nci_cd, obj_key_def, obj_key_cmnts, LST_UPD_DT,LST_UPD_USR_ID
    from obj_key
    where obj_typ_id = 25
    and   lst_upd_dt > sysdate - vdays
    and   upper(ATL_NAME) = upper(nci_cd))
where upper(ATL_NAME) in
    (select upper(nci_cd)
    from obj_key
    where obj_typ_id = 25
    and lst_upd_dt >=  sysdate - vDays );

insert into sbr.COMM_TYPES_LOV (CTL_NAME, description, comments, created_by, date_created, date_modified, modified_by)
select nci_cd, obj_key_def, obj_key_cmnts,CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID
from obj_key
where obj_typ_id = 25
and   creat_dt > sysdate - vdays
and   upper(nci_cd) not in (select upper(CTL_NAME) from sbr.COMM_TYPES_LOV);
commit;

-- Communication Type id 26

update sbr.COMM_TYPES_LOV set (CTL_NAME, description, comments, date_modified, modified_by) =
    (select nci_cd, obj_key_def, obj_key_cmnts, LST_UPD_DT,LST_UPD_USR_ID
    from obj_key
    where obj_typ_id = 26
    and   lst_upd_dt > sysdate - vdays
    and   upper(CTL_NAME) = upper(nci_cd))
where upper(CTL_NAME) in
    (select upper(nci_cd)
    from obj_key
    where obj_typ_id = 26
    and lst_upd_dt >=  sysdate - vDays );

insert into sbr.COMM_TYPES_LOV (CTL_NAME, description, comments, created_by, date_created, date_modified, modified_by)
select nci_cd, obj_key_def, obj_key_cmnts,CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID
from obj_key
where obj_typ_id = 26
and   creat_dt > sysdate - vdays
and   upper(nci_cd) not in (select upper(CTL_NAME) from  sbr.COMM_TYPES_LOV);
commit;


end;

 procedure spPushAIChildren (vDays in integer)
as
v_cnt integer;
begin

--  Definitions
insert into sbr.definitions (DEFIN_IDSEQ, AC_IDSEQ, DEFINITION, CONTE_IDSEQ, DATE_CREATED, CREATED_BY, DATE_MODIFIED, MODIFIED_BY, LAE_NAME, DEFL_NAME)
select ad.nci_idseq, ai.nci_idseq,  def_desc, c.nci_idseq, ad.CREAT_DT,ad.CREAT_USR_ID,  ad.LST_UPD_DT,ad.LST_UPD_USR_ID,decode(lang_id, 1000,'ENGLISH', 1007, 'Icelandic', 1004, 'Spanish'), ok.nci_cd
from alt_def ad, admin_item ai, admin_item c, obj_key ok
where ad.item_id = ai.item_id
and   ad.ver_nr = ai.ver_nr
and   ad.cntxt_item_id = c.item_id
and   ad.cntxt_ver_nr = c.ver_nr
and nvl(ad.fld_delete,0) = 0
and   ad.nci_def_typ_id = ok.obj_key_id (+)
and   ad.nci_idseq not in (select defin_idseq from sbr.definitions)
and   ad.lst_upd_dt >= sysdate - vDays;

for cur in (select nci_idseq from alt_def where lst_upd_dt > creat_dt and lst_upd_dt >= sysdate - vDays and  nvl(fld_delete,0) = 0 and nci_idseq in (select defin_idseq from sbr.definitions)) loop
update sbr.definitions d set (DEFINITION, CONTE_IDSEQ, DATE_CREATED, CREATED_BY, DATE_MODIFIED, MODIFIED_BY, LAE_NAME, DEFL_NAME) =
    (select  def_desc, c.nci_idseq, ad.CREAT_DT,ad.CREAT_USR_ID,  ad.LST_UPD_DT,ad.LST_UPD_USR_ID,decode(lang_id, 1000,'ENGLISH', 1007, 'Icelandic', 1004, 'Spanish'), ok.nci_cd
    from alt_def ad, admin_item ai, admin_item c, obj_key ok
    where ad.item_id = ai.item_id
    and   ad.ver_nr = ai.ver_nr
    and   ad.cntxt_item_id = c.item_id
    and   ad.cntxt_ver_nr = c.ver_nr
    and   ad.nci_def_typ_id = ok.obj_key_id (+)
    and   ad.nci_idseq = cur.nci_idseq)
where d.defin_idseq = cur.nci_idseq;
end loop;

for cur in (select nci_idseq from alt_def where lst_upd_dt > creat_dt and lst_upd_dt >= sysdate - vDays and  nvl(fld_delete,0) = 1 and nci_idseq in (select defin_idseq from sbr.definitions)) loop
delete from sbr.definitions where  defin_idseq = cur.nci_idseq;
end loop;

commit;

-- Designations
insert into sbr.designations (DEsig_IDSEQ, AC_IDSEQ, NAME, CONTE_IDSEQ, DATE_CREATED, CREATED_BY, DATE_MODIFIED, MODIFIED_BY, LAE_NAME, DETL_NAME)
select ad.nci_idseq, ai.nci_idseq,  nm_desc, c.nci_idseq, ad.CREAT_DT,ad.CREAT_USR_ID,  ad.LST_UPD_DT,ad.LST_UPD_USR_ID,decode(lang_id, 1000,'ENGLISH', 1007, 'Icelandic', 1004, 'Spanish'), ok.nci_cd
from alt_nms ad, admin_item ai, admin_item c, obj_key ok
where ad.item_id = ai.item_id
and   ad.ver_nr = ai.ver_nr
and   ad.cntxt_item_id = c.item_id
and   ad.cntxt_ver_nr = c.ver_nr
and nvl(ad.fld_delete, 0) = 0
and   ad.nm_typ_id = ok.obj_key_id (+)
and   ad.nci_idseq not in (select desig_idseq from sbr.designations)
and   ad.lst_upd_dt >= sysdate - vDays;

for cur in (select nci_idseq from alt_nms where lst_upd_dt > creat_dt and lst_upd_dt >= sysdate - vDays and nvl(fld_delete, 0) = 0 and nci_idseq in (select desig_idseq from sbr.designations)) loop
update sbr.designations d set (NAME, CONTE_IDSEQ, DATE_CREATED, CREATED_BY, DATE_MODIFIED, MODIFIED_BY, LAE_NAME, DETL_NAME) =
    (select  nm_desc, c.nci_idseq, ad.CREAT_DT,ad.CREAT_USR_ID,  ad.LST_UPD_DT,ad.LST_UPD_USR_ID,decode(lang_id, 1000,'ENGLISH', 1007, 'Icelandic', 1004, 'Spanish'), ok.nci_cd
    from alt_nms ad, admin_item ai, admin_item c, obj_key ok
    where ad.item_id = ai.item_id
    and   ad.ver_nr = ai.ver_nr
    and   ad.cntxt_item_id = c.item_id
    and   ad.cntxt_ver_nr = c.ver_nr
    and   ad.nm_typ_id = ok.obj_key_id (+)
    and   ad.nci_idseq = cur.nci_idseq)
where d.desig_idseq = cur.nci_idseq;
end loop;


for cur in (select nci_idseq from alt_nms where lst_upd_dt > creat_dt and lst_upd_dt >= sysdate - vDays and nvl(fld_delete, 0) = 1 and nci_idseq in (select desig_idseq from sbr.designations)) loop
delete from sbr.designations d where d.desig_idseq = cur.nci_idseq;
end loop;
commit;

-- Reference Documents
insert into sbr.reference_documents (RD_IDSEQ, AC_IDSEQ, NAME, CONTE_IDSEQ, DATE_CREATED, CREATED_BY, DATE_MODIFIED, MODIFIED_BY, LAE_NAME, DcTL_NAME,display_order, doc_text,URL)
select ad.nci_idseq, ai.nci_idseq,  ad.ref_nm, c.nci_idseq, ad.CREAT_DT,ad.CREAT_USR_ID,  ad.LST_UPD_DT,ad.LST_UPD_USR_ID,decode(lang_id, 1000,'ENGLISH', 1007, 'Icelandic', 1004, 'Spanish'), ok.nci_cd, ad.disp_ord, ad.ref_desc, ad.url
from ref ad, admin_item ai, admin_item c, obj_key ok
where  ad.item_id = ai.item_id
    and   ad.ver_nr = ai.ver_nr
    and   ai.cntxt_item_id = c.item_id
    and   ai.cntxt_ver_nr = c.ver_nr
    and nvl(ad.fld_delete, 0) = 0
and   ad.ref_typ_id = ok.obj_key_id (+)
and   ad.nci_idseq not in (select rd_idseq from sbr.reference_documents)
and   ad.lst_upd_dt >= sysdate - vDays;


for cur in (select nci_idseq from ref where lst_upd_dt > creat_dt and  lst_upd_dt >= sysdate - vDays and nvl(fld_delete, 0) = 0 and nci_idseq in (select rd_idseq from sbr.reference_documents)) loop
update sbr.reference_documents d set (NAME, CONTE_IDSEQ, DATE_CREATED, CREATED_BY, DATE_MODIFIED, MODIFIED_BY, LAE_NAME, DcTL_NAME,display_order, doc_text, url) =
    (select  ref_nm, c.nci_idseq, ad.CREAT_DT,ad.CREAT_USR_ID,  ad.LST_UPD_DT,ad.LST_UPD_USR_ID,decode(lang_id, 1000,'ENGLISH', 1007, 'Icelandic', 1004, 'Spanish'), ok.nci_cd, ad.disp_ord, ad.ref_desc, ad.url
    from ref ad, admin_item ai, admin_item c, obj_key ok
    where ad.item_id = ai.item_id
    and   ad.ver_nr = ai.ver_nr
    and   ai.cntxt_item_id = c.item_id
    and   ai.cntxt_ver_nr = c.ver_nr
    and   ad.ref_typ_id = ok.obj_key_id (+)
    and   ad.nci_idseq = cur.nci_idseq)
where d.rd_idseq = cur.nci_idseq;
end loop;


for cur in (select nci_idseq from ref where lst_upd_dt > creat_dt and  lst_upd_dt >= sysdate - vDays and nvl(fld_delete, 0) = 1 and nci_idseq in (select rd_idseq from sbr.reference_documents)) loop
delete from sbr.reference_documents d  where d.rd_idseq = cur.nci_idseq;
end loop;

commit;

-- Classifications
insert into sbr.ac_csi (ac_csi_idseq, CS_CSI_IDSEQ, AC_IDSEQ, DATE_CREATED, CREATED_BY, DATE_MODIFIED, MODIFIED_BY)
select nci_11179.cmr_guid, nvl(csi.cs_csi_idseq, csiai.nci_idseq),ai.nci_idseq , ad.CREAT_DT,ad.CREAT_USR_ID,  ad.LST_UPD_DT,ad.LST_UPD_USR_ID
from nci_admin_item_rel ad, admin_item csiai, nci_clsfctn_schm_item csi, admin_item ai
where  ad.p_item_id = csiai.item_id
    and   ad.p_item_ver_nr = csiai.ver_nr
    and   csiai.item_id = csi.item_id
    and   csiai.ver_nr = csi.ver_nr
    and nvl(ad.fld_delete, 0) = 0
and   ad.rel_typ_id = 65
and ad.c_item_id = ai.item_id
and ad.c_item_ver_nr = ai.ver_nr
and   (nvl(csi.cs_csi_idseq, csiai.nci_idseq),ai.nci_idseq)  not in (select cs_csi_idseq, ac_idseq from sbr.ac_csi)
and   ad.lst_upd_dt >= sysdate - vDays;

-- no update for classifications. only insert and delete.
for cur in (select nvl(csi.cs_csi_idseq, csiai.nci_idseq) cs_csi_idseq,ai.nci_idseq
from nci_admin_item_rel ad, admin_item csiai, nci_clsfctn_schm_item csi, admin_item ai
where  ad.p_item_id = csiai.item_id
    and   ad.p_item_ver_nr = csiai.ver_nr
    and   csiai.item_id = csi.item_id
    and   csiai.ver_nr = csi.ver_nr
    and nvl(ad.fld_delete, 0) = 1
and   ad.rel_typ_id = 65
and ad.c_item_id = ai.item_id
and ad.lst_upd_dt > ad.creat_dt
and ad.c_item_ver_nr = ai.ver_nr
and   (nvl(csi.cs_csi_idseq, csiai.nci_idseq),ai.nci_idseq)  in (select cs_csi_idseq, ac_idseq from sbr.ac_csi)
and   ad.lst_upd_dt >= sysdate - vDays) loop
delete from sbr.ac_csi where cs_csi_idseq = cur.cs_csi_idseq and ac_idseq = cur.nci_idseq;
end loop;
commit;

-- Alt names classification

insert into sbrext.AC_ATT_CSCSI_EXT (aca_idseq, cs_csi_idseq, att_idseq,atl_name)
select nci_11179.cmr_guid, nvl(csi.cs_csi_idseq, csiai.nci_idseq), am.nci_idseq, 'DESIGNATION'
from alt_nms am, admin_item csiai, nci_clsfctn_schm_item csi, NCI_CSI_ALT_DEFNMS  x
where x.typ_nm = 'DESIGNATION'
and x.lst_upd_dt >= sysdate - vDays
and x.nci_pub_id = csiai.item_id
and x.nci_ver_nr = csiai.ver_nr
and csiai.item_id = csi.item_id
and nvl(x.fld_delete, 0) = 0
and csiai.ver_nr = csi.ver_nr
and am.nm_id = x.nmdef_id
and (nvl(csi.cs_csi_idseq, csiai.nci_idseq), am.nci_idseq) not in (select cs_csi_idseq, att_idseq from sbrext.AC_ATT_CSCSI_EXT);
commit;

-- Alt def classification

insert into sbrext.AC_ATT_CSCSI_EXT (aca_idseq, cs_csi_idseq, att_idseq, atl_name)
select nci_11179.cmr_guid, nvl(csi.cs_csi_idseq, csiai.nci_idseq), am.nci_idseq, 'DEFINITION'
from alt_def am, admin_item csiai, nci_clsfctn_schm_item csi, NCI_CSI_ALT_DEFNMS  x
where x.typ_nm = 'DEFINITION'
and x.lst_upd_dt >= sysdate - vDays
and x.nci_pub_id = csiai.item_id
and x.nci_ver_nr = csiai.ver_nr
and nvl(x.fld_delete, 0) = 0
and csiai.item_id = csi.item_id
and csiai.ver_nr = csi.ver_nr
and am.def_id = x.nmdef_id
and (nvl(csi.cs_csi_idseq, csiai.nci_idseq), am.nci_idseq) not in (select cs_csi_idseq, att_idseq from sbrext.AC_ATT_CSCSI_EXT);
commit;


/*
-- Reference Blobs
insert into sbr.reference_blobs (RD_IDSEQ, NAME, DOC_SIZE, DAD_CHARSET, LAST_UPDATED, BLOB_CONTENT, DATE_CREATED, CREATED_BY, DATE_MODIFIED, MODIFIED_BY)
select ad.nci_idseq, file_nm, nci_doc_size, nci_charset, nci_doc_lst_upd_dt, blob_col, ad.CREAT_DT, ad.CREAT_USR_ID, ad.LST_UPD_DT,ad.LST_UPD_USR_ID
from ref ad, ref_doc rd, admin_item ai, admin_item c, obj_key ok
where ad.item_id = ai.item_id
and   ad.ver_nr = ai.ver_nr
and   ai.cntxt_item_id = c.item_id
and   ai.cntxt_ver_nr = c.ver_nr
and   ad.ref_typ_id = ok.obj_key_id (+)
and   ad.nci_idseq not in (select rd_idseq from sbr.reference_blobs)
and ad.lst_upd_dt >= sysdate - vDays;


for cur in (select nci_idseq from ref where lst_upd_dt > creat_dt and lst_upd_dt >= sysdate - vDays and nci_idseq in (select rd_idseq from sbr.reference_documents)) loop
update sbr.reference_blobs d set(RD_IDSEQ, NAME, DOC_SIZE, DAD_CHARSET, LAST_UPDATED, BLOB_CONTENT, DATE_CREATED, CREATED_BY, DATE_MODIFIED, MODIFIED_BY) =
    (select ad.nci_idseq, file_nm, nci_doc_size, nci_charset, nci_doc_lst_upd_dt, blob_col, ad.CREAT_DT, ad.CREAT_USR_ID, ad.LST_UPD_DT,ad.LST_UPD_USR_ID
    from ref ad, ref_doc rd, admin_item ai, admin_item c, obj_key ok
    where ad.item_id = ai.item_id
    and   ad.ver_nr = ai.ver_nr
    and   ai.cntxt_item_id = c.item_id
    and   ai.cntxt_ver_nr = c.ver_nr
    and   ad.ref_typ_id = ok.obj_key_id (+)
    and   ad.nci_idseq not in (select rd_idseq from sbr.reference_blobs)
    and   ad.lst_upd_dt >= sysdate - vDays);
end loop;
*/
commit;


-- DE Derivation Components
/*
insert into sbr.complex_de_relationships (p_de_idseq, c_de_idseq, display_order,created_by, date_created, date_modified, modified_by)
select prnt.nci_idseq, chld.nci_idseq, disp_ord, r.CREAT_USR_ID,    r.CREAT_DT,   r.LST_UPD_DT,    r.LST_UPD_USR_ID from nci_admin_item_rel r, admin_item         prnt,
               admin_item     chld
where rel_typ_id= 66 and r.p_item_id = prnt.item_id and r.p_item_ver_nr = prnt.ver_nr and r.c_item_id = chld.item_id and r.c_item_ver_nr = chld.ver_nr
and r.lst_upd_dt >= sysdate - vDays
and (prnt.nci_idseq, chld.nci_idseq) not in (select p_de_idseq, c_de_idseq from sbr.complex_de_relationships);
commit;

-- update sbr.complex_de_relationships  set (display_order  ,date_modified, modified_by) = (select disp_ord,

/*
Protocol Form Relationshio
    INSERT INTO nci_admin_item_rel (P_ITEM_ID,
                                    P_ITEM_VER_NR,
                                    C_ITEM_ID,
                                    C_ITEM_VER_NR,
                                    --CNTXT_ITEM_ID, CNTXT_VER_NR,
                                    REL_TYP_ID)
        SELECT DISTINCT pro.item_id,
                        pro.ver_nr,
                        frm.item_id,
                        frm.ver_nr,
                        60
          --, qc.DISPLAY_ORDER
          FROM admin_item pro, admin_item frm, sbrext.protocol_qc_ext qc
         WHERE     pro.nci_idseq = qc.proto_idseq
               AND frm.nci_idseq = qc.qc_idseq
               AND pro.admin_item_typ_id = 50
               AND frm.admin_item_typ_id = 54;

    COMMIT;
    */

    /*
    -- Form-module relationship
    INSERT INTO nci_admin_item_rel (P_ITEM_ID,
                                    P_ITEM_VER_NR,
                                    C_ITEM_ID,
                                    C_ITEM_VER_NR,
                                    --CNTXT_ITEM_ID, CNTXT_VER_NR,
                                    REL_TYP_ID,
                                    DISP_ORD,
                                    REP_NO,
                                    --DISP_LBL,
                                    CREAT_DT,
                                    CREAT_USR_ID,
                                    LST_UPD_USR_ID,
                                    LST_UPD_DT)
        SELECT DISTINCT frm.item_id,
                        frm.ver_nr,
                        MOD.item_id,
                        MOD.ver_nr,
                        61,
                        qc.DISPLAY_ORDER,
                        qc.REPEAT_NO,
                        qc.DATE_CREATED,
                        qc.CREATED_BY,
                        NVL (qc.MODIFIED_BY, qc.date_created),
                        DATE_MODIFIED
          FROM admin_item MOD, admin_item frm, sbrext.quest_contents_ext qc
         WHERE     MOD.nci_idseq = qc.qc_idseq
               AND frm.nci_idseq = qc.dn_crf_idseq
               AND qc.qtl_name = 'MODULE'
               AND MOD.admin_item_typ_id = 52
               AND frm.admin_item_typ_id = 54;

    COMMIT;
END;
*/
end;

procedure spPushAISpecific (vDays in integer)
as
v_temp integer;
v_nci_idseq char(36);
v_vd_idseq char(36);
v_pv_idseq char(36);
begin

--- CD-VM relationship
/*
update sbr.cd_vms set (CD_IDSEQ, VM_IDSEQ,  SHORT_MEANING, DATE_CREATED, CREATED_BY, DATE_MODIFIED, MODIFIED_BY) =  --- Check what needs to go into short-meaning
    (select cd.nci_idseq, vm.nci_idseq, vm.item_long_nm, cdvm.CREAT_DT,cdvm.CREAT_USR_ID, cdvm.LST_UPD_DT,cdvm.LST_UPD_USR_ID
    from conc_dom_val_mean cdvm, admin_item cd, admin_item vm
    where cdvm.conc_dom_item_id = cd.item_id
    and   cdvm.conc_dom_ver_nr = cd.ver_nr
    and   cdvm.nci_val_mean_item_id = vm.item_id
    and   cdvm.nci_val_mean_ver_nr = vm.ver_nr
    and   cdvm.lst_upd_dt >= sysdate - vDays
    and   (cd.nci_idseq, vm.nci_idseq) in (select cd_idseq, vm_idseq from sbr.cd_vms));
*/

insert into sbr.cd_vms (cv_idseq, CD_IDSEQ, VM_IDSEQ,  SHORT_MEANING, DATE_CREATED, CREATED_BY, DATE_MODIFIED, MODIFIED_BY)  --- Check what needs to go into short-meaning
select nci_11179.cmr_guid, cd.nci_idseq, vm.nci_idseq, vm.item_long_nm, cdvm.CREAT_DT,cdvm.CREAT_USR_ID,  cdvm.LST_UPD_DT,cdvm.LST_UPD_USR_ID
from conc_dom_val_mean cdvm, admin_item cd, admin_item vm
where cdvm.conc_dom_item_id = cd.item_id
and   cdvm.conc_dom_ver_nr = cd.ver_nr
and   cdvm.nci_val_mean_item_id = vm.item_id and cdvm.nci_val_mean_ver_nr = vm.ver_nr
and   (cd.nci_idseq, vm.nci_idseq) not in (select cd_idseq, vm_idseq from sbr.cd_vms)
and   cdvm.lst_upd_dt >= sysdate - vDays;
commit;

-- Permissible Values
/*
for cur in (select PERM_VAL_BEG_DT, PERM_VAL_END_DT, PERM_VAL_NM, PERM_VAL_DESC_TXT,pv.nci_idseq nci_idseq, vm.nci_idseq vm_idseq, pv.LST_UPD_DT,pv.LST_UPD_USR_ID
    from perm_val pv, admin_item vm where pv.nci_val_mean_item_id = vm.item_id
    and   pv.nci_val_mean_ver_nr = vm.ver_nr
    and   pv.lst_upd_dt >= sysdate - vDays
    and pv.creat_dt <> pv.lst_upd_dt
    and pv.nci_idseq in (select pv_idseq from sbr.permissible_Values)) loop
update sbr.permissible_Values set (BEGIN_DATE, END_DATE, VALUE, SHORT_MEANING, vm_idseq,  DATE_MODIFIED, MODIFIED_BY) =
    (select cur.PERM_VAL_BEG_DT, cur.PERM_VAL_END_DT, cur.PERM_VAL_NM, cur.PERM_VAL_DESC_TXT, cur.vm_idseq, cur.LST_UPD_DT,cur.LST_UPD_USR_ID from dual)
  where pv_idseq = cur.nci_idseq;
  end loop;
commit;
*/

insert into sbr.permissible_Values(pv_idseq, BEGIN_DATE, END_DATE, VALUE, SHORT_MEANING, vm_idseq, DATE_CREATED, CREATED_BY, DATE_MODIFIED, MODIFIED_BY)
select nci_11179.cmr_guid, min(PERM_VAL_BEG_DT), max(PERM_VAL_END_DT), PERM_VAL_NM, nvl(max(PERM_VAL_DESC_TXT), 'NO MEANING'), vm.nci_idseq, min(pv.CREAT_DT),min(pv.CREAT_USR_ID),min(pv.LST_UPD_DT),min(pv.LST_UPD_USR_ID)
from perm_val pv, admin_item vm
where pv.nci_val_mean_item_id = vm.item_id
and   pv.nci_val_mean_ver_nr = vm.ver_nr
and   pv.lst_upd_dt >= sysdate - vDays
and nvl(pv.fld_delete,0) = 0
and   (perm_val_nm, vm.nci_idseq) not in (select value, vm_idseq  from sbr.permissible_Values)
group by perm_val_nm, vm.nci_idseq;
commit;

/*
update sbr.vd_pvs set (BEGIN_DATE, END_DATE, pv_idseq, vd_idseq, DATE_MODIFIED, MODIFIED_BY) =
    (select PERM_VAL_BEG_DT, PERM_VAL_END_DT, pv.nci_idseq, vd.nci_idseq,  pv.LST_UPD_DT,pv.LST_UPD_USR_ID
    from perm_val pv, admin_item vd
    where pv.val_dom_item_id = vd.item_id
    and   pv.val_dom_ver_nr = vd.ver_nr
    and   pv.lst_upd_dt >= sysdate - vDays
    and   pv.nci_idseq in (select pv_idseq from sbr.vd_pvs));
*/

/*
for cur in (select distinct val_dom_item_id, val_dom_ver_nr from perm_val where  lst_upd_dt >= sysdate - vDays) loop
select nci_idseq into v_nci_idseq from admin_item where item_id = cur.val_dom_item_id and ver_nr = cur.val_dom_ver_nr;

delete from sbr.vd_pvs where vd_idseq = v_nci_idseq;
commit;
insert into sbr.vd_pvs (vp_idseq, BEGIN_DATE, END_DATE, pv_idseq, vd_idseq, DATE_CREATED, CREATED_BY, DATE_MODIFIED, MODIFIED_BY)
select pv.nci_idseq, PERM_VAL_BEG_DT, PERM_VAL_END_DT,spv.pv_idseq,  v_nci_idseq, pv.CREAT_DT,pv.CREAT_USR_ID, pv.LST_UPD_DT,pv.LST_UPD_USR_ID
from sbr.permissible_Values spv, perm_val pv, admin_item vm where pv.val_dom_item_id = cur.val_dom_item_id and pv.val_dom_ver_nr = cur.val_dom_ver_nr
and pv.perm_val_nm = spv.value and vm.nci_idseq = spv.vm_idseq and pv.nci_val_mean_item_id = vm.item_id and pv.nci_val_mean_ver_nr = vm.ver_nr;
end loop;
commit;
*/

for cur in (select * from perm_val where  lst_upd_dt >= sysdate - vDays and nvl(fld_delete,0) = 0) loop
select pv_idseq into v_pv_idseq from admin_item ai, sbr.permissible_values pv where ai.item_id = cur.nci_val_mean_item_id and ai.ver_nr = cur.nci_val_mean_ver_nr
and ai.nci_idseq = pv.vm_idseq and pv.value = cur.perm_val_nm;
select nci_idseq into v_vd_idseq from admin_item where item_id = cur.val_dom_item_id and ver_nr = cur.val_dom_ver_nr;

--select count(*) into v_temp from sbr.vd_pvs where pv_idseq = v_pv_idseq and vd_idseq = v_vd_idseq;
select count(*) into v_temp from sbr.vd_pvs where vp_idseq = cur.nci_idseq
or (vd_idseq, pv_idseq) in (select v_vd_idseq, v_pv_idseq from dual) ;

if (v_temp = 0) then
insert into sbr.vd_pvs (vp_idseq, BEGIN_DATE, END_DATE, pv_idseq, vd_idseq, DATE_CREATED, CREATED_BY, DATE_MODIFIED, MODIFIED_BY)
select cur.nci_idseq, cur.PERM_VAL_BEG_DT, cur.PERM_VAL_END_DT, v_pv_idseq, v_vd_idseq, cur.CREAT_DT, cur.CREAT_USR_ID, cur.LST_UPD_DT,cur.LST_UPD_USR_ID from dual;
--elsif v_temp = 1 then
--update sbr.vd_pvs set (BEGIN_DATE, END_DATE, pv_idseq, DATE_MODIFIED, MODIFIED_BY)  =  (select cur.PERM_VAL_BEG_DT, cur.PERM_VAL_END_DT, v_pv_idseq,cur.LST_UPD_DT,cur.LST_UPD_USR_ID from dual )
--where vp_idseq = ;
end if;
end loop;
commit;

end;

procedure sp_create_csi (vDays in integer)
as
v_cnt integer;
begin

-- Classification Scheme Items

update sbr.cs_csi set (cs_idseq, cs_csi_idseq, p_cs_csi_idseq, date_created,created_by,date_modified, modified_by, display_order, label) =
    (select cs.nci_idseq, csi.nci_idseq, pcsi.nci_idseq, rel.creat_dt, rel.CREAT_USR_ID, rel.LST_UPD_DT,rel.LST_UPD_USR_ID, disp_ord, disp_lbl
    from admin_item cs, admin_item csi, admin_item pcsi, nci_admin_item_rel_alt_key rel
    where rel.lst_upd_dt >= sysdate - vDays
    and   rel.cntxt_cs_item_id = cs.item_id
    and   cntxt_cs_ver_nr = cs.ver_nr
    and   rel.c_item_ver_nr = csi.ver_nr
    and   rel.c_item_id = csi.item_id
    and   rel.p_item_ver_nr = pcsi.ver_nr (+)
    and   rel.p_item_id = pcsi.item_id (+)
    and   rel.rel_typ_id = 64
    and   rel.nci_idseq in (select CS_CSI_IDSEQ from sbr.cs_csi));

insert into sbr.cs_csi (cs_idseq, cs_csi_idseq, p_cs_csi_idseq, date_created,created_by,date_modified, modified_by, display_order, label)
    select cs.nci_idseq, csi.nci_idseq, pcsi.nci_idseq, rel.creat_dt, rel.CREAT_USR_ID, rel.LST_UPD_DT,rel.LST_UPD_USR_ID, disp_ord, disp_lbl
    from admin_item cs, admin_item csi, admin_item pcsi, nci_admin_item_rel_alt_key rel
    where rel.lst_upd_dt >= sysdate - vDays
    and   rel.cntxt_cs_item_id = cs.item_id
    and   cntxt_cs_ver_nr = cs.ver_nr
    and   rel.c_item_ver_nr = csi.ver_nr
    and   rel.c_item_id = csi.item_id
    and   rel.p_item_ver_nr = pcsi.ver_nr (+)
    and   rel.p_item_id = pcsi.item_id (+)
    and   rel.rel_typ_id = 64
    and   rel.nci_idseq not in (select CS_CSI_IDSEQ from sbr.cs_csi);
commit;

-- Classification Scheme Items

update sbr.ac_csi set (CS_CSI_IDSEQ,  AC_IDSEQ,  date_created,created_by,date_modified, modified_by) =
    (select csi.nci_idseq, ai.nci_idseq , rel.creat_dt, rel.CREAT_USR_ID, rel.LST_UPD_DT,rel.LST_UPD_USR_ID
    from nci_alt_key_admin_item_rel rel, nci_admin_item_rel_alt_key csi, admin_item ai
    where rel.lst_upd_dt >= sysdate - vDays
    and   rel.c_item_id = ai.item_id
    and   rel.c_item_ver_nr = ai.ver_nr
    and   rel.nci_pub_id = csi.nci_pub_id
    and   rel.nci_ver_nr = csi.nci_ver_nr
    and   rel.rel_typ_id = 65
    and   (csi.nci_idseq, ai.nci_idseq) in (select cs_csi_idseq, ac_idseq from sbr.ac_csi));

insert into sbr.ac_csi (ac_csi_idseq, CS_CSI_IDSEQ,  AC_IDSEQ,  date_created,created_by,date_modified, modified_by)
    select nci_11179.cmr_guid, csi.nci_idseq, ai.nci_idseq , rel.creat_dt, rel.CREAT_USR_ID, rel.LST_UPD_DT,rel.LST_UPD_USR_ID
    from nci_alt_key_admin_item_rel rel, nci_admin_item_rel_alt_key csi, admin_item ai
    where rel.lst_upd_dt >= sysdate - vDays
    and   rel.c_item_id = ai.item_id
    and   rel.c_item_ver_nr = ai.ver_nr
    and   rel.nci_pub_id = csi.nci_pub_id
    and   rel.nci_ver_nr = csi.nci_ver_nr
    and   rel.rel_typ_id = 65
    and   (csi.nci_idseq, ai.nci_idseq) not in (select cs_csi_idseq, ac_idseq from sbr.ac_csi);
commit;

-- Classification Scheme Items - Alternate Designations

update sbrext.AC_ATT_CSCSI_EXT set (CS_CSI_IDSEQ,ATT_IDSEQ,ATL_NAME,date_created,created_by,date_modified, modified_by) =
    (select csi.nci_idseq, an.nci_idseq, 'DESIGNATION',  csian.CREAT_DT, csian.CREAT_USR_ID, csian.LST_UPD_DT,csian.LST_UPD_USR_ID
    from nci_admin_item_rel_alt_key csi, alt_nms an, nci_csi_alt_defnms csian
    where csi.nci_pub_id = csian.nci_pub_id
    and   csi.nci_ver_nr = csian.nci_ver_nr
    and   an.nm_id = nmdef_id
    and   csian.lst_upd_dt >= sysdate - vDays
    and   (csi.nci_idseq, an.nci_idseq) in (select CS_CSI_IDSEQ,ATT_IDSEQ from sbr.ac_att_cscsi_ext));


insert into sbrext.AC_ATT_CSCSI_EXT (CS_CSI_IDSEQ,ATT_IDSEQ,ATL_NAME,date_created,created_by,date_modified, modified_by)
    select csi.nci_idseq, an.nci_idseq, 'DESIGNATION',  csian.CREAT_DT, csian.CREAT_USR_ID, csian.LST_UPD_DT,csian.LST_UPD_USR_ID
    from nci_admin_item_rel_alt_key csi, alt_nms an, nci_csi_alt_defnms csian
    where csi.nci_pub_id = csian.nci_pub_id
    and   csi.nci_ver_nr = csian.nci_ver_nr
    and   an.nm_id = nmdef_id
    and   csian.lst_upd_dt >= sysdate - vDays
    and   (csi.nci_idseq, an.nci_idseq) not in (select CS_CSI_IDSEQ,ATT_IDSEQ from sbr.ac_att_cscsi_ext);
commit;

-- Classification Scheme Items - Alternate Definitions

update sbrext.AC_ATT_CSCSI_EXT set (CS_CSI_IDSEQ,ATT_IDSEQ,ATL_NAME,date_created,created_by,date_modified, modified_by) =
    (select csi.nci_idseq, an.nci_idseq, 'DEFINITION',  csian.CREAT_DT, csian.CREAT_USR_ID, csian.LST_UPD_DT,csian.LST_UPD_USR_ID
    from nci_admin_item_rel_alt_key csi, alt_def an, nci_csi_alt_defnms csian
    where csi.nci_pub_id = csian.nci_pub_id
    and csi.nci_ver_nr = csian.nci_ver_nr
    and an.def_id = nmdef_id
    and csian.lst_upd_dt >= sysdate - vDays
    and (csi.nci_idseq, an.nci_idseq) in (select CS_CSI_IDSEQ,ATT_IDSEQ from sbr.ac_att_cscsi_ext));

insert into sbrext.AC_ATT_CSCSI_EXT (CS_CSI_IDSEQ,ATT_IDSEQ,ATL_NAME,date_created,created_by,date_modified, modified_by)
    select csi.nci_idseq, an.nci_idseq, 'DEFINITION',  csian.CREAT_DT, csian.CREAT_USR_ID, csian.LST_UPD_DT,csian.LST_UPD_USR_ID
    from nci_admin_item_rel_alt_key csi, alt_def an, nci_csi_alt_defnms csian
    where csi.nci_pub_id = csian.nci_pub_id
    and   csi.nci_ver_nr = csian.nci_ver_nr
    and   an.def_id = nmdef_id
    and   csian.lst_upd_dt >= sysdate - vDays
    and   (csi.nci_idseq, an.nci_idseq) not in (select CS_CSI_IDSEQ,ATT_IDSEQ from sbr.ac_att_cscsi_ext);
commit;

end;

END;
/


DROP PACKAGE BODY ONEDATA_WA.NCI_CADSR_PUSH_CORE;

CREATE OR REPLACE PACKAGE body ONEDATA_WA.nci_caDSR_push_core AS

procedure spPushAI (vDays in integer)
as
--    1 - Conceptual Domain
--    2 - Data Element Concept
--    3 - Value Domain
--    4 - Data Element
--    5 - Object Class
--    6 - Property
--    7 - Representation Class
--    8 - Context
--    9 - Classification Scheme
--    49 - Concept
--    52 - Module
--    54 - Form
--    53 - Value Meaning
--    51 - Classification Scheme Item
--    50 - Protocol
--    56 - OCRecs
v_cnt integer;
v_test integer;
ActionType char(1);
begin


for cur in (select nci_idseq, item_id, ver_nr, admin_item_typ_id from admin_item ai, obj_key ok where admin_item_typ_id <> 52 and ai.admin_item_typ_id = ok.obj_key_id and ok.obj_typ_id = 4
and ai.lst_upd_dt >= sysdate -vDays order by ok.disp_ord) loop
select count(*) into v_cnt  from sbr.administered_components where ac_idseq = cur.nci_idseq;
if (v_cnt = 0) then ActionType := 'I';
else ActionType := 'U';
end if;
begin
dbms_output.put_line(cur.item_id || ActionType);
end;
case cur.admin_item_typ_id
when 1 then --- Conceptual Domain
nci_cadsr_push_core.pushCD(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);

when 2 then --- Data Element Concept
nci_cadsr_push_core.pushDEC(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);

when 3 then --- Value Domain
nci_cadsr_push_core.pushVD(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);

when 4 then ---- Data Element
nci_cadsr_push_core.pushDE(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);

when 5 then --- Object Class
nci_cadsr_push_core.pushOC(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);

when 6 then --- Property
nci_cadsr_push_core.pushProp(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);

when 7 then ---Representation Class
nci_cadsr_push_core.pushRC(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);

when 8 then --- Context
nci_cadsr_push_core.pushContext(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);

when 9 then --- Classification Scheme
nci_cadsr_push_core.pushCS(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);

when 49 then ---Concept
--v_test := 1;
nci_cadsr_push_core.pushConcept(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);


when 54 then --- Form
nci_cadsr_push_core.pushForm(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);

when 53 then --- Value Meaning
nci_cadsr_push_core.pushVM(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);

when 51 then  --- Classification Scheme Item
nci_cadsr_push_core.pushCSI(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);

when 50 then --- Protocol
nci_cadsr_push_core.pushProt(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);


when 56 then --- Protocol
nci_cadsr_push_core.pushOCRecs(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);

end case;
nci_cadsr_push_core.pushAC(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);
commit;
end loop;

end;


procedure spPushAIType (vDays in integer, v_typ in integer)
as
--    1 - Conceptual Domain
--    2 - Data Element Concept
--    3 - Value Domain
--    4 - Data Element
--    5 - Object Class
--    6 - Property
--    7 - Representation Class
--    8 - Context
--    9 - Classification Scheme
--    49 - Concept
--    52 - Module
--    54 - Form
--    53 - Value Meaning
--    51 - Classification Scheme Item
--    50 - Protocol
--    56 - OCRecs
v_cnt integer;
v_test integer;
ActionType char(1);
begin


for cur in (select nci_idseq, item_id, ver_nr, admin_item_typ_id from admin_item where  lst_upd_dt >= sysdate -vDays and admin_item_typ_id = v_typ order by creat_dt) loop
select count(*) into v_cnt  from sbr.administered_components where ac_idseq = cur.nci_idseq;

--raise_application_error(-20000, cur.item_id);

if (v_cnt = 0) then ActionType := 'I';
else ActionType := 'U';
end if;

case v_typ
when 1 then --- Conceptual Domain
nci_cadsr_push_core.pushCD(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);

when 2 then --- Data Element Concept
nci_cadsr_push_core.pushDEC(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);

when 3 then --- Value Domain
nci_cadsr_push_core.pushVD(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);

when 4 then ---- Data Element
nci_cadsr_push_core.pushDE(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);

when 5 then --- Object Class
nci_cadsr_push_core.pushOC(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);

when 6 then --- Property
nci_cadsr_push_core.pushProp(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);

when 7 then ---Representation Class
nci_cadsr_push_core.pushRC(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);

when 8 then --- Context
nci_cadsr_push_core.pushContext(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);

when 9 then --- Classification Scheme
nci_cadsr_push_core.pushCS(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);

when 49 then ---Concept
v_test := 1;
--nci_cadsr_push_core.pushConcept(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);


when 54 then --- Form
nci_cadsr_push_core.pushForm(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);

when 53 then --- Value Meaning
nci_cadsr_push_core.pushVM(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);

when 51 then  --- Classification Scheme Item
nci_cadsr_push_core.pushCSI(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);

when 50 then --- Protocol
nci_cadsr_push_core.pushProt(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);


when 56 then --- Protocol
nci_cadsr_push_core.pushOCRecs(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);

end case;
nci_cadsr_push_core.pushAC(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);
commit;
end loop;

end;


procedure spPushAIID (vItemId in number, vVerNr in number)
as
--    1 - Conceptual Domain
--    2 - Data Element Concept
--    3 - Value Domain
--    4 - Data Element
--    5 - Object Class
--    6 - Property
--    7 - Representation Class
--    8 - Context
--    9 - Classification Scheme
--    49 - Concept
--    52 - Module
--    54 - Form
--    53 - Value Meaning
--    51 - Classification Scheme Item
--    50 - Protocol
--    56 - OCRecs
v_cnt integer;
v_test integer;
ActionType char(1);
begin


for cur in (select nci_idseq, item_id, ver_nr, admin_item_typ_id from admin_item where  item_id =vItemId and ver_nr=vVerNr) loop
select count(*) into v_cnt  from sbr.administered_components where ac_idseq = cur.nci_idseq;

--raise_application_error(-20000, cur.item_id);

if (v_cnt = 0) then ActionType := 'I';
else ActionType := 'U';
end if;

case cur.admin_item_typ_id
when 1 then --- Conceptual Domain
nci_cadsr_push_core.pushCD(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);

when 2 then --- Data Element Concept
nci_cadsr_push_core.pushDEC(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);

when 3 then --- Value Domain
nci_cadsr_push_core.pushVD(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);

when 4 then ---- Data Element
nci_cadsr_push_core.pushDE(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);

when 5 then --- Object Class
nci_cadsr_push_core.pushOC(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);

when 6 then --- Property
nci_cadsr_push_core.pushProp(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);

when 7 then ---Representation Class
nci_cadsr_push_core.pushRC(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);

when 8 then --- Context
nci_cadsr_push_core.pushContext(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);

when 9 then --- Classification Scheme
nci_cadsr_push_core.pushCS(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);

when 49 then ---Concept
v_test := 1;
--nci_cadsr_push_core.pushConcept(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);


when 54 then --- Form
nci_cadsr_push_core.pushForm(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);

when 53 then --- Value Meaning
nci_cadsr_push_core.pushVM(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);

when 51 then  --- Classification Scheme Item
nci_cadsr_push_core.pushCSI(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);

when 50 then --- Protocol
nci_cadsr_push_core.pushProt(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);


when 56 then --- Protocol
nci_cadsr_push_core.pushOCRecs(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);

end case;
nci_cadsr_push_core.pushAC(cur.nci_idseq, cur.item_id, cur.ver_nr, ActionType);
commit;
end loop;

end;

procedure pushOC (vIdseq in char, vItemId in number, vVerNr in number, vActionType in char)
as
begin

pushCondr (vIdseq, vItemId, vVerNr, vActionType);

if vActionType = 'U' then

update sbrext.object_classes_ext set ( asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,origin,preferred_definition,preferred_name,definition_source,
            date_modified, modified_by, deleted_ind) =
(select  ai.ADMIN_STUS_NM_DN, ai.EFF_DT, ai.ADMIN_NOTES, c.nci_idseq, ai.UNTL_DT, decode(ai.CURRNT_VER_IND,1,'Yes',0,'No'),
            ai.ITEM_NM, ai.ORIGIN,nci_cadsr_push.getShortDef(ai.ITEM_DESC),ai.ITEM_LONG_Nm,  ai.def_src,
            ai.LST_UPD_DT,ai.LST_UPD_USR_ID,decode(nvl(ai.fld_delete,0),0,'No',1,'Yes')
    from admin_item ai, admin_item c
    where ai.cntxt_item_id = c.item_id and ai.cntxt_ver_nr = c.ver_nr
        and ai.nci_idseq = vIdseq)
where oc_idseq = vIdseq;

end if;
if vActionType = 'I' then
insert into sbrext.object_classes_ext (oc_idseq, asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,origin,preferred_definition,preferred_name,oc_id,CONDR_IDSEQ,version,definition_source,
            created_by, date_created,date_modified, modified_by, deleted_ind)
select  ai.NCI_IDSEQ, ai.ADMIN_STUS_NM_DN,ai.EFF_DT, ai.ADMIN_NOTES, c.nci_idseq,ai.UNTL_DT, decode(ai.CURRNT_VER_IND,1,'Yes',0,'No'),
            ai.ITEM_NM, ai.ORIGIN,nci_cadsr_push.getShortDef(ai.ITEM_DESC),ai.ITEM_LONG_Nm,ai.ITEM_ID, ai.NCI_IDSEQ,ai.VER_NR,ai.def_src,
            ai.CREAT_USR_ID, ai.CREAT_DT, ai.LST_UPD_DT,ai.LST_UPD_USR_ID ,decode(nvl(ai.fld_delete,0),0,'No',1,'Yes')
    from admin_item ai, admin_item c
    where ai.cntxt_item_id = c.item_id and ai.cntxt_ver_nr = c.ver_nr
        and c.admin_item_typ_id = 8
        and ai.nci_idseq= vIdseq;
end if;
end;

procedure pushProp (vIdseq in char, vItemId in number, vVerNr in number, vActionType in char)
as
begin

pushCondr (vIdseq, vItemId, vVerNr, vActionType);

if vActionType = 'U' then
update sbrext.properties_ext set ( asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,origin,preferred_definition,preferred_name, definition_source,
            date_modified, modified_by, deleted_ind) =
(select  ai.ADMIN_STUS_NM_DN,ai.EFF_DT, ai.ADMIN_NOTES, c.nci_idseq,ai.UNTL_DT, decode(ai.CURRNT_VER_IND,1,'Yes',0,'No'),
            ai.ITEM_NM, ai.origin,nci_cadsr_push.getShortDef(ai.ITEM_DESC),ai.ITEM_LONG_NM, ai.def_src,
            ai.LST_UPD_DT,ai.LST_UPD_USR_ID,decode(nvl(ai.fld_delete,0),0,'No',1,'Yes')
    from admin_item ai, admin_item c
    where ai.cntxt_item_id = c.item_id and ai.cntxt_ver_nr = c.ver_nr
        and ai.nci_idseq = vIdseq)
where prop_idseq = vIdseq;

end if;
if vActionType = 'I' then
insert into sbrext.properties_Ext (prop_idseq, asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,origin,preferred_definition,preferred_name,prop_id,CONDR_IDSEQ, version,definition_source,
            created_by, date_created,date_modified, modified_by, deleted_ind)
select  ai.NCI_IDSEQ, ai.ADMIN_STUS_NM_DN,ai.EFF_DT, ai.ADMIN_NOTES, c.nci_idseq,ai.UNTL_DT, decode(ai.CURRNT_VER_IND,1,'Yes',0,'No'),
            ai.ITEM_NM, ai.ORIGIN,nci_cadsr_push.getShortDef(ai.ITEM_DESC),ai.ITEM_LONG_NM,ai.ITEM_ID, ai.nci_idseq, ai.VER_NR,ai.def_src,
            ai.CREAT_USR_ID, ai.CREAT_DT, ai.LST_UPD_DT,ai.LST_UPD_USR_ID,decode(nvl(ai.fld_delete,0),0,'No',1,'Yes')
    from admin_item ai, admin_item c
    where ai.cntxt_item_id = c.item_id and ai.cntxt_ver_nr = c.ver_nr
            and c.admin_item_typ_id = 8
            and ai.nci_idseq= vIdseq;

end if;
end;



procedure pushAC (vIdseq in char, vItemId in number, vVerNr in number, vActionType in char)
as
v_cnt integer;
begin

if vActionType = 'U' then
update sbr.administered_components set ( asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,origin,preferred_definition,preferred_name,
            date_modified, modified_by, deleted_ind) =
(select  ai.ADMIN_STUS_NM_DN,ai.EFF_DT, ai.ADMIN_NOTES, c.nci_idseq,ai.UNTL_DT, decode(ai.CURRNT_VER_IND,1,'Yes',0,'No'),
            ai.ITEM_NM, ai.origin,nci_cadsr_push.getShortDef (ai.ITEM_DESC),ai.ITEM_LONG_NM,
            ai.LST_UPD_DT,ai.LST_UPD_USR_ID, decode(nvl(ai.fld_delete,0),0,'No',1,'Yes')
    from admin_item ai, admin_item c
    where ai.cntxt_item_id = c.item_id and ai.cntxt_ver_nr = c.ver_nr
        and ai.nci_idseq = vIdseq)
where AC_idseq = vIdseq;

end if;
if vActionType = 'I' then
insert into sbr.administered_components (ac_idseq, asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,origin,preferred_definition,preferred_name,public_id, version,
            created_by, date_created,date_modified, modified_by, actl_name, deleted_ind)
select  ai.NCI_IDSEQ, ai.ADMIN_STUS_NM_DN,ai.EFF_DT, ai.ADMIN_NOTES, c.nci_idseq,ai.UNTL_DT, decode(ai.CURRNT_VER_IND,1,'Yes',0,'No'),
            ai.ITEM_NM, ai.ORIGIN,nci_cadsr_push.getShortDef (ai.ITEM_DESC),ai.ITEM_LONG_NM,ai.ITEM_ID,  ai.VER_NR,
            ai.CREAT_USR_ID, ai.CREAT_DT, ai.LST_UPD_DT,ai.LST_UPD_USR_ID, decode(ai.admin_item_typ_id, 52, 'QUEST_CONTENT', 54, 'QUEST_CONTENT', ok.NCI_CD), decode(nvl(ai.fld_delete,0),0,'No',1,'Yes')
    from admin_item ai, admin_item c, obj_key ok
    where ai.cntxt_item_id = c.item_id and ai.cntxt_ver_nr = c.ver_nr
            and c.admin_item_typ_id = 8
            and ai.nci_idseq= vIdseq
            and ai.admin_item_typ_id = ok.obj_key_id
            and ok.obj_typ_id = 4;

end if;

select count(*) into v_cnt from sbr.ac_registrations where ac_idseq = vIdSeq;

if (v_cnt = 1) then
update sbr.ac_registrations a set (REGISTRATION_STATUS) =
(select nci_stus from stus_mstr, admin_item ai where stus_typ_id = 1 and stus_id = ai.regstr_stus_id
and ai.nci_idseq = vIdSeq )
where a.ac_idseq = vIdSeq;

else
--raise_application_error(-20000, 'Here');

insert into sbr.ac_registrations (ar_idseq, ac_idseq, registration_status, date_created, created_by)
select nci_11179.cmr_guid, vIdSeq, nci_stus, ai.creat_dt, ai.creat_usr_id from stus_mstr, admin_item ai where stus_typ_id = 1 and stus_id = ai.regstr_stus_id
and ai.nci_idseq = vIdSeq and ai.regstr_stus_id is not null ;

end if;
end;


procedure pushDE (vIdseq in char, vItemId in number, vVerNr in number, vActionType in char)
as
begin
if vActionType = 'U' then
update sbr.data_elements set ( asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,ORIGIN,preferred_definition,preferred_name, dec_idseq, vd_idseq,
            date_modified, modified_by, deleted_ind, question) =
(select  ai.ADMIN_STUS_NM_DN,ai.EFF_DT, ai.ADMIN_NOTES, c.nci_idseq,ai.UNTL_DT, decode(ai.CURRNT_VER_IND,1,'Yes',0,'No'),
            ai.ITEM_NM, ai.ORIGIN,nci_cadsr_push.getShortDef(ai.ITEM_DESC),ai.ITEM_LONG_NM,   dec.nci_idseq, vd.nci_idseq,
            ai.LST_UPD_DT,ai.LST_UPD_USR_Id ,decode(nvl(ai.fld_delete,0),0,'No',1,'Yes'), de.pref_quest_txt
    from admin_item ai, admin_item c, de de, admin_item vd,  admin_item dec
    where ai.cntxt_item_id = c.item_id and ai.cntxt_ver_nr = c.ver_nr
            and ai.nci_idseq = vIdseq
            and ai.item_id = de.item_id and ai.ver_nr = de.ver_nr
            and de.val_dom_item_id = vd.item_id and de.val_dom_ver_nr = vd.ver_nr
            and de.de_conc_item_id = dec.item_id and de.de_conc_ver_nr = dec.ver_nr)
where de_idseq = vIdseq;


--- Update Complex_data_elements
for cur2 in (select DERV_MTHD	, DERV_RUL , DERV_TYP_ID, CONCAT_CHAR, DERV_DE_IND from de where item_id = vItemId and ver_nr = vVerNr and derv_de_ind = 1) loop
update sbr.complex_data_elements set (METHODS,RULE, CRTL_NAME, CONCAT_CHAR) =
(select DERV_MTHD, DERV_RUL , ok.nci_cd, CONCAT_CHAR
        from de, obj_key ok
        where item_id = vItemId and ver_nr = vVerNr and de.DERV_TYP_ID = ok.obj_key_id (+))
where p_de_idseq = vIdseq;
end loop;

-- Derivation components update
for cur3 in (select vIdseq, c.nci_idseq c_de_idseq, disp_ord,rel.CREAT_USR_ID, rel.CREAT_DT, rel.LST_UPD_DT,rel.LST_UPD_USR_ID
from nci_admin_item_rel rel, admin_item c where rel_typ_id = 65 and rel.p_item_id = vItemId and p_item_ver_nr = vVerNr and
c.item_id = rel.c_item_id and c.ver_nr = rel.c_item_ver_nr and (vIdseq, c.nci_idseq) in (select p_de_idseq, c_de_idseq from sbr.COMPLEX_DE_RELATIONSHIPS) )loop
update sbr.complex_de_relationships set (DISPLAY_ORDER,DATE_MODIFIED,MODIFIED_BY) =
(select cur3.disp_ord, cur3.lst_upd_dt, cur3.lst_upd_usr_id from dual)
where p_de_idseq = vIdseq and c_de_idseq = cur3.c_de_idseq;
end loop;

for cur4 in (select vIdseq, c.nci_idseq c_de_idseq, disp_ord,rel.CREAT_USR_ID, rel.CREAT_DT, rel.LST_UPD_DT,rel.LST_UPD_USR_ID
from nci_admin_item_rel rel, admin_item c where rel_typ_id = 65 and rel.p_item_id = vItemId and p_item_ver_nr = vVerNr and
c.item_id = rel.c_item_id and c.ver_nr = rel.c_item_ver_nr and (vIdseq, c.nci_idseq) not in (select p_de_idseq, c_de_idseq from sbr.COMPLEX_DE_RELATIONSHIPS)) loop
insert into sbr.complex_de_relationships (p_de_idseq, c_de_idseq, DISPLAY_ORDER,DATE_MODIFIED,MODIFIED_BY,DATE_CREATED, CREATED_BY )
select vIdseq, cur4.c_de_idseq, cur4.disp_ord, cur4.lst_upd_dt, cur4.lst_upd_usr_id, cur4.creat_dt, cur4.creat_usr_id from dual;
end loop;
end if;

if vActionType = 'I' then

insert into sbr.data_elements (de_idseq, asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,ORIGIN,preferred_definition,preferred_name,cde_id,version, dec_idseq, vd_idseq,
            created_by, date_created,date_modified, modified_by, deleted_ind, question)
select  ai.NCI_IDSEQ, ai.ADMIN_STUS_NM_DN,ai.EFF_DT, ai.ADMIN_NOTES, c.nci_idseq,ai.UNTL_DT, decode(ai.CURRNT_VER_IND,1,'Yes',0,'No'),
            ai.ITEM_NM, ai.ORIGIN,nci_cadsr_push.getShortDef(ai.ITEM_DESC),ai.ITEM_LONG_NM,ai.ITEM_ID, ai.VER_NR, dec.nci_idseq, vd.nci_idseq,
            ai.CREAT_USR_ID, ai.CREAT_DT, ai.LST_UPD_DT,ai.LST_UPD_USR_ID ,decode(nvl(ai.fld_delete,0),0,'No',1,'Yes'), de.pref_quest_txt
        from admin_item ai, admin_item c, de de, admin_item vd,  admin_item dec
        where ai.cntxt_item_id = c.item_id and ai.cntxt_ver_nr = c.ver_nr
            and ai.nci_idseq = vIdseq
            and ai.item_id = de.item_id and ai.ver_nr = de.ver_nr
            and de.val_dom_item_id = vd.item_id and de.val_dom_ver_nr = vd.ver_nr
            and de.de_conc_item_id = dec.item_id and de.de_conc_ver_nr = dec.ver_nr
            and ai.nci_idseq= vIdseq;


for cur2 in (select DERV_MTHD	, DERV_RUL , DERV_TYP_ID, CONCAT_CHAR, DERV_DE_IND from de where item_id = vItemId and ver_nr = vVerNr and derv_de_ind = 1) loop
insert into sbr.complex_data_elements (p_de_idseq, METHODS,RULE, CRTL_NAME, CONCAT_CHAR)
select vIdseq, DERV_MTHD, DERV_RUL , ok.nci_cd, CONCAT_CHAR
from de, obj_key ok where item_id = vItemId and ver_nr = vVerNr and de.DERV_TYP_ID = ok.obj_key_id (+);
end loop;

for cur4 in (select vIdseq, c.nci_idseq c_de_idseq, disp_ord,rel.CREAT_USR_ID, rel.CREAT_DT, rel.LST_UPD_DT,rel.LST_UPD_USR_ID
from nci_admin_item_rel rel, admin_item c where rel_typ_id = 65 and rel.p_item_id = vItemId and p_item_ver_nr = vVerNr and
C.item_id = rel.c_item_id and c.ver_nr = rel.c_item_ver_nr ) loop
insert into sbr.complex_de_relationships (p_de_idseq, c_de_idseq, DISPLAY_ORDER,DATE_MODIFIED,MODIFIED_BY,DATE_CREATED, CREATED_BY )
select vIdseq, cur4.c_de_idseq, cur4.disp_ord, cur4.lst_upd_dt, cur4.lst_upd_usr_id, cur4.creat_dt, cur4.creat_usr_id from dual;

end loop;

end if;
end;

procedure pushDEC (vIdseq in char, vItemId in number, vVerNr in number, vActionType in char)
as
begin
if vActionType = 'U' then
update  sbr.data_element_concepts  set ( asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,ORIGIN,preferred_definition,preferred_name, oc_idseq, prop_idseq, cd_idseq,
            date_modified, modified_by, deleted_ind) =
(select  ai.ADMIN_STUS_NM_DN,ai.EFF_DT, ai.ADMIN_NOTES, c.nci_idseq,ai.UNTL_DT, decode(ai.CURRNT_VER_IND,1,'Yes',0,'No'),
            ai.ITEM_NM, ai.ORIGIN,nci_cadsr_push.getShortDef(ai.ITEM_DESC),ai.ITEM_LONG_NM, oc.nci_idseq, prop.nci_idseq, cd.nci_idseq ,
            ai.LST_UPD_DT,ai.LST_UPD_USR_ID,decode(nvl(ai.fld_delete,0),0,'No',1,'Yes')
    from admin_item ai, admin_item c, de_conc dec, admin_item oc, admin_item prop, admin_item cd
    where ai.cntxt_item_id = c.item_id and ai.cntxt_ver_nr = c.ver_nr
            and ai.nci_idseq = vIdseq
            and ai.item_id = dec.item_id and ai.ver_nr = dec.ver_nr
            and dec.obj_cls_item_id = oc.item_id and dec.obj_cls_ver_nr = oc.ver_nr
            and dec.prop_item_id = prop.item_id and dec.prop_ver_nr = prop.ver_nr
            and dec.conc_dom_item_id = cd.item_id and dec.conc_dom_ver_nr = cd.ver_nr)
where dec_idseq = vIdseq;
end if;

if vActionType = 'I' then

insert into sbr.data_element_concepts (dec_idseq, asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,ORIGIN,preferred_definition,preferred_name,dec_id,oc_idseq, prop_idseq, cd_idseq,version,
            created_by, date_created,date_modified, modified_by, deleted_ind)
select  ai.NCI_IDSEQ, ai.ADMIN_STUS_NM_DN,ai.EFF_DT, ai.ADMIN_NOTES, c.nci_idseq,ai.UNTL_DT, decode(ai.CURRNT_VER_IND,1,'Yes',0,'No'),
            ai.ITEM_NM, ai.ORIGIN,nci_cadsr_push.getShortDef(ai.ITEM_DESC),ai.ITEM_LONG_NM,ai.ITEM_ID, oc.nci_idseq, prop.nci_idseq, cd.nci_idseq,ai.VER_NR,
            ai.CREAT_USR_ID, ai.CREAT_DT, ai.LST_UPD_DT,ai.LST_UPD_USR_ID ,decode(nvl(ai.fld_delete,0),0,'No',1,'Yes')
        from admin_item ai, admin_item c, de_conc dec, admin_item oc, admin_item prop, admin_item cd
        where ai.cntxt_item_id = c.item_id and ai.cntxt_ver_nr = c.ver_nr
            and ai.nci_idseq = vIdseq
            and ai.item_id = dec.item_id and ai.ver_nr = dec.ver_nr
            and dec.obj_cls_item_id = oc.item_id and dec.obj_cls_ver_nr = oc.ver_nr
            and dec.prop_item_id = prop.item_id and dec.prop_ver_nr = prop.ver_nr
            and dec.conc_dom_item_id = cd.item_id and dec.conc_dom_ver_nr = cd.ver_nr
            and ai.nci_idseq= vIdseq;
end if;
end;

procedure pushConcept (vIdseq in char, vItemId in number, vVerNr in number, vActionType in char)
as
begin
if vActionType = 'U' then
update sbrext.concepts_ext set ( asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,origin,preferred_definition,preferred_name, evs_source, definition_source,
            date_modified, modified_by) =
(select  ai.ADMIN_STUS_NM_DN,ai.EFF_DT, ai.ADMIN_NOTES, c.nci_idseq,ai.UNTL_DT, decode(ai.CURRNT_VER_IND,1,'Yes',0,'No'),
            ai.ITEM_NM, ai.ORIGIN,nci_cadsr_push.getShortDef(ai.ITEM_DESC),ai.ITEM_LONG_Nm, ok.NCI_CD,  ai.def_src,
            ai.LST_UPD_DT,ai.LST_UPD_USR_ID
        from admin_item ai, admin_item c, obj_key ok, cncpt con
        where ai.cntxt_item_id = c.item_id and ai.cntxt_ver_nr = c.ver_nr
            and ai.nci_idseq = vIdseq
            and ai.item_id = con.item_id and ai.ver_nr = con.ver_nr
            and con.evs_src_id = ok.obj_key_id (+))
where con_idseq = vIdseq;

end if;

if vActionType = 'I' then
insert into sbr.concepts_ext (con_idseq, asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,origin,preferred_definition,preferred_name,con_id, evs_source,definition_source,version,
            created_by, date_created,date_modified, modified_by)
select  ai.NCI_IDSEQ, ai.ADMIN_STUS_NM_DN,ai.EFF_DT, ai.ADMIN_NOTES, c.nci_idseq,ai.UNTL_DT, decode(ai.CURRNT_VER_IND,1,'Yes',0,'No'),
            ai.ITEM_NM, ai.ORIGIN,nci_cadsr_push.getShortDef(ai.ITEM_DESC),ai.ITEM_LONG_Nm,ai.ITEM_ID, ok.nci_cd, ai.def_src,ai.VER_NR,
            ai.CREAT_USR_ID, ai.CREAT_DT, ai.LST_UPD_DT,ai.LST_UPD_USR_ID
        from admin_item ai, admin_item c, cncpt con, obj_key ok
        where ai.cntxt_item_id = c.item_id and ai.cntxt_ver_nr = c.ver_nr
            and c.admin_item_typ_id = 8
            and con.evs_src_id = ok.obj_key_id (+)
            and con.item_id = ai.item_id and con.ver_nr = ai.ver_nr
            and ai.nci_idseq= vIdseq;

end if;
end;

procedure pushVD (vIdseq in char, vItemId in number, vVerNr in number, vActionType in char)
as
begin


pushCondr (vIdseq, vItemId, vVerNr, vActionType);

if vActionType = 'U' then

update sbr.value_domains set ( asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
                long_name,ORIGIN,preferred_definition,preferred_name, high_value_num,low_value_num, max_length_num, min_length_num,
                decimal_place,rep_idseq, cd_idseq,uoml_name, dtl_name, forml_name,vd_type_flag,
                date_modified, modified_by, deleted_ind) =
(select  ai.ADMIN_STUS_NM_DN,ai.EFF_DT, ai.ADMIN_NOTES, c.nci_idseq,ai.UNTL_DT, decode(ai.CURRNT_VER_IND,1,'Yes',0,'No'),
                ai.ITEM_NM, ai.ORIGIN,nci_cadsr_push.getShortDef(ai.ITEM_DESC),ai.ITEM_LONG_NM,  VAL_DOM_HIGH_VAL_NUM,VAL_DOM_LOW_VAL_NUM,VAL_DOM_MAX_CHAR,VAL_DOM_MIN_CHAR,
                NCI_DEC_PREC, rc.nci_idseq, cd.nci_idseq, uom.nci_cd, dt.nci_cd, fmt.nci_cd,decode(VAL_DOM_TYP_ID, 17,'E' ,18, 'N'),
                ai.LST_UPD_DT,ai.LST_UPD_USR_ID ,decode(nvl(ai.fld_delete,0),0,'No',1,'Yes')
            from admin_item ai, admin_item c, value_dom vd, admin_item rc,  admin_item cd, fmt, uom, data_typ dt
            where ai.cntxt_item_id = c.item_id and ai.cntxt_ver_nr = c.ver_nr
                and ai.nci_idseq = vIdseq
                and ai.item_id = vd.item_id and ai.ver_nr = vd.ver_nr
                and vd.conc_dom_item_id = cd.item_id and Vd.conc_dom_ver_nr = cd.ver_nr
                and vd.rep_cls_item_id = rc.item_id (+) and vd.rep_cls_ver_nr = rc.ver_nr (+)
                and vd.val_dom_fmt_id = fmt.fmt_id (+)
                and vd.uom_id = uom.uom_id (+)
                and vd.dttype_id = dt.dttype_id (+))
where vd_idseq = vIdseq;
end if;
if vActionType = 'I' then

insert into sbr.value_domains (vd_idseq, asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,ORIGIN,preferred_definition,preferred_name,vd_id,
            high_value_num,low_value_num, max_length_num, min_length_num,
            decimal_place,rep_idseq, cd_idseq,uoml_name, dtl_name, forml_name,vd_type_flag,version,
            created_by, date_created,date_modified, modified_by, deleted_ind)
select  ai.NCI_IDSEQ, ai.ADMIN_STUS_NM_DN,ai.EFF_DT, ai.ADMIN_NOTES, c.nci_idseq,ai.UNTL_DT, decode(ai.CURRNT_VER_IND,1,'Yes',0,'No'),
            ai.ITEM_NM, ai.ORIGIN,nci_cadsr_push.getShortDef(ai.ITEM_DESC),ai.ITEM_LONG_NM,ai.ITEM_ID,
            VAL_DOM_HIGH_VAL_NUM,VAL_DOM_LOW_VAL_NUM,VAL_DOM_MAX_CHAR,VAL_DOM_MIN_CHAR,
            NCI_DEC_PREC, rc.nci_idseq, cd.nci_idseq, uom.nci_cd, dt.nci_cd, fmt.nci_cd,decode(Val_dom_typ_id, 17,'E' ,18, 'N')ai,ai.VER_NR,
            ai.CREAT_USR_ID, ai.CREAT_DT, ai.LST_UPD_DT,ai.LST_UPD_USR_ID ,decode(nvl(ai.fld_delete,0),0,'No',1,'Yes')
        from admin_item ai, admin_item c, value_dom vd, admin_item rc,  admin_item cd,  fmt, uom, data_typ dt
        where ai.cntxt_item_id = c.item_id and ai.cntxt_ver_nr = c.ver_nr
            and ai.nci_idseq = vIdseq
            and ai.item_id = vd.item_id and ai.ver_nr = vd.ver_nr
            and vd.conc_dom_item_id = cd.item_id and Vd.conc_dom_ver_nr = cd.ver_nr
            and vd.rep_cls_item_id = rc.item_id (+) and vd.rep_cls_ver_nr = rc.ver_nr (+)
            and vd.val_dom_fmt_id = fmt.fmt_id (+)
            and vd.uom_id = uom.uom_id (+)
            and vd.dttype_id = dt.dttype_id (+)
            and ai.nci_idseq= vIdseq;

end if;
end;
procedure pushRC (vIdseq in char, vItemId in number, vVerNr in number, vActionType in char)
as
begin

pushCondr (vIdseq, vItemId, vVerNr, vActionType);

if vActionType = 'U' then
update sbrext.representations_ext set ( asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,origin,preferred_definition,preferred_name, definition_source,
            date_modified, modified_by, deleted_ind) =
(select  ai.ADMIN_STUS_NM_DN,ai.EFF_DT, ai.ADMIN_NOTES, c.nci_idseq,ai.UNTL_DT, decode(ai.CURRNT_VER_IND,1,'Yes',0,'No'),
            ai.ITEM_NM, ai.ORIGIN,nci_cadsr_push.getShortDef(ai.ITEM_DESC),ai.ITEM_LONG_Nm, ai.def_src,
            ai.LST_UPD_DT,ai.LST_UPD_USR_ID ,decode(nvl(ai.fld_delete,0),0,'No',1,'Yes')
        from admin_item ai, admin_item c
        where ai.cntxt_item_id = c.item_id and ai.cntxt_ver_nr = c.ver_nr
            and ai.nci_idseq = vIdseq)
where rep_idseq = vIdseq;

end if;
if vActionType = 'I' then
insert into sbrext.representations_ext (rep_idseq,asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,origin,preferred_definition,preferred_name,rep_id,CONDR_IDSEQ,version,definition_source,
            created_by, date_created,date_modified, modified_by, deleted_ind)
select  ai.NCI_IDSEQ, ai.ADMIN_STUS_NM_DN,ai.EFF_DT, ai.ADMIN_NOTES, c.nci_idseq,ai.UNTL_DT, decode(ai.CURRNT_VER_IND,1,'Yes',0,'No'),
            ai.ITEM_NM, ai.ORIGIN,nci_cadsr_push.getShortDef(ai.ITEM_DESC),ai.ITEM_LONG_Nm,ai.ITEM_ID, ai.nci_idseq,ai.VER_NR,ai.def_src,
            ai.CREAT_USR_ID, ai.CREAT_DT, ai.LST_UPD_DT,ai.LST_UPD_USR_ID ,decode(nvl(ai.fld_delete,0),0,'No',1,'Yes')
        from admin_item ai, admin_item c
        where ai.cntxt_item_id = c.item_id and ai.cntxt_ver_nr = c.ver_nr
            and c.admin_item_typ_id = 8
            and ai.nci_idseq= vIdseq;

end if;
end;

procedure pushCD (vIdseq in char, vItemId in number, vVerNr in number, vActionType in char)
as
begin


pushCondr (vIdseq, vItemId, vVerNr, vActionType);

if vActionType = 'U' then
update sbr.conceptual_domains set ( asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,origin,preferred_definition,preferred_name, dimensionality,
            date_modified, modified_by, deleted_ind) =
(select  ai.ADMIN_STUS_NM_DN,ai.EFF_DT, ai.ADMIN_NOTES, c.nci_idseq,ai.UNTL_DT, decode(ai.CURRNT_VER_IND,1,'Yes',0,'No'),
            ai.ITEM_NM, ai.ORIGIN,nci_cadsr_push.getShortDef (ai.ITEM_DESC),ai.ITEM_LONG_Nm, DIMNSNLTY,
            ai.LST_UPD_DT,ai.LST_UPD_USR_ID ,decode(nvl(ai.fld_delete,0),0,'No',1,'Yes')
        from admin_item ai, admin_item c, conc_dom cd
        where ai.cntxt_item_id = c.item_id and ai.cntxt_ver_nr = c.ver_nr
            and ai.item_id = cd.item_id and ai.ver_nr = cd.ver_nr
            and ai.nci_idseq = vIdseq)
where cd_idseq = vIdseq;

end if;
if vActionType = 'I' then
insert into sbr.conceptual_domains (cd_idseq, asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,origin,preferred_definition,preferred_name,cd_id,version,dimensionality,
            created_by, date_created,date_modified, modified_by, deleted_ind)
select  ai.NCI_IDSEQ, ai.ADMIN_STUS_NM_DN,ai.EFF_DT, ai.ADMIN_NOTES, c.nci_idseq,ai.UNTL_DT, decode(ai.CURRNT_VER_IND,1,'Yes',0,'No'),
            ai.ITEM_NM, ai.ORIGIN,nci_cadsr_push.getShortDef(ai.ITEM_DESC),ai.ITEM_LONG_Nm,ai.ITEM_ID, ai.VER_NR,DIMNSNLTY,
            ai.CREAT_USR_ID, ai.CREAT_DT, ai.LST_UPD_DT,ai.LST_UPD_USR_ID ,decode(nvl(ai.fld_delete,0),0,'No',1,'Yes')
        from admin_item ai, admin_item c, conc_dom cd
        where ai.cntxt_item_id = c.item_id and ai.cntxt_ver_nr = c.ver_nr
        and c.admin_item_typ_id = 8
        and cd.item_id = ai.item_id and cd.ver_nr = ai.ver_nr
        and ai.nci_idseq= vIdseq;

end if;
end;


procedure pushForm (vIdseq in char, vItemId in number, vVerNr in number, vActionType in char)
as
v_id number;
v_cnt integer;
v_hdridseq  char(36);
v_ftridseq  char(36);
begin
if vActionType = 'U' then
--raise_application_error(-20000, vItemId);
update sbrext.quest_contents_ext set ( qtl_name,  qcdl_name,asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,origin,preferred_definition,preferred_name,qc_id,
            created_by, date_created,date_modified, modified_by, deleted_ind) =
(select   decode(frm.form_typ_id,70, 'CRF', 71, 'TEMPLATE') , ok.nci_cd, ai.ADMIN_STUS_NM_DN, ai.EFF_DT, ai.ADMIN_NOTES, c.nci_idseq,ai.UNTL_DT, decode(ai.CURRNT_VER_IND,1,'Yes',0,'No'),
            ai.ITEM_NM, ai.ORIGIN,nci_cadsr_push.getShortDef(ai.ITEM_DESC),ai.ITEM_LONG_Nm,ai.ITEM_ID,
            ai.CREAT_USR_ID, ai.CREAT_DT, ai.LST_UPD_DT,ai.LST_UPD_USR_ID ,decode(nvl(ai.fld_delete,0),0,'No',1,'Yes')
        from admin_item ai, admin_item c,  nci_form frm, obj_key ok
        where ai.cntxt_item_id = c.item_id and ai.cntxt_ver_nr = c.ver_nr
            and ai.item_id = frm.item_id and ai.ver_nr = frm.ver_nr
            and frm.catgry_id = ok.obj_key_id (+)
            and c.admin_item_typ_id = 8
            and ai.nci_idseq= vIdseq)
            where qc_idseq = vIdseq;

end if;
if vActionType = 'I' then
--raise_application_error(-20000, vItemId);
for curfrm in (select  ai.NCI_IDSEQ, decode(frm.form_typ_id,70, 'CRF', 71, 'TEMPLATE') FORM_TYP_ID ,
ok.nci_cd, ai.ADMIN_STUS_NM_DN, ai.EFF_DT, ai.ADMIN_NOTES, c.nci_idseq cntxt_idseq,ai.UNTL_DT, decode(ai.CURRNT_VER_IND,1,'Yes',0,'No') CURRNT_VER_IND ,
            ai.ITEM_NM, ai.ORIGIN,nci_cadsr_push.getShortDef(ai.ITEM_DESC) ITEM_DESC,ai.ITEM_LONG_Nm,ai.ITEM_ID, ai.VER_NR, frm.ftr_instr, frm.hdr_instr,
            ai.CREAT_USR_ID, ai.CREAT_DT, ai.LST_UPD_DT,ai.LST_UPD_USR_ID ,decode(nvl(ai.fld_delete,0),0,'No',1,'Yes') FLD_DELETE, 'Yes',1
        from admin_item ai, admin_item c,  nci_form frm, obj_key ok
        where ai.cntxt_item_id = c.item_id and ai.cntxt_ver_nr = c.ver_nr
            and ai.item_id = frm.item_id and ai.ver_nr = frm.ver_nr
            and frm.catgry_id = ok.obj_key_id (+)
            and c.admin_item_typ_id = 8
            and ai.nci_idseq= vIdseq) loop

 insert into sbrext.quest_contents_ext (qc_idseq,dn_crf_idseq, qtl_name,  qcdl_name,asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,origin,preferred_definition,preferred_name,qc_id,version,
            created_by, date_created,date_modified, modified_by, deleted_ind, display_ind, display_order)
values ( curfrm.NCI_IDSEQ,curfrm.nci_idseq, curfrm.form_typ_id, curfrm.nci_cd, curfrm.ADMIN_STUS_NM_DN, curfrm.EFF_DT, curfrm.ADMIN_NOTES, curfrm.cntxt_idseq,
curfrm.UNTL_DT, curfrm.CURRNT_VER_IND,
            curfrm.ITEM_NM, curfrm.ORIGIN,substr(curfrm.ITEM_DESC,1,2000),curfrm.ITEM_LONG_Nm,curfrm.ITEM_ID, curfrm.VER_NR,
            curfrm.CREAT_USR_ID, curfrm.CREAT_DT, curfrm.LST_UPD_DT,curfrm.LST_UPD_USR_ID ,curfrm.fld_delete, 'Yes',1);
          end loop;
end if;




select count(*) into v_cnt from sbrext.quest_contents_ext where dn_crf_idseq = vIdSeq and qtl_name = 'FORM_INSTR';
if (v_cnt = 0) then
v_id := nci_11179.getItemid;
v_hdridseq := nci_11179.cmr_guid;
for curfrm in (select  ai.NCI_IDSEQ,
 ai.ADMIN_STUS_NM_DN, ai.EFF_DT, ai.ADMIN_NOTES, c.nci_idseq cntxt_idseq,ai.UNTL_DT, decode(ai.CURRNT_VER_IND,1,'Yes',0,'No') CURRNT_VER_IND ,
            ai.ITEM_NM, ai.ORIGIN,nci_cadsr_push.getShortDef(ai.ITEM_DESC) ITEM_DESC,ai.ITEM_LONG_Nm,ai.ITEM_ID, ai.VER_NR, frm.ftr_instr, frm.hdr_instr,
            ai.CREAT_USR_ID, ai.CREAT_DT, ai.LST_UPD_DT,ai.LST_UPD_USR_ID ,decode(nvl(ai.fld_delete,0),0,'No',1,'Yes') FLD_DELETE, 'Yes',1
        from admin_item ai, admin_item c, nci_form frm
        where ai.cntxt_item_id = c.item_id and ai.cntxt_ver_nr = c.ver_nr
            and ai.item_id = frm.item_id and ai.ver_nr = frm.ver_nr
            and c.admin_item_typ_id = 8
            and ai.nci_idseq= vIdseq) loop
insert into sbrext.quest_contents_ext (qc_idseq, dn_crf_idseq, qtl_name, asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,origin,preferred_definition,
            preferred_name,qc_id,
            version,
            created_by, date_created,date_modified, modified_by, deleted_ind,display_ind, display_order)
values (v_hdridseq, curfrm.nci_idseq, 'FORM_INSTR' , curfrm.ADMIN_STUS_NM_DN, curfrm.EFF_DT, curfrm.ADMIN_NOTES, curfrm.cntxt_idseq,
curfrm.UNTL_DT, curfrm.CURRNT_VER_IND,
            curfrm.ITEM_NM, curfrm.ORIGIN,nvl(curfrm.hdr_instr, ' '),
            v_id,v_id,
            curfrm.VER_NR,
            curfrm.CREAT_USR_ID, curfrm.CREAT_DT, curfrm.LST_UPD_DT,curfrm.LST_UPD_USR_ID ,curfrm.fld_delete, 'Yes', 1);

       insert into sbr.administered_components (ac_idseq, actl_name, asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,origin,preferred_definition,
            preferred_name,public_id,
            version,
            created_by, date_created,date_modified, modified_by, deleted_ind)
values ( v_hdridseq, 'QUEST_CONTENT' , curfrm.ADMIN_STUS_NM_DN, curfrm.EFF_DT, curfrm.ADMIN_NOTES, curfrm.cntxt_idseq,curfrm.UNTL_DT, curfrm.CURRNT_VER_IND,
            curfrm.ITEM_NM, curfrm.ORIGIN,nvl(curfrm.hdr_instr, ' '),
            v_id,v_id,
            curfrm.VER_NR,
            curfrm.CREAT_USR_ID, curfrm.CREAT_DT, curfrm.LST_UPD_DT,curfrm.LST_UPD_USR_ID ,curfrm.fld_delete);

insert into sbrext.qc_recs_ext (QR_IDSEQ,P_QC_IDSEQ,C_QC_IDSEQ,DISPLAY_ORDER,RL_NAME,DATE_CREATED,CREATED_BY,DATE_MODIFIED,MODIFIED_BY)
select nci_11179.cmr_guid,curfrm.nci_idseq, v_hdridseq, 1 ,'FORM_INSTRUCTION',curfrm.CREAT_DT, curfrm.CREAT_USR_ID,  curfrm.LST_UPD_DT,curfrm.LST_UPD_USR_ID from dual;
end loop;
else
            update sbrext.quest_contents_ext set ( preferred_definition,
            date_modified, modified_by) =
(select  nvl(frm.hdr_instr, ' ' ), frm.LST_UPD_DT,frm.LST_UPD_USR_ID
        from admin_item ai,  nci_form frm
        where ai.item_id = frm.item_id and ai.ver_nr = frm.ver_nr
            and ai.nci_idseq= vIdseq)
            where dn_crf_idseq = vIdseq and qtl_name ='FORM_INSTR';
    end if;
                  --      and frm.hdr_instr is not null;



         select count(*) into v_cnt from sbrext.quest_contents_ext where dn_crf_idseq = vIdSeq and qtl_name = 'FOOTER';

         if (v_cnt = 0) then
v_id := nci_11179.getItemid;
v_ftridseq := nci_11179.cmr_guid;
for curfrm in (select  ai.NCI_IDSEQ,
 ai.ADMIN_STUS_NM_DN, ai.EFF_DT, ai.ADMIN_NOTES, c.nci_idseq cntxt_idseq,ai.UNTL_DT, decode(ai.CURRNT_VER_IND,1,'Yes',0,'No') CURRNT_VER_IND ,
            ai.ITEM_NM, ai.ORIGIN,nci_cadsr_push.getShortDef(ai.ITEM_DESC) ITEM_DESC,ai.ITEM_LONG_Nm,ai.ITEM_ID, ai.VER_NR, frm.ftr_instr, frm.hdr_instr,
            ai.CREAT_USR_ID, ai.CREAT_DT, ai.LST_UPD_DT,ai.LST_UPD_USR_ID ,decode(nvl(ai.fld_delete,0),0,'No',1,'Yes') FLD_DELETE, 'Yes',1
        from admin_item ai, admin_item c, nci_form frm
        where ai.cntxt_item_id = c.item_id and ai.cntxt_ver_nr = c.ver_nr
            and ai.item_id = frm.item_id and ai.ver_nr = frm.ver_nr
            and c.admin_item_typ_id = 8
            and ai.nci_idseq= vIdseq) loop
insert into sbrext.quest_contents_ext (qc_idseq, dn_crf_idseq, qtl_name, asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,origin,preferred_definition,
            preferred_name,qc_id,
            version,
            created_by, date_created,date_modified, modified_by, deleted_ind,display_ind, display_order)
values (  v_ftridseq, curfrm.nci_idseq, 'FOOTER' , curfrm.ADMIN_STUS_NM_DN, curfrm.EFF_DT, curfrm.ADMIN_NOTES,curfrm.cntxt_idseq,
         curfrm.UNTL_DT, curfrm.CURRNT_VER_IND,
            curfrm.ITEM_NM, curfrm.ORIGIN,nvl(curfrm.ftr_instr, ' '),
            v_id,v_id,
            curfrm.VER_NR,
            curfrm.CREAT_USR_ID, curfrm.CREAT_DT, curfrm.LST_UPD_DT,curfrm.LST_UPD_USR_ID ,curfrm.fld_delete, 'Yes', 1);

            --and frm.ftr_instr is not null;


         insert into sbr.administered_components (ac_idseq, actl_name, asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,origin,preferred_definition,
            preferred_name,public_id,
            version,
            created_by, date_created,date_modified, modified_by, deleted_ind)
            values (  v_ftridseq,  'QUEST_CONTENT' , curfrm.ADMIN_STUS_NM_DN, curfrm.EFF_DT, curfrm.ADMIN_NOTES,curfrm.cntxt_idseq,curfrm.UNTL_DT, curfrm.CURRNT_VER_IND,
            curfrm.ITEM_NM, curfrm.ORIGIN,nvl(curfrm.ftr_instr, ' ' ),
            v_id,v_id,
            curfrm.VER_NR,
            curfrm.CREAT_USR_ID, curfrm.CREAT_DT, curfrm.LST_UPD_DT,curfrm.LST_UPD_USR_ID,curfrm.fld_delete);


insert into sbrext.qc_recs_ext (QR_IDSEQ,P_QC_IDSEQ,C_QC_IDSEQ,DISPLAY_ORDER,RL_NAME,DATE_CREATED,CREATED_BY,DATE_MODIFIED,MODIFIED_BY)
select nci_11179.cmr_guid,curfrm.nci_idseq, v_ftridseq, 2 ,'FORM_INSTRUCTION',curfrm.CREAT_DT, curfrm.CREAT_USR_ID,  curfrm.LST_UPD_DT,curfrm.LST_UPD_USR_ID from dual;

            end loop;
      else
               update sbrext.quest_contents_ext set ( preferred_definition,
            date_modified, modified_by) =
(select  nvl(frm.ftr_instr, ' ' ), frm.LST_UPD_DT,frm.LST_UPD_USR_ID
        from admin_item ai,  nci_form frm
        where ai.item_id = frm.item_id and ai.ver_nr = frm.ver_nr
            and ai.nci_idseq= vIdseq)
            where dn_crf_idseq = vIdseq and qtl_name ='FOOTER';

      end if;


/*
insert into sbrext.qc_recs_ext (QR_IDSEQ,P_QC_IDSEQ,C_QC_IDSEQ,DISPLAY_ORDER,RL_NAME,DATE_CREATED,CREATED_BY,DATE_MODIFIED,MODIFIED_BY)
select nci_11179.cmr_guid,curmod.mod_idseq, v_idseq, curmod.disp_ord ,'MODULE_INSTRUCTION', curmod.CREAT_USR_ID, curmod.CREAT_DT, curmod.LST_UPD_DT,curmod.LST_UPD_USR_ID from dual;
*/




end;

procedure pushProt (vIdseq in char, vItemId in number, vVerNr in number, vActionType in char)
as
begin
if vActionType = 'U' then
update sbrext.protocols_ext set ( asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,origin,preferred_definition,preferred_name, CHANGE_TYPE,CHANGE_NUMBER,REVIEWED_DATE,REVIEWED_BY,APPROVED_DATE, APPROVED_BY, type,
            protocol_id,     LEAD_ORG,               PHASE,
            date_modified, modified_by, deleted_ind) =
(select  ai.ADMIN_STUS_NM_DN,ai.EFF_DT, ai.ADMIN_NOTES, c.nci_idseq,ai.UNTL_DT, decode(ai.CURRNT_VER_IND,1,'YES',0,'NO'),
            ai.ITEM_NM, ai.ORIGIN,nci_cadsr_push.getShortDef(ai.ITEM_DESC),ai.ITEM_LONG_Nm, CHNG_TYP,	CHNG_NBR,	RVWD_DT,	RVWD_USR_ID, APPRVD_DT,	APPRVD_USR_ID, ok.nci_cd,
            PROTCL_ID,    org.ORG_NM,                     PROTCL_PHASE,
            ai.LST_UPD_DT,ai.LST_UPD_USR_ID ,decode(nvl(ai.fld_delete,0),0,'No',1,'Yes')
        from admin_item ai, admin_item c, obj_key ok, nci_protcl con, nci_org org
        where ai.cntxt_item_id = c.item_id and ai.cntxt_ver_nr = c.ver_nr
            and ai.nci_idseq = vIdseq
            and ai.item_id = con.item_id and ai.ver_nr = con.ver_nr
            and con.protcl_typ_id = ok.obj_key_id (+)
            and proto_idseq = ai.nci_idseq
            and con.LEAD_ORG_ID =org.ENTTY_ID(+)) ;

end if;
if vActionType = 'I' then

insert into sbrext.protocols_ext (proto_idseq, asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,origin,preferred_definition,preferred_name,proto_id, type, CHANGE_TYPE,CHANGE_NUMBER,REVIEWED_DATE,REVIEWED_BY,APPROVED_DATE, APPROVED_BY,version,
                     protocol_id,     LEAD_ORG,               PHASE,
            created_by, date_created,date_modified, modified_by, deleted_ind)
select  ai.NCI_IDSEQ, ai.ADMIN_STUS_NM_DN,ai.EFF_DT, ai.ADMIN_NOTES, c.nci_idseq,ai.UNTL_DT, decode(ai.CURRNT_VER_IND,1,'Yes',0,'No'),
            ai.ITEM_NM, ai.ORIGIN,nci_cadsr_push.getShortDef(ai.ITEM_DESC),ai.ITEM_LONG_Nm,ai.ITEM_ID, ok.nci_cd, 	CHNG_TYP,	CHNG_NBR,	RVWD_DT,	RVWD_USR_ID, APPRVD_DT,	APPRVD_USR_ID,ai.VER_NR,
           PROTCL_ID,  org.ORG_NM,  PROTCL_PHASE,
            ai.CREAT_USR_ID, ai.CREAT_DT, ai.LST_UPD_DT,ai.LST_UPD_USR_ID ,decode(nvl(ai.fld_delete,0),0,'No',1,'Yes')
        from admin_item ai, admin_item c, nci_protcl con, obj_key ok, nci_org org
        where ai.cntxt_item_id = c.item_id and ai.cntxt_ver_nr = c.ver_nr
            and c.admin_item_typ_id = 8
            and con.protcl_typ_id = ok.obj_key_id (+)
            and con.item_id = ai.item_id and con.ver_nr = ai.ver_nr
            and ai.nci_idseq= vIdseq
             and con.LEAD_ORG_ID =org.ENTTY_ID(+);

end if;
end;

procedure pushVM (vIdseq in char, vItemId in number, vVerNr in number, vActionType in char)
as
begin

pushCondr (vIdseq, vItemId, vVerNr, vActionType);

if vActionType = 'U' then
update sbrext.value_meanings set ( asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,origin,preferred_definition,preferred_name,description, comments,CONDR_IDSEQ,definition_source,
            date_modified, modified_by, deleted_ind) =
(select  ai.ADMIN_STUS_NM_DN,ai.EFF_DT, ai.ADMIN_NOTES, c.nci_idseq,ai.UNTL_DT, decode(ai.CURRNT_VER_IND,1,'Yes',0,'No'),
            ai.ITEM_NM, ai.ORIGIN,nci_cadsr_push.getShortDef(ai.ITEM_DESC),ai.ITEM_LONG_Nm, vm_desc_txt, vm_cmnts,ai.nci_idseq,ai.DEF_SRC,
            ai.LST_UPD_DT,ai.LST_UPD_USR_ID ,decode(nvl(ai.fld_delete,0),0,'No',1,'Yes')
        from admin_item ai, admin_item c,   nci_val_mean con
        where ai.cntxt_item_id = c.item_id and ai.cntxt_ver_nr = c.ver_nr
            and ai.nci_idseq = vIdseq
            and ai.item_id = con.item_id and ai.ver_nr = con.ver_nr)
where vm_idseq = vIdseq;

end if;
if vActionType = 'I' then
insert into sbr.value_meanings (vm_idseq, asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,origin,preferred_definition,preferred_name,vm_id, description, comments,version,condr_idseq,definition_source,
            created_by, date_created,date_modified, modified_by, deleted_ind, short_meaning)
select  ai.NCI_IDSEQ, ai.ADMIN_STUS_NM_DN,ai.EFF_DT, ai.ADMIN_NOTES, c.nci_idseq,ai.UNTL_DT, decode(ai.CURRNT_VER_IND,1,'Yes',0,'No'),
            ai.ITEM_NM, ai.ORIGIN,nci_cadsr_push.getShortDef(ai.ITEM_DESC),ai.ITEM_LONG_Nm,ai.ITEM_ID, vm_desc_txt, vm_cmnts ,ai.VER_NR, ai.nci_idseq,ai.DEF_SRC,
            ai.CREAT_USR_ID, ai.CREAT_DT, ai.LST_UPD_DT,ai.LST_UPD_USR_ID ,decode(nvl(ai.fld_delete,0),0,'No',1,'Yes'), ai.item_nm
        from admin_item ai, admin_item c, NCI_val_mean con
        where ai.cntxt_item_id = c.item_id and ai.cntxt_ver_nr = c.ver_nr
            and c.admin_item_typ_id = 8
            and con.item_id = ai.item_id and con.ver_nr = ai.ver_nr
            and ai.nci_idseq= vIdseq;


end if;
end;

procedure pushOCRecs (vIdseq in char, vItemId in number, vVerNr in number, vActionType in char)
as
begin
if vActionType = 'U' then
update sbrext.oc_recs_ext set ( asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,origin,preferred_definition,preferred_name,date_modified, modified_by,
            t_oc_idseq, s_oc_idseq, rl_name, source_role, target_role, direction, source_low_multiplicity,
            source_high_multiplicity,target_low_multiplicity,target_high_multiplicity,display_order,dimensionality,array_ind ) =
(select  ai.ADMIN_STUS_NM_DN,ai.EFF_DT, ai.ADMIN_NOTES, c.nci_idseq,ai.UNTL_DT, decode(ai.CURRNT_VER_IND,1,'Yes',0,'No'),
            ai.ITEM_NM, ai.ORIGIN,nci_cadsr_push.getShortDef(ai.ITEM_DESC),ai.ITEM_LONG_Nm, ai.LST_UPD_DT,ai.LST_UPD_USR_ID,
            toc.nci_idseq, soc.nci_idseq, REL_TYP_NM,SRC_ROLE,TRGT_ROLE,DRCTN,SRC_LOW_MULT,SRC_HIGH_MULT,
            TRGT_LOW_MULT,TRGT_HIGH_MULT,DISP_ORD,DIMNSNLTY,ARRAY_IND
        from admin_item ai, admin_item c,   admin_item toc, admin_item soc, nci_oc_recs ocr
        where ai.cntxt_item_id = c.item_id and ai.cntxt_ver_nr = c.ver_nr
            and ai.nci_idseq = vIdseq
            and ai.item_id = ocr.item_id and ai.ver_nr = ocr.ver_nr
            and ocr.trgt_obj_cls_item_id = toc.item_id and ocr.trgt_obj_cls_ver_nr = toc.ver_nr
            and ocr.src_obj_cls_item_id = soc.item_id and ocr.src_obj_cls_ver_nr = soc.ver_nr)
where ocr_idseq = vIdseq;

end if;
if vActionType = 'I' then
insert into sbrext.oc_recs_ext (ocr_idseq, asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,origin,preferred_definition,preferred_name,ocr_id, version,
            created_by, date_created,date_modified, modified_by,
            t_oc_idseq, s_oc_idseq, rl_name, source_role, target_role, direction, source_low_multiplicity,
            source_high_multiplicity,target_low_multiplicity,target_high_multiplicity,display_order,dimensionality,array_ind )
select  ai.NCI_IDSEQ, ai.ADMIN_STUS_NM_DN,ai.EFF_DT, ai.ADMIN_NOTES, c.nci_idseq,ai.UNTL_DT, decode(ai.CURRNT_VER_IND,1,'Yes',0,'No'),
            ai.ITEM_NM, ai.ORIGIN,nci_cadsr_push.getShortDef(ai.ITEM_DESC),ai.ITEM_LONG_Nm,ai.ITEM_ID, ai.VER_NR,
            ai.CREAT_USR_ID, ai.CREAT_DT, ai.LST_UPD_DT,ai.LST_UPD_USR_ID,
            toc.nci_idseq, soc.nci_idseq, REL_TYP_NM,SRC_ROLE,TRGT_ROLE,DRCTN,SRC_LOW_MULT,SRC_HIGH_MULT,
            TRGT_LOW_MULT,TRGT_HIGH_MULT,DISP_ORD,DIMNSNLTY,ARRAY_IND
        from admin_item ai, admin_item c,   admin_item toc, admin_item soc, nci_oc_recs ocr
        where ai.cntxt_item_id = c.item_id and ai.cntxt_ver_nr = c.ver_nr
            and ai.nci_idseq = vIdseq
            and ai.item_id = ocr.item_id and ai.ver_nr = ocr.ver_nr
            and ocr.trgt_obj_cls_item_id = toc.item_id and ocr.trgt_obj_cls_ver_nr = toc.ver_nr
            and ocr.src_obj_cls_item_id = soc.item_id and ocr.src_obj_cls_ver_nr = soc.ver_nr;

end if;
end;

procedure pushCSI (vIdseq in char, vItemId in number, vVerNr in number, vActionType in char)
as
v_prnt_null integer;
begin

select decode(p_item_id, null, 1, 0) into v_prnt_null from nci_clsfctn_schm_item where item_id = vItemId and ver_nr =vVerNr;

if vActionType = 'U' then
update sbr.cs_items set ( asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,origin,preferred_definition,preferred_name,csitl_name, description, comments,
            date_modified, modified_by, deleted_ind) =
(select  ai.ADMIN_STUS_NM_DN,ai.EFF_DT, ai.ADMIN_NOTES, c.nci_idseq,ai.UNTL_DT, decode(ai.CURRNT_VER_IND,1,'Yes',0,'No'),
            ai.ITEM_NM, ai.ORIGIN,nci_cadsr_push.getShortDef(ai.ITEM_DESC),ai.ITEM_LONG_Nm, ok.NCI_CD,  csi_desc_txt, csi_cmnts,
            ai.LST_UPD_DT,ai.LST_UPD_USR_ID ,decode(nvl(ai.fld_delete,0),0,'No',1,'Yes')
        from admin_item ai, admin_item c, obj_key ok, nci_clsfctn_schm_item con
        where ai.cntxt_item_id = c.item_id and ai.cntxt_ver_nr = c.ver_nr
            and ai.nci_idseq = vIdseq
            and ai.item_id = con.item_id and ai.ver_nr = con.ver_nr
            and con.csi_typ_id = ok.obj_key_id (+))
            where csi_idseq = vIdseq;

-- if parent is not null
if (v_prnt_null = 0) then
for cur in (select nvl(csi.cs_csi_idseq, csiai.nci_idseq) cs_csi_idseq, cs.nci_idseq cs_idseq, csiai.nci_idseq csi_idseq, nvl(pcsi.cs_csi_idseq, pcsiai.nci_idseq) p_cs_csi_idseq
from admin_item csiai, nci_clsfctn_schm_item csi, admin_item cs, admin_item pcsiai, nci_clsfctn_schm_item pcsi where
csiai.nci_idseq = vIdSeq and csi.item_id = vItemid and csi.ver_nr = vVerNr and csi.cs_item_id = cs.item_id and csi.cs_item_ver_nr = cs.ver_nr
and csi.p_item_id = pcsiai.item_id and csi.p_item_ver_nr = pcsiai.ver_nr and csi.p_item_id = pcsi.item_id and csi.p_item_ver_nr = pcsi.ver_nr
and csi.p_item_id is not null) loop
update sbr.cs_csi set cs_idseq = cur.cs_idseq, p_cs_csi_idseq  = cur.p_cs_csi_idseq where cs_csi_idseq = cur.cs_csi_idseq;
end loop;
else
-- if parent is null
for cur in (select nvl(csi.cs_csi_idseq, csiai.nci_idseq) cs_csi_idseq, cs.nci_idseq cs_idseq, csiai.nci_idseq csi_idseq
from admin_item csiai, nci_clsfctn_schm_item csi, admin_item cs where
csiai.nci_idseq = vIdSeq and csi.item_id = vItemid and csi.ver_nr = vVerNr and csi.cs_item_id = cs.item_id and csi.cs_item_ver_nr = cs.ver_nr
and csi.p_item_id is null) loop
update sbr.cs_csi set cs_idseq = cur.cs_idseq, p_cs_csi_idseq  = null where cs_csi_idseq = cur.cs_csi_idseq;
end loop;
end if;
end if;
if vActionType = 'I' then
--raise_application_error(-20000, vIdseq);

insert into sbr.cs_items (csi_idseq, asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,origin,preferred_definition,preferred_name,csi_id, csitl_name, description, comments,version,
            created_by, date_created,date_modified, modified_by, deleted_ind)
select  ai.NCI_IDSEQ, ai.ADMIN_STUS_NM_DN,ai.EFF_DT, ai.ADMIN_NOTES, c.nci_idseq,ai.UNTL_DT, decode(ai.CURRNT_VER_IND,1,'Yes',0,'No'),
            ai.ITEM_NM, ai.ORIGIN,nci_cadsr_push.getShortDef(ai.ITEM_DESC),ai.ITEM_LONG_Nm,ai.ITEM_ID, ok.nci_cd, csi_desc_txt, csi_cmnts,ai.VER_NR,
            ai.CREAT_USR_ID, ai.CREAT_DT, ai.LST_UPD_DT,ai.LST_UPD_USR_ID ,decode(nvl(ai.fld_delete,0),0,'No',1,'Yes')
        from admin_item ai, admin_item c, NCI_CLSFCTN_SCHM_ITEM con, obj_key ok
        where ai.cntxt_item_id = c.item_id and ai.cntxt_ver_nr = c.ver_nr
            and c.admin_item_typ_id = 8
            and con.csi_typ_id = ok.obj_key_id (+)
            and con.item_id = ai.item_id and con.ver_nr = ai.ver_nr
            and ai.nci_idseq= vIdseq;

-- if parent is not null
if (v_prnt_null = 0) then
for cur in (select nvl(csi.cs_csi_idseq, csiai.nci_idseq) cs_csi_idseq, cs.nci_idseq cs_idseq, csiai.nci_idseq csi_idseq, nvl(pcsi.cs_csi_idseq, pcsiai.nci_idseq) p_cs_csi_idseq,
csi.creat_dt, csi.lst_upd_dt, csi.creat_usr_id, csi.lst_upd_usr_id
from admin_item csiai, nci_clsfctn_schm_item csi, admin_item cs, admin_item pcsiai, nci_clsfctn_schm_item pcsi where
csiai.nci_idseq = vIdSeq and csi.item_id = vItemid and csi.ver_nr = vVerNr and csi.cs_item_id = cs.item_id and csi.cs_item_ver_nr = cs.ver_nr
and csi.p_item_id = pcsiai.item_id and csi.p_item_ver_nr = pcsiai.ver_nr and csi.p_item_id = pcsi.item_id and csi.p_item_ver_nr = pcsi.ver_nr
and csi.p_item_id is not null) loop
insert into  sbr.cs_csi (CS_CSI_IDSEQ, CS_IDSEQ,csi_idseq, P_CS_CSI_IDSEQ,  DATE_CREATED, CREATED_BY, DATE_MODIFIED, MODIFIED_BY, LABEL)
select  cur.cs_csi_idseq, cur.cs_idseq, cur.csi_idseq, cur.p_cs_csi_idseq, cur.creat_dt,
cur.creat_usr_id, cur.lst_upd_dt, cur.lst_upd_usr_id,'1' from dual
where cur.cs_csi_idseq not in (Select cs_csi_idseq from sbr.cs_csi);


end loop;
else
-- if parent is null
for cur in (select nvl(csi.cs_csi_idseq, csiai.nci_idseq) cs_csi_idseq, cs.nci_idseq cs_idseq, csiai.nci_idseq csi_idseq,
csi.creat_dt, csi.lst_upd_dt, csi.creat_usr_id, csi.lst_upd_usr_id
from admin_item csiai, nci_clsfctn_schm_item csi, admin_item cs where
csiai.nci_idseq = vIdSeq and csi.item_id = vItemid and csi.ver_nr = vVerNr and csi.cs_item_id = cs.item_id and csi.cs_item_ver_nr = cs.ver_nr
and csi.p_item_id is null) loop
insert into  sbr.cs_csi (CS_CSI_IDSEQ, CS_IDSEQ, csi_idseq, DATE_CREATED, CREATED_BY, DATE_MODIFIED, MODIFIED_BY,LABEL)
select cur.cs_csi_idseq, cur.cs_idseq, cur.csi_idseq, cur.creat_dt,
cur.creat_usr_id, cur.lst_upd_dt, cur.lst_upd_usr_id,'1' from dual
where cur.cs_csi_idseq not in (Select cs_csi_idseq from sbr.cs_csi);

end loop;
end if;
end if;

end;

procedure pushContext (vIdseq in char, vItemId in number, vVerNr in number, vActionType in char)
as
begin
--if vActionType = 'U' then
--end if;
if vActionType = 'I' then

insert into sbr.contexts (conte_idseq, description, name, version, pal_name, LL_Name)
select ai.nci_idseq,  nci_cadsr_push.getShortDef(ai.ITEM_DESC), ai.ITEM_Nm, ai.VER_NR, ok.nci_cd, 'UNASSIGNED'
from admin_item ai, cntxt c, obj_key ok
where ai.admin_item_typ_id = 8 and ai.item_id = c.item_id and ai.ver_nr = c.ver_nr and c.NCI_PRG_AREA_ID = ok.obj_key_id
and ai.item_id = vItemId and ai.ver_nr = vVerNr;
end if;
end;

procedure pushCS (vIdseq in char, vItemId in number, vVerNr in number, vActionType in char)
as
begin
if vActionType = 'U' then
update sbr.classification_schemes set ( asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,origin,preferred_definition,preferred_name, cstl_name, label_type_flag,
            date_modified, modified_by, deleted_ind) =
(select  ai.ADMIN_STUS_NM_DN,ai.EFF_DT, ai.ADMIN_NOTES, c.nci_idseq,ai.UNTL_DT, decode(ai.CURRNT_VER_IND,1,'Yes',0,'No'),
            ai.ITEM_NM, ai.ORIGIN,nci_cadsr_push.getShortDef(ai.ITEM_DESC),ai.ITEM_LONG_Nm,  ok.nci_cd, nvl(nci_label_typ_flg, 'A'),
            ai.LST_UPD_DT,ai.LST_UPD_USR_ID ,decode(nvl(ai.fld_delete,0),0,'No',1,'Yes')
        from admin_item ai, admin_item c, clsfctn_schm cs, obj_key ok
        where ai.cntxt_item_id = c.item_id and ai.cntxt_ver_nr = c.ver_nr
            and ai.nci_idseq = vIdseq and ai.item_id = cs.item_id and ai.ver_nr = cs.ver_nr
            and ok.obj_key_id = cs.clsfctn_schm_typ_id)
where cs_idseq = vIdseq;

end if;
if vActionType = 'I' then
insert into sbr.classification_schemes (cs_idseq, asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,origin,preferred_definition,preferred_name,cs_id,version, cstl_name, label_type_flag,
            created_by, date_created,date_modified, modified_by, deleted_ind)
select  ai.NCI_IDSEQ, ai.ADMIN_STUS_NM_DN,ai.EFF_DT, ai.ADMIN_NOTES, c.nci_idseq,ai.UNTL_DT, decode(ai.CURRNT_VER_IND,1,'Yes',0,'No'),
            ai.ITEM_NM, ai.ORIGIN,nci_cadsr_push.getShortDef(ai.ITEM_DESC),ai.ITEM_LONG_Nm,ai.ITEM_ID, ai.VER_NR, ok.nci_cd, nvl(cs.nci_label_typ_flg, 'A'),
            ai.CREAT_USR_ID, ai.CREAT_DT, ai.LST_UPD_DT,ai.LST_UPD_USR_ID ,decode(nvl(ai.fld_delete,0),0,'No',1,'Yes')
        from admin_item ai, admin_item c, clsfctn_schm cs, obj_key ok
        where ai.cntxt_item_id = c.item_id and ai.cntxt_ver_nr = c.ver_nr
        and c.admin_item_typ_id = 8
        and ai.item_id = cs.item_id and ai.ver_nr = cs.ver_nr
        and ok.obj_key_id = cs.clsfctn_schm_typ_id
        and ai.nci_idseq= vIdseq;

end if;
end;

procedure pushCondr (vCondrIdseq in char, vItemId in number, vVerNr in number, vActionType in char)
as
v_cnt integer;
vExist integer;
--v_condr_idseq char(36);

begin


select count(*) into v_cnt from cncpt_admin_item cai where cai.item_id = vItemId and cai.ver_nr = vVerNr;
--raise_application_error(-20000, vItemID);
select count(*) into v_cnt from sbrext.CON_DERIVATION_RULES_EXT where condr_idseq = vCondrIdseq;

if (v_cnt = 0) then

insert into sbrext.CON_DERIVATION_RULES_EXT (condr_idseq, date_created, created_by, crtl_name, name)
select vCondrIdseq, nvl(max(cai.creat_dt), sysdate),nvl(max(cai.creat_usr_id), 'ONEDATA'), decode(v_cnt,0, 'Simple Concept',1, 'Simple Concept','CONCATENATION') ,  nvl(listagg(con.item_long_nm,':') within group (order by cai.NCI_ORD),'No concepts')
from cncpt_admin_item cai, admin_item con where cai.item_id = vItemId and cai.ver_nr = vVerNr and cai.cncpt_item_id = con.item_id and cai.cncpt_ver_nr = con.ver_nr ;
else
update sbrext.CON_DERIVATION_RULES_EXT set (condr_idseq, crtl_name, name)=
(select vCondrIdseq, decode(v_cnt,0, 'Simple Concept',1, 'Simple Concept','CONCATENATION') ,  nvl(listagg(con.item_long_nm,':') within group (order by cai.NCI_ORD),'No concepts')
from cncpt_admin_item cai, admin_item con where cai.item_id = vItemId and cai.ver_nr = vVerNr and cai.cncpt_item_id = con.item_id and cai.cncpt_ver_nr = con.ver_nr)
where condr_idseq = vCondrIdseq;

end if;

delete from sbrext.COMPONENT_CONCEPTS_EXT where condr_idseq = vCondrIdseq;

insert into sbrext.COMPONENT_CONCEPTS_EXT (cc_idseq, CONDR_IDSEQ, CON_IDSEQ, DISPLAY_ORDER, DATE_CREATED, DATE_MODIFIED, MODIFIED_BY, CREATED_BY, PRIMARY_FLAG_IND, CONCEPT_VALUE)
select nci_11179.cmr_guid, vCondrIdseq, con.nci_idseq, nvl(nci_ord,1), cai.CREAT_DT, cai.LST_UPD_DT,cai.LST_UPD_USR_ID,cai.CREAT_USR_ID, decode(nci_prmry_ind, 1, 'Yes',0,'No'), nci_cncpt_val
from cncpt_admin_item cai, admin_item con where cai.item_id = vItemId and cai.ver_nr = vVerNr and cai.cncpt_item_id = con.item_id and cai.cncpt_ver_nr = con.ver_nr;


end;

END;
/


DROP PACKAGE BODY ONEDATA_WA.NCI_CADSR_PUSH_FORM;

CREATE OR REPLACE PACKAGE body ONEDATA_WA.nci_caDSR_push_form AS

/* ELEMENT_INSTRUCTION
MODULE_ELEMENT
VALUE_INSTRUCTION
ELEMENT_VALUE
FORM_MODULE
FORM_INSTRUCTION
MODULE_INSTRUCTION
*/

procedure pushModule (vDays in integer)
as
v_cnt integer;
vActionType char(1);
v_id number;
vidseq char(36);
v_idseq char(36);
begin



for cur in (select ai.nci_idseq, item_id, ver_nr, admin_item_typ_id from admin_item ai, nci_admin_item_rel r where  greatest(ai.lst_upd_dt,r.lst_upd_dt) >= sysdate -vDays
and ai.item_id = r.c_item_id and ai.ver_nr = r.c_item_ver_nr and r.rel_typ_id = 61 and ai.admin_item_typ_id = 52 and r.p_item_id <> r.c_item_id order by ai.creat_dt) loop
select count(*) into v_cnt  from sbr.administered_components where ac_idseq = cur.nci_idseq;
if (v_cnt = 0) then vActionType := 'I';
else vActionType := 'U';
end if;

if vActionType = 'I' then


-- Module
for curmod in (select  ai.NCI_IDSEQ MOD_IDSEQ, frm.nci_idseq FRM_IDSEQ,  rel.disp_ord,rel.rep_no,ai.ADMIN_STUS_NM_DN, ai.EFF_DT, ai.ADMIN_NOTES, c.nci_idseq CNTXT_IDSEQ,ai.UNTL_DT,
decode(ai.CURRNT_VER_IND,1,'Yes',0,'No') CURRNT_VER_IND, rel.instr,
            ai.ITEM_NM, ai.ORIGIN,ai.ITEM_DESC,ai.ITEM_LONG_Nm,ai.ITEM_ID, ai.VER_NR,
            ai.CREAT_USR_ID, ai.CREAT_DT, ai.LST_UPD_DT,ai.LST_UPD_USR_ID ,decode(nvl(ai.fld_delete,0),0,'No',1,'Yes') FLD_DELETE from admin_item ai, admin_item c, NCI_ADMIN_ITEM_REL rel, admin_item frm
        where ai.cntxt_item_id = c.item_id and ai.cntxt_ver_nr = c.ver_nr
        and c.admin_item_typ_id = 8
        and rel.rel_typ_id = 61
        and rel.c_item_id  = ai.item_id and rel.c_item_ver_nr = ai.ver_nr
        and rel.p_item_id = frm.item_id and rel.p_item_ver_nr = frm.ver_nr
        and ai.nci_idseq= cur.nci_idseq) loop
insert into sbrext.quest_contents_ext (qc_idseq,p_mod_idseq, qtl_name, dn_crf_idseq,display_order, repeat_no,
            asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,origin,preferred_definition,preferred_name,qc_id,version,
            created_by, date_created,date_modified, modified_by, deleted_ind, display_ind)
values ( curmod.MOD_IDSEQ,curmod.MOD_IDSEQ, 'MODULE',  curmod.FRM_idseq, curmod.disp_ord,curmod.rep_no,curmod.ADMIN_STUS_NM_DN,curmod.EFF_DT,
curmod.ADMIN_NOTES, curmod.CNTXT_idseq,curmod.UNTL_DT, curmod.CURRNT_VER_IND,
            curmod.ITEM_NM, curmod.ORIGIN,nci_cadsr_push.getShortDef(curmod.ITEM_DESC),curmod.ITEM_LONG_Nm,curmod.ITEM_ID, curmod.VER_NR,
            curmod.CREAT_USR_ID, curmod.CREAT_DT, curmod.LST_UPD_DT,curmod.LST_UPD_USR_ID ,curmod.fld_delete, 'Yes');





insert into sbr.administered_components (ac_idseq,actl_name,
            asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,origin,preferred_definition,preferred_name,public_id,version,
            created_by, date_created,date_modified, modified_by, deleted_ind) values
( curmod.MOD_IDSEQ, 'QUEST_CONTENT', curmod.ADMIN_STUS_NM_DN,curmod.EFF_DT, curmod.ADMIN_NOTES, curmod.CNTXT_idseq,curmod.UNTL_DT, curmod.CURRNT_VER_IND,
            curmod.ITEM_NM, curmod.ORIGIN,curmod.ITEM_DESC,curmod.ITEM_LONG_Nm,curmod.ITEM_ID, curmod.VER_NR,
            curmod.CREAT_USR_ID, curmod.CREAT_DT, curmod.LST_UPD_DT,curmod.LST_UPD_USR_ID ,curmod.fld_delete);


--Module Instruction
v_id := nci_11179.getItemid;
v_idseq := nci_11179.cmr_guid;

--raise_application_error(-20000, 'HEre');
insert into sbrext.quest_contents_ext (qc_idseq, p_mod_idseq, dn_crf_idseq, qtl_name, asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,origin,preferred_definition,
            preferred_name,qc_id,
            version,
            created_by, date_created,date_modified, modified_by,deleted_ind, display_ind) values
( v_idseq,  curmod.mod_idseq, curmod.frm_idseq, 'MODULE_INSTR' , curmod.ADMIN_STUS_NM_DN, curmod.EFF_DT, curmod.ADMIN_NOTES, curmod.CNTXT_idseq,curmod.UNTL_DT, curmod.CURRNT_VER_IND,
            curmod.ITEM_NM, curmod.ORIGIN,
            nvl(curmod.instr, ' '),
            v_id,v_id,
            curmod.VER_NR,
            curmod.CREAT_USR_ID, curmod.CREAT_DT, curmod.LST_UPD_DT,curmod.LST_UPD_USR_ID ,curmod.fld_delete, 'Yes');


insert into sbr.administered_components (ac_idseq,actl_name, asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,origin,preferred_definition,
            preferred_name,public_id,
            version,
            created_by, date_created,date_modified, modified_by,deleted_ind) values
    ( v_idseq,  'QUEST_CONTENT', curmod.ADMIN_STUS_NM_DN, curmod.EFF_DT, curmod.ADMIN_NOTES, curmod.CNTXT_idseq,curmod.UNTL_DT, curmod.CURRNT_VER_IND,
            curmod.ITEM_NM, curmod.ORIGIN,nvl(curmod.instr, ' '),
            v_id,v_id,
            curmod.VER_NR,
            curmod.CREAT_USR_ID, curmod.CREAT_DT, curmod.LST_UPD_DT,curmod.LST_UPD_USR_ID ,curmod.fld_delete);

insert into sbrext.qc_recs_ext (QR_IDSEQ,P_QC_IDSEQ,C_QC_IDSEQ,DISPLAY_ORDER,RL_NAME,CREATED_BY,DATE_CREATED,DATE_MODIFIED,MODIFIED_BY)
select nci_11179.cmr_guid,curmod.frm_idseq, curmod.mod_idseq, curmod.disp_ord ,'FORM_MODULE', curmod.CREAT_USR_ID, curmod.CREAT_DT, curmod.LST_UPD_DT,curmod.LST_UPD_USR_ID from dual;

insert into sbrext.qc_recs_ext (QR_IDSEQ,P_QC_IDSEQ,C_QC_IDSEQ,DISPLAY_ORDER,RL_NAME,CREATED_BY,DATE_CREATED,DATE_MODIFIED,MODIFIED_BY)
select nci_11179.cmr_guid,curmod.mod_idseq, v_idseq, curmod.disp_ord ,'MODULE_INSTRUCTION', curmod.CREAT_USR_ID, curmod.CREAT_DT, curmod.LST_UPD_DT,curmod.LST_UPD_USR_ID from dual;

end loop;
end if;



if vActionType = 'U' then

-- Module
update sbrext.quest_contents_ext set (display_order, repeat_no,
            asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,origin,preferred_definition,preferred_name,
            date_modified, modified_by, deleted_ind)=
(select   rel.disp_ord,rel.rep_no,ai.ADMIN_STUS_NM_DN, ai.EFF_DT, ai.ADMIN_NOTES, c.nci_idseq,ai.UNTL_DT, decode(ai.CURRNT_VER_IND,1,'Yes',0,'No'),
            ai.ITEM_NM, ai.ORIGIN,nci_cadsr_push.getShortDef(ai.ITEM_DESC),ai.ITEM_LONG_Nm,
            rel.LST_UPD_DT,rel.LST_UPD_USR_ID ,decode(nvl(ai.fld_delete,0),0,'No',1,'Yes')
        from admin_item ai, admin_item c, NCI_ADMIN_ITEM_REL rel, admin_item frm
        where ai.cntxt_item_id = c.item_id and ai.cntxt_ver_nr = c.ver_nr
        and c.admin_item_typ_id = 8
        and rel.rel_typ_id = 61
        and rel.c_item_id  = ai.item_id and rel.c_item_ver_nr = ai.ver_nr
        and rel.p_item_id = frm.item_id and rel.p_item_ver_nr = frm.ver_nr
        and ai.nci_idseq= cur.nci_idseq)
        where qc_idseq = cur.nci_idseq;

update sbrext.quest_contents_ext set (preferred_definition,
            date_modified, modified_by, deleted_ind) =
(select  nvl(rel.instr, ' '),
           rel.LST_UPD_DT,rel.LST_UPD_USR_ID ,decode(nvl(ai.fld_delete,0),0,'No',1,'Yes')
        from admin_item ai,  nci_admin_item_rel rel
        where  rel.rel_typ_id = 61
        and rel.c_item_id  = ai.item_id and rel.c_item_ver_nr = ai.ver_nr
             and ai.nci_idseq= cur.nci_idseq)
             where qc_idseq = cur.nci_idseq and qtl_name = 'MODULE_INSTR';
      --      and frm.hdr_instr is not null;


end if;

end loop;
commit;
end;



procedure pushQuestion (vDays in integer)
as
v_cnt integer;
vActionType char(1);
v_id number;
v_idseq  char(36);
begin

for cur in (select * from nci_admin_item_rel_alt_key where lst_upd_dt >= sysdate -vDays ) loop
select count(*) into v_cnt  from sbrext.quest_contents_ext where qc_idseq = cur.nci_idseq;
if (v_cnt = 0) then vActionType := 'I';
else vActionType := 'U';
end if;

if vActionType = 'I' then
--vidseq := cur.nci_idseq;
--raise_application_error(-20000,cur.nci_idseq);

for curqst in (select  ak.NCI_IDSEQ QST_IDSEQ, mod.nci_idseq MOD_IDSEQ,  frm.nci_idseq FRM_IDSEQ, de.nci_idseq DE_IDSEQ,
ak.disp_ord,frm.ADMIN_STUS_NM_DN, frm.EFF_DT, frm.ADMIN_NOTES, c.nci_idseq CNTXT_IDSEQ,frm.UNTL_DT,
decode(frm.CURRNT_VER_IND,1,'Yes',0,'No') CURRNT_VER_IND, ak.instr, ak.EDIT_IND, ak.req_ind, ak.DEFLT_VAL,
            ak.ITEM_LONG_NM, frm.ORIGIN,substr(de.ITEM_DESC,1,2000) ITEM_DESC,ak.ITEM_Nm,ak.NCI_PUB_ID, ak.NCI_VER_NR,
            ak.CREAT_USR_ID, ak.CREAT_DT, ak.LST_UPD_DT,ak.LST_UPD_USR_ID ,decode(nvl(ak.fld_delete,0),0,'No',1,'Yes') FLD_DELETE
        from nci_admin_item_rel_alt_key ak, admin_item c, admin_item mod, admin_item frm, admin_item de, nci_admin_item_rel rel
        where frm.cntxt_item_id = c.item_id and frm.cntxt_ver_nr = c.ver_nr
        and c.admin_item_typ_id = 8
        and rel.rel_typ_id = 61
        and rel.c_item_id  = ak.p_item_id and rel.c_item_ver_nr = ak.p_item_ver_nr
        and rel.p_item_id = frm.item_id and rel.p_item_ver_nr = frm.ver_nr
        and rel.c_item_id = mod.item_id and rel.c_item_ver_nr = mod.ver_nr
        and ak.nci_idseq= cur.nci_idseq
        and ak.c_item_id = de.item_id (+)
        and ak.c_item_ver_nr = de.ver_nr(+)) loop

insert into sbrext.quest_contents_ext (qc_idseq , p_qst_idseq, p_mod_idseq, qtl_name, dn_crf_idseq, De_idseq, display_order,
            asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,origin,preferred_definition,preferred_name,qc_id,version,
            created_by, date_created,date_modified, modified_by, deleted_ind,  display_ind)
values ( curqst.QST_IDSEQ, curqst.QST_IDSEQ,curqst.mod_idseq, 'QUESTION',  curqst.FRM_idseq, curqst.de_idseq, curqst.disp_ord,curqst.ADMIN_STUS_NM_DN, curqst.EFF_DT,
curqst.ADMIN_NOTES, curqst.cntxt_idseq,curqst.UNTL_DT,
curqst.CURRNT_VER_IND,
            curqst.ITEM_LONG_NM, curqst.ORIGIN,
            nci_cadsr_push.getShortDef (curqst.ITEM_DESC),
            --curqst.ITEM_Nm,
            curqst.nci_pub_id,
            curqst.NCI_PUB_ID, curqst.NCI_VER_NR,
            curqst.CREAT_USR_ID, curqst.CREAT_DT, curqst.LST_UPD_DT,curqst.LST_UPD_USR_ID ,curqst.fld_delete, 'Yes');



insert into sbr.administered_components (ac_idseq , actl_name,
            asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,origin,preferred_definition,preferred_name,public_id,version,
            created_by, date_created,date_modified, modified_by, deleted_ind)
values ( curqst.QST_IDSEQ,'QUEST_CONTENT', curqst.ADMIN_STUS_NM_DN, curqst.EFF_DT, curqst.ADMIN_NOTES, curqst.cntxt_idseq,curqst.UNTL_DT,
curqst.CURRNT_VER_IND,
            curqst.ITEM_LONG_NM, curqst.ORIGIN,curqst.ITEM_DESC,
            nci_11179_2.getStdShortName(curqst.NCI_PUB_ID, curqst.NCI_VER_NR),
            curqst.NCI_PUB_ID, curqst.NCI_VER_NR,
         curqst.CREAT_USR_ID, curqst.CREAT_DT, curqst.LST_UPD_DT,curqst.LST_UPD_USR_ID ,curqst.fld_delete);

-- Question Instruction
v_id := nci_11179.getItemid;
v_idseq := nci_11179.cmr_guid;
insert into sbrext.quest_contents_ext (qc_idseq , p_qst_idseq, p_mod_idseq, qtl_name, dn_crf_idseq, De_idseq, display_order,
            asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,origin,preferred_definition,preferred_name,qc_id,version,
            created_by, date_created,date_modified, modified_by, deleted_ind,  display_ind)
values(  v_idseq, curqst.qst_idseq, curqst.mod_idseq, 'QUESTION_INSTR',  curqst.frm_idseq, curqst.de_idseq, curqst.disp_ord,
curqst.ADMIN_STUS_NM_DN, curqst.EFF_DT, curqst.ADMIN_NOTES, curqst.cntxt_idseq,curqst.UNTL_DT,
curqst.CURRNT_VER_IND,
            curqst.ITEM_LONG_NM, curqst.ORIGIN,nvl(curqst.instr, ' ' ),v_id, v_id, curqst.NCI_VER_NR,
              curqst.CREAT_USR_ID, curqst.CREAT_DT, curqst.LST_UPD_DT,curqst.LST_UPD_USR_ID ,curqst.fld_delete, 'Yes');


insert into sbr.administered_components (ac_idseq , actl_name,
            asl_name,begin_date,change_note,conte_idseq,end_date,latest_version_ind,
            long_name,origin,preferred_definition,preferred_name,public_id,version,
            created_by, date_created,date_modified, modified_by, deleted_ind)
values (  v_idseq,'QUEST_CONTENT', curqst.ADMIN_STUS_NM_DN, curqst.EFF_DT, curqst.ADMIN_NOTES, curqst.cntxt_idseq,curqst.UNTL_DT,
curqst.CURRNT_VER_IND,
            curqst.ITEM_LONG_NM, curqst.ORIGIN,curqst.item_desc,
                      nci_11179_2.getStdShortName(v_id, curqst.NCI_VER_NR),
            v_id, curqst.NCI_VER_NR,
              curqst.CREAT_USR_ID, curqst.CREAT_DT, curqst.LST_UPD_DT,curqst.LST_UPD_USR_ID ,curqst.fld_delete);



insert into sbrext.QUEST_ATTRIBUTES_EXT (qc_idseq, quest_idseq , editable_ind,mandatory_ind,DEFAULT_VALUE,
            created_by, date_created,date_modified, modified_by)
values (curqst.qst_idseq, curqst.qst_idseq, decode(nvl(curqst.EDIT_IND,0), 1, 'Yes', 'No'), decode(nvl(curqst.REQ_IND,0), 1, 'Yes', 'No'), curqst.DEFLT_VAL,
curqst.CREAT_USR_ID, curqst.CREAT_DT, curqst.LST_UPD_DT,curqst.LST_UPD_USR_ID );


insert into sbrext.qc_recs_ext (QR_IDSEQ,P_QC_IDSEQ,C_QC_IDSEQ,DISPLAY_ORDER,RL_NAME,CREATED_BY,DATE_CREATED,DATE_MODIFIED,MODIFIED_BY)
select nci_11179.cmr_guid,curqst.mod_idseq, curqst.qst_idseq, curqst.disp_ord ,'MODULE_ELEMENT', curqst.CREAT_USR_ID, curqst.CREAT_DT, curqst.LST_UPD_DT,curqst.LST_UPD_USR_ID from dual;

insert into sbrext.qc_recs_ext (QR_IDSEQ,P_QC_IDSEQ,C_QC_IDSEQ,DISPLAY_ORDER,RL_NAME,CREATED_BY,DATE_CREATED,DATE_MODIFIED,MODIFIED_BY)
select nci_11179.cmr_guid,curqst.qst_idseq, v_idseq, curqst.disp_ord ,'ELEMENT_INSTRUCTION', curqst.CREAT_USR_ID, curqst.CREAT_DT, curqst.LST_UPD_DT,curqst.LST_UPD_USR_ID from dual;
end loop;
end if;

if vActionType = 'U' then
update sbrext.quest_contents_ext set ( display_order, latest_version_ind,
            long_name,
            date_modified, modified_by, deleted_ind)=
(select  ak.disp_ord,
decode(frm.CURRNT_VER_IND,1,'Yes',0,'No'),
            ak.ITEM_LONG_NM,
           ak.LST_UPD_DT,ak.LST_UPD_USR_ID ,decode(nvl(ak.fld_delete,0),0,'No',1,'Yes')
        from nci_admin_item_rel_alt_key ak, admin_item c, admin_item mod, admin_item frm, admin_item de, nci_admin_item_rel rel
        where frm.cntxt_item_id = c.item_id and frm.cntxt_ver_nr = c.ver_nr
        and c.admin_item_typ_id = 8
        and rel.rel_typ_id = 61
        and rel.c_item_id  = ak.p_item_id and rel.c_item_ver_nr = ak.p_item_ver_nr
        and rel.p_item_id = frm.item_id and rel.p_item_ver_nr = frm.ver_nr
        and rel.c_item_id = mod.item_id and rel.c_item_ver_nr = mod.ver_nr
        and ak.nci_idseq= cur.nci_idseq
        and ak.c_item_id = de.item_id (+)
        and ak.c_item_ver_nr = de.ver_nr(+))
        where qc_idseq = cur.nci_idseq;


end if;
end loop;
commit;
end;

PROCEDURE            PushQuestValidValue (vDays in integer)
 AS
    v_cnt   INTEGER;
    v_id number;
    v_idseq char(36);
BEGIN
    FOR cur IN (SELECT nci_idseq
                  FROM NCI_QUEST_VALID_VALUE
                 WHERE lst_upd_dt >= sysdate - vDays)
    LOOP
        SELECT COUNT (*)
          INTO v_cnt
          FROM sbrext.quest_contents_ext
         WHERE qc_idseq = cur.nci_idseq;

        IF (v_cnt = 0)
        THEN                      -- new

            for curvv in (SELECT vv.NCI_IDSEQ,      q.p_mod_idseq,
                       q.dn_crf_idseq,
                       q.qc_idseq,--rel.disp_ord,
                       q.asl_Name,
                       q.begin_date,
                       q.change_note,
                       q.conte_idseq ,
                       q.end_date,
                       q.latest_version_ind,
                       vv.VALUE,
                       vv.VM_DEF,
                       vv.desc_txt,
                       vv.mean_txt,
                       vv.NCI_PUB_ID,
                       vv.NCI_VER_NR,
                       vv.CREAT_USR_ID,
                       vv.CREAT_DT,
                       vv.LST_UPD_DT,
                       vv.LST_UPD_USR_ID,
                       vv.instr,
                       decode(nvl(vv.fld_delete,0),0,'No',1,'Yes') FLD_DELETE,  vv.disp_ord
                  FROM sbrext.quest_contents_ext q,
                  nci_quest_valid_value       vv
                 WHERE     vv.Q_PUB_ID = q.qc_ID
                 and   vv.q_ver_nr = q.version
                       AND vv.nci_idseq = cur.nci_idseq) loop

            INSERT INTO sbrext.quest_contents_ext (qc_idseq,
                                                   p_mod_idseq,
                                                   qtl_name,
                                                   dn_crf_idseq,
                                                   p_qst_idseq,
                                                   asl_name,
                                                   begin_date,
                                                   change_note,
                                                   conte_idseq,
                                                   end_date,
                                                   latest_version_ind,
                                                   long_name,
                                                   preferred_definition,
                                                   preferred_name,
                                                   qc_id,
                                                   version,
                                                   created_by,
                                                   date_created,
                                                   date_modified,
                                                   modified_by, deleted_ind, display_ind, display_order)
                values ( curvv.NCI_IDSEQ,
                       curvv.p_mod_idseq,
                       'VALID_VALUE',
                       curvv.dn_crf_idseq,
                       curvv.qc_idseq,--rel.disp_ord,
                       curvv.asl_Name,
                       curvv.begin_date,
                       curvv.change_note,
                       curvv.conte_idseq,
                       curvv.end_date,
                       curvv.latest_version_ind,
                       curvv.VALUE,
                       curvv.VM_DEF,
                       curvv.nci_pub_id,
                       curvv.NCI_PUB_ID,
                       curvv.NCI_VER_NR,
                       curvv.CREAT_USR_ID,
                       curvv.CREAT_DT,
                       curvv.LST_UPD_DT,
                       curvv.LST_UPD_USR_ID,
                       curvv.fld_delete, 'Yes',curvv.disp_ord);

   INSERT INTO sbr.administered_components (ac_idseq,actl_name,
                                                   asl_name,
                                                   begin_date,
                                                   change_note,
                                                   conte_idseq,
                                                   end_date,
                                                   latest_version_ind,
                                                   long_name,
                                                   preferred_definition,
                                                   preferred_name,
                                                   public_id,
                                                   version,
                                                   created_by,
                                                   date_created,
                                                   date_modified,
                                                   modified_by, deleted_ind)
               values ( curvv.NCI_IDSEQ,
                       'QUEST_CONTENT',
                       curvv.asl_Name,
                       curvv.begin_date,
                       curvv.change_note,
                       curvv.conte_idseq,
                       curvv.end_date,
                       curvv.latest_version_ind,
                       curvv.VALUE,
                       curvv.VM_DEF,
                       curvv.nci_pub_id,
                       curvv.NCI_PUB_ID,
                       curvv.NCI_VER_NR,
                       curvv.CREAT_USR_ID,
                       curvv.CREAT_DT,
                       curvv.LST_UPD_DT,
                       curvv.LST_UPD_USR_ID,
                       curvv.fld_delete);

--- Valid Values Instructions

v_id := nci_11179.getItemid;
v_idseq := nci_11179.cmr_guid;

   INSERT INTO sbrext.quest_contents_ext (qc_idseq,
                                                   p_mod_idseq,
                                                   qtl_name,
                                                   dn_crf_idseq,
                                                   p_qst_idseq,
                                                   asl_name,
                                                   begin_date,
                                                   change_note,
                                                   conte_idseq,
                                                   end_date,
                                                   latest_version_ind,
                                                   long_name,
                                                   preferred_definition,
                                                   preferred_name,
                                                   qc_id,
                                                   version,
                                                   created_by,
                                                   date_created,
                                                   date_modified,
                                                   modified_by, deleted_ind, display_ind, display_order)
                values ( v_idseq,
                       curvv.p_mod_idseq,
                       'VALUE_INSTR',
                       curvv.dn_crf_idseq,
                       curvv.qc_idseq,
                       curvv.asl_Name,
                       curvv.begin_date,
                       curvv.change_note,
                       curvv.conte_idseq,
                       curvv.end_date,
                       curvv.latest_version_ind,
                       curvv.VALUE,
                       nvl(curvv.instr, ' '),
                      v_id,
                       v_id,
                       curvv.NCI_VER_NR,
                       curvv.CREAT_USR_ID,
                       curvv.CREAT_DT,
                       curvv.LST_UPD_DT,
                       curvv.LST_UPD_USR_ID,
                       curvv.fld_delete, 'Yes',curvv.disp_ord);

   INSERT INTO sbr.administered_components (ac_idseq,actl_name,
                                                   asl_name,
                                                   begin_date,
                                                   change_note,
                                                   conte_idseq,
                                                   end_date,
                                                   latest_version_ind,
                                                   long_name,
                                                   preferred_definition,
                                                   preferred_name,
                                                   public_id,
                                                   version,
                                                   created_by,
                                                   date_created,
                                                   date_modified,
                                                   modified_by, deleted_ind)
               values ( v_IDSEQ,
                       'QUEST_CONTENT',
                       curvv.asl_Name,
                       curvv.begin_date,
                       curvv.change_note,
                       curvv.conte_idseq,
                       curvv.end_date,
                       curvv.latest_version_ind,
                       curvv.VALUE,
                           nvl(curvv.instr, ' '),
                     v_id,
                       v_id,
                       curvv.NCI_VER_NR,
                       curvv.CREAT_USR_ID,
                       curvv.CREAT_DT,
                       curvv.LST_UPD_DT,
                       curvv.LST_UPD_USR_ID,
                       curvv.fld_delete);

            INSERT INTO sbrext.valid_values_att_ext (qc_idseq,
                                                     description_text,
                                                     meaning_text,
                                                     created_by,
                                                     date_created,
                                                     date_modified,
                                                     modified_by)
                values ( curvv.nci_idseq,
                       curvv.desc_txt,
                       curvv.mean_txt,
                       curvv.CREAT_USR_ID,
                       curvv.CREAT_DT,
                       curvv.LST_UPD_DT,
                       curvv.LST_UPD_USR_ID);

-- Instructions


insert into sbrext.qc_recs_ext (QR_IDSEQ,P_QC_IDSEQ,C_QC_IDSEQ,DISPLAY_ORDER,RL_NAME,CREATED_BY,DATE_CREATED,DATE_MODIFIED,MODIFIED_BY)
select nci_11179.cmr_guid,curvv.qc_idseq, curvv.nci_idseq, curvv.disp_ord ,'ELEMENT_VALUE', curvv.CREAT_USR_ID, curvv.CREAT_DT, curvv.LST_UPD_DT,curvv.LST_UPD_USR_ID from dual;

insert into sbrext.qc_recs_ext (QR_IDSEQ,P_QC_IDSEQ,C_QC_IDSEQ,DISPLAY_ORDER,RL_NAME,CREATED_BY,DATE_CREATED,DATE_MODIFIED,MODIFIED_BY)
select nci_11179.cmr_guid,curvv.nci_idseq, v_idseq, curvv.disp_ord ,'VALUE_INSTRUCTION',  curvv.CREAT_USR_ID, curvv.CREAT_DT, curvv.LST_UPD_DT,curvv.LST_UPD_USR_ID from dual;
end loop;
        END IF;
        if (v_cnt = 1) then
            update sbrext.quest_contents_ext set ( latest_version_ind,
                                                   long_name,
                                                   preferred_definition,display_order,
                                                   date_modified,
                                                   modified_by, deleted_ind)=
               ( SELECT q.latest_version_ind,
                       vv.VALUE,
                       vv.VM_DEF,
                       vv.disp_ord,
                       vv.LST_UPD_DT,
                       vv.LST_UPD_USR_ID,
                       decode(nvl(vv.fld_delete,0),0,'No',1,'Yes')
                  FROM sbrext.quest_contents_ext q,
                  nci_quest_valid_value       vv
                 WHERE     vv.Q_PUB_ID = q.qc_ID
                 and   vv.q_ver_nr = q.version
                       AND vv.nci_idseq = cur.nci_idseq)
                       where qc_idseq = cur.nci_idseq;


            update sbrext.valid_values_att_ext set ( description_text,
                                                     meaning_text,
                                                     date_modified,
                                                     modified_by) =
                (SELECT
                       desc_txt,
                       mean_txt,
                       vv.LST_UPD_DT,
                       vv.LST_UPD_USR_ID
                  FROM nci_quest_valid_value vv
                 WHERE nci_idseq = cur.nci_idseq)
                 where qc_idseq = cur.nci_idseq;
        end if;

    END LOOP;
/*
  INSERT INTO NCI_QUEST_VALID_VALUE (NCI_PUB_ID,
                                       Q_PUB_ID,
                                       Q_VER_NR,
                                       VM_NM,
                                       VM_DEF,
                                       VALUE,
                                       NCI_IDSEQ,
                                       DESC_TXT,
                                       MEAN_TXT,
                                       VAL_MEAN_ITEM_ID,
                                       VAL_MEAN_VER_NR,
                                       CREAT_USR_ID,
                                       CREAT_DT,
                                       LST_UPD_DT,
                                       LST_UPD_USR_ID, DISP_ORD)
        SELECT qc.qc_id,
               qc1.qc_id,
               qc1.VERSION,
               qc.preferred_name,
               qc.preferred_definition,
               qc.long_name,
               qc.qc_idseq,
               vv.description_text,
               vv.meaning_text,
               vm.vm_id,
               vm.version,
          nvl(qc.created_by,v_dflt_usr),
               nvl(qc.date_created,v_dflt_date) ,
             nvl(NVL (qc.date_modified, qc.date_created), v_dflt_date),
               nvl(qc.modified_by,v_dflt_usr), qc.DISPLAY_ORDER
                       FROM sbrext_m.quest_contents_ext    qc,
               sbrext_m.quest_contents_ext    qc1,
               sbrext_m.valid_values_att_ext  vv,
               sbrext_m.vd_pvs  vp,
                sbrext_m.permissible_Values pv,
                sbrext_m.value_meanings vm
         WHERE     qc.qtl_name = 'VALID_VALUE'
               AND qc1.qtl_name = 'QUESTION'
               AND qc1.qc_idseq = qc.p_qst_idseq
               AND qc.qc_idseq = vv.qc_idseq(+)
                and vp.pv_idseq = pv.pv_idseq (+) and pv.vm_idseq = vm.vm_idseq (+)
                and qc.vp_idseq = vp.vp_idseq (+);

    COMMIT;
*/
    COMMIT;
/*


insert into NCI_QUEST_VALID_VALUE
(NCI_PUB_ID, Q_PUB_ID, Q_VER_NR, VM_NM, VM_DEF, VALUE, NCI_IDSEQ, DESC_TXT, MEAN_TXT,
CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID)
select qc.qc_id, qc1.qc_id, qc1.VERSION, qc.preferred_name, qc.preferred_definition ,qc.long_name, qc.qc_idseq, vv.description_text, vv.meaning_text,
qc.created_by, qc.date_created,
qc.date_modified, qc.modified_by
from  sbrext.quest_contents_ext qc, sbrext.quest_contents_ext qc1, sbrext.valid_values_att_ext vv
where qc.qtl_name = 'VALID_VALUE' and qc1.qtl_name = 'QUESTION' and qc1.qc_idseq = qc.p_qst_idseq and qc.qc_idseq = vv.qc_idseq (+);

commit;

delete from NCI_QUEST_VV_REP;
commit;

insert into NCI_QUEST_VV_REP
( QUEST_PUB_ID ,  QUEST_VER_NR ,
 VV_PUB_ID, VV_VER_NR,
 VAL,EDIT_IND , REP_SEQ,
   CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID )
select q.NCI_PUB_ID, q.NCI_VER_NR, vv.NCI_PUB_ID, vv.NCI_VER_NR,
qvv.value, decode(editable_ind,'Yes',1,'No',0), repeat_sequence,
qvv.created_by, qvv.date_created,
qvv.date_modified, qvv.modified_by
from sbrext.quest_vv_ext qvv, NCI_ADMIN_ITEM_REL_ALT_KEY q, NCI_QUEST_VALID_VALUE vv
where qvv.quest_idseq = q.NCI_IDSEQ and qvv.vv_idseq = vv.NCI_IDSEQ (+);
commit;
*/

END;

procedure sp_create_form_vv (    vDays   IN INTEGER)
as
v_cnt integer;
begin

delete from NCI_QUEST_VALID_VALUE;
commit;

insert into NCI_QUEST_VALID_VALUE
(NCI_PUB_ID, Q_PUB_ID, Q_VER_NR, VM_NM, VM_DEF, VALUE, NCI_IDSEQ, DESC_TXT, MEAN_TXT,
CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID)
select qc.qc_id, qc1.qc_id, qc1.VERSION, qc.preferred_name, qc.preferred_definition ,qc.long_name, qc.qc_idseq, vv.description_text, vv.meaning_text,
qc.created_by, qc.date_created,
qc.date_modified, qc.modified_by
from  sbrext.quest_contents_ext qc, sbrext.quest_contents_ext qc1, sbrext.valid_values_att_ext vv
where qc.qtl_name = 'VALID_VALUE' and qc1.qtl_name = 'QUESTION' and qc1.qc_idseq = qc.p_qst_idseq and qc.qc_idseq = vv.qc_idseq (+);

commit;

delete from NCI_QUEST_VV_REP;
commit;

insert into NCI_QUEST_VV_REP
(	QUEST_PUB_ID , 	QUEST_VER_NR ,
	VV_PUB_ID,	VV_VER_NR,
	VAL,EDIT_IND ,	REP_SEQ,
   CREAT_USR_ID, CREAT_DT, LST_UPD_DT,LST_UPD_USR_ID )
select q.NCI_PUB_ID, q.NCI_VER_NR, vv.NCI_PUB_ID, vv.NCI_VER_NR,
qvv.value, decode(editable_ind,'Yes',1,'No',0), repeat_sequence,
qvv.created_by, qvv.date_created,
qvv.date_modified, qvv.modified_by
from sbrext.quest_vv_ext qvv, NCI_ADMIN_ITEM_REL_ALT_KEY q, NCI_QUEST_VALID_VALUE vv
where qvv.quest_idseq = q.NCI_IDSEQ and qvv.vv_idseq = vv.NCI_IDSEQ (+);
commit;
end;
END;
/


DROP PACKAGE BODY ONEDATA_WA.NCI_CHNG_MGMT;

CREATE OR REPLACE PACKAGE BODY ONEDATA_WA.nci_CHNG_MGMT AS
v_temp_rep_ver_nr varchar2(10):='0';
v_temp_rep_id VARCHAR2(10):='0';
v_err_str      varchar2(1000) := '';
DEFAULT_TS_FORMAT    varchar2(50) := 'YYYY-MM-DD HH24:MI:SS';
type       t_orgs is table of org_cntct.org_id%type;
type t_cncpt_id is table of admin_item.item_id%type;
v_t_cncpt_id  t_cncpt_id := t_cncpt_id();
c_long_nm_len  integer := 30;
c_nm_len integer := 255;
c_ver_suffix varchar2(5) := 'v1.00';
v_dflt_txt    varchar2(100) := 'Enter text or auto-generated.';



PROCEDURE spShowClassificationNmDef   ( v_data_in IN CLOB, v_data_out OUT CLOB, v_usr_id  IN varchar2)
as

    hookInput           t_hookInput;
    hookOutput           t_hookOutput := t_hookOutput();
    showRowset     t_showableRowset;

    rows      t_rows;
    row          t_row;
    row_ori t_row;

    v_tbl_nm  varchar2(100);
    v_item_id		 number;
    v_ver_nr		 number;
begin

    hookInput := ihook.getHookInput(v_data_in);
    hookOutput.invocationNumber := hookInput.invocationNumber;
    hookOutput.originalRowset := hookInput.originalRowset;

    row_ori := hookInput.originalRowset.Rowset(1);
    v_item_id := ihook.getColumnValue(row_ori, 'ITEM_ID');
    v_ver_nr := ihook.getColumnValue(row_ori, 'VER_NR');
    v_tbl_nm := hookinput.originalRowset.tablename ;

    rows := t_rows();

    if (upper(v_tbl_nm) like '%NAME%') then
    for cur in (select * from alt_nms where item_id = v_item_id and ver_nr = v_ver_nr) loop
        row := t_row();
        ihook.setColumnValue(row,'NM_ID', cur.NM_ID);
        ihook.setColumnValue(row,'ITEM_ID', v_item_id);
        ihook.setColumnValue(row,'VER_NR', v_ver_nr);
        rows.extend; rows(rows.last) := row;
    end loop;
    showRowset := t_showableRowset(rows, 'NCI Alternate Names',2, 'unselectable');
    end if;
    if (upper(v_tbl_nm) like '%DEF%') then
    for cur in (select * from alt_def where item_id = v_item_id and ver_nr = v_ver_nr) loop
        row := t_row();
        ihook.setColumnValue(row,'DEF_ID', cur.DEF_ID);
        ihook.setColumnValue(row,'ITEM_ID', v_item_id);
        ihook.setColumnValue(row,'VER_NR', v_ver_nr);
        rows.extend; rows(rows.last) := row;
    end loop;
    showRowset := t_showableRowset(rows, 'NCI Alternate Definitions',2, 'unselectable');
    end if;

    hookOutput.showRowset := showRowset;

    hookOutput.message := 'Classification Details';
    v_data_out := ihook.getHookOutput(hookOutput);
end;

procedure spAddCSI ( v_data_in IN CLOB, v_data_out OUT CLOB, v_usr_id  IN varchar2)
as
 hookInput t_hookInput;
  hookOutput t_hookOutput := t_hookOutput();
  showRowset t_showableRowset;
  rowai t_row;
  rowcsi t_row;
  forms t_forms;
  form1 t_form;

  row t_row;
  rows  t_rows;
  row_ori t_row;
  rowset            t_rowset;
  rowsetde            t_rowset;
 v_id number;
 v_ver_nr number(4,2);
  cnt integer;

    actions t_actions := t_actions();
  action t_actionRowset;
  i integer := 0;
 bEGIN
  hookinput                    := Ihook.gethookinput (v_data_in);
  hookoutput.invocationnumber  := hookinput.invocationnumber;
  hookoutput.originalrowset    := hookinput.originalrowset;
     row_ori := hookInput.originalRowset.rowset(1);

   if (ihook.getColumnValue(row_ori,'LVL') = 98) then
   raise_application_error(-20000, 'Cannot create CSI under Context. Please choose CS or CSI.');
   return;
   end if;
    if hookInput.invocationNumber = 0 then
          HOOKOUTPUT.QUESTION    := nci_chng_mgmt.getCSICreateQuestion(1);
          row := t_row();

          ihook.setColumnValue(row, 'CURRNT_VER_IND', 1);
          ihook.setColumnValue(row, 'VER_NR', 1.0);
          ihook.setColumnValue(row, 'ADMIN_STUS_ID', 75);
          ihook.setColumnValue(row, 'REGSTR_STUS_ID', 9);
          ihook.setColumnValue(row, 'ADMIN_ITEM_TYP_ID', 51);
          ihook.setColumnValue(row, 'ITEM_LONG_NM', v_dflt_txt);

          rows := t_rows(); rows.extend;          rows(rows.last) := row;
          rowset := t_rowset(rows, 'Administered Item', 1, 'ADMIN_ITEM');
          row := t_row();
           if (ihook.getColumnValue(row_ori,'LVL') = 100) then
                ihook.setColumnValue(row,'P_ITEM_ID', ihook.getColumnValue(row_ori,'ITEM_ID'));
                ihook.setColumnValue(row,'P_ITEM_VER_NR', ihook.getColumnValue(row_ori,'VER_NR'));
                for cur1 in (select * from nci_clsfctn_schm_item where item_id = ihook.getColumnValue(row_ori,'ITEM_ID') and ver_nr = ihook.getColumnValue(row_ori,'VER_NR')) loop
                ihook.setColumnValue(row,'CS_ITEM_ID', cur1.cs_item_id);
                ihook.setColumnValue(row,'CS_ITEM_VER_NR', cur1.cs_item_ver_nr);
                end loop;
            end if;
            if (ihook.getColumnValue(row_ori,'LVL') =99) then
                ihook.setColumnValue(row,'CS_ITEM_ID', ihook.getColumnValue(row_ori,'ITEM_ID'));
                ihook.setColumnValue(row,'CS_ITEM_VER_NR', ihook.getColumnValue(row_ori,'VER_NR'));
            end if;
            ihook.setColumnValue(row,'ITEM_ID', -1);
            ihook.setColumnValue(row,'VER_NR', 1);

                 rows := t_rows(); rows.extend;          rows(rows.last) := row;
                 rowsetde := t_rowset(rows, 'CSI', 1, 'NCI_CLSFCTN_SCHM_ITEM');
          hookOutput.forms := nci_chng_mgmt.getCSICreateForm(rowset, rowsetde);
  ELSE
            forms              := hookInput.forms;
            form1              := forms(1);
            rowai := form1.rowset.rowset(1);
            form1              := forms(2);
            rowcsi := form1.rowset.rowset(1);

            v_id := nci_11179.getItemId;

            ihook.setColumnValue(rowai,'ITEM_ID', v_id);
            ihook.setColumnValue(rowai,'ADMIN_ITEM_TYP_ID', 51);
            ihook.setColumnValue(rowai,'ITEM_LONG_NM', v_id || 'v1.00');

            ihook.setColumnValue(rowcsi,'ITEM_ID', v_id);
            ihook.setColumnValue(rowcsi,'VER_NR', 1.0);
            if (ihook.getColumnValue(rowcsi,'P_ITEM_ID') is not null) then
    -- use CS from Parent
                for cur1 in (select * from vw_clsfctn_schm_item where item_id = ihook.getColumnValue(rowcsi,'P_ITEM_ID') and ver_nr = ihook.getColumnValue(rowcsi,'P_ITEM_VER_NR')) loop
                    ihook.setColumnValue(rowcsi,'CS_ITEM_ID', cur1.cs_item_id);
                    ihook.setColumnValue(rowcsi,'CS_ITEM_VER_NR', cur1.cs_item_VER_NR);
                end loop;
            end if;
            -- Context is context of CS
            for cur1 in (select * from admin_item where item_id = ihook.getColumnValue(rowcsi,'CS_ITEM_ID') and ver_nr = ihook.getColumnValue(rowcsi,'CS_ITEM_VER_NR')) loop
                ihook.setColumnValue(rowai, 'CNTXT_ITEM_ID', cur1.CNTXT_ITEM_ID);
                ihook.setColumnValue(rowai, 'CNTXT_VER_NR', cur1.CNTXT_VER_NR);
            end loop;

            rows := t_rows();    rows.extend;    rows(rows.last) := rowai;
            action := t_actionrowset(rows, 'Administered Item (No Sequence)', 2,1,'insert');
            actions.extend;    actions(actions.last) := action;

            rows := t_rows();    rows.extend;    rows(rows.last) := rowcsi;
            action := t_actionrowset(rows, 'CSI', 2,2,'insert');
            actions.extend;    actions(actions.last) := action;

            hookoutput.message := 'CSI Created Successfully with ID ' || v_id ;
            hookoutput.actions := actions;

    end if;

  V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);

END;


procedure spEditCSI ( v_data_in IN CLOB, v_data_out OUT CLOB, v_usr_id  IN varchar2)
as
 hookInput t_hookInput;
  hookOutput t_hookOutput := t_hookOutput();
  showRowset t_showableRowset;
  rowai t_row;
  rowcsi t_row;
  forms t_forms;
  form1 t_form;

  row t_row;
  rows  t_rows;
  row_ori t_row;
  rowset            t_rowset;
  rowsetde            t_rowset;
 v_item_id number;
 v_ver_nr number(4,2);
  cnt integer;

    actions t_actions := t_actions();
  action t_actionRowset;
  i integer := 0;
 bEGIN
  hookinput                    := Ihook.gethookinput (v_data_in);
  hookoutput.invocationnumber  := hookinput.invocationnumber;
  hookoutput.originalrowset    := hookinput.originalrowset;
     row_ori := hookInput.originalRowset.rowset(1);
      v_item_id := ihook.getColumnValue(row_ori,'ITEM_ID');
          v_ver_nr := ihook.getColumnValue(row_ori,'VER_NR');

   if (ihook.getColumnValue(row_ori,'LVL') <> 100) then
   raise_application_error(-20000, 'Please select a CSI to edit.');
   return;
   end if;
    if hookInput.invocationNumber = 0 then
          HOOKOUTPUT.QUESTION    := nci_chng_mgmt.getCSICreateQuestion(2);
          v_item_id := ihook.getColumnValue(row_ori,'ITEM_ID');
          v_ver_nr := ihook.getColumnValue(row_ori,'VER_NR');
          row := t_row();
          nci_11179.spReturnAIRow(v_item_id, v_ver_nr, row);

          rows := t_rows(); rows.extend;          rows(rows.last) := row;
          rowset := t_rowset(rows, 'Administered Item', 1, 'ADMIN_ITEM');
          row := t_row();
          nci_11179.spReturnSubtypeRow(v_item_id, v_ver_nr,51, row);

                 rows := t_rows(); rows.extend;          rows(rows.last) := row;
                 rowsetde := t_rowset(rows, 'CSI', 1, 'NCI_CLSFCTN_SCHM_ITEM');
          hookOutput.forms := nci_chng_mgmt.getCSICreateForm(rowset, rowsetde);
  ELSE
            forms              := hookInput.forms;
            form1              := forms(1);
            rowai := form1.rowset.rowset(1);
            form1              := forms(2);
            rowcsi := form1.rowset.rowset(1);

            ihook.setColumnValue(rowai,'ITEM_ID', v_item_id);
             ihook.setColumnValue(rowai,'VER_NR', v_ver_nr);
           ihook.setColumnValue(rowai,'ADMIN_ITEM_TYP_ID', 51);
            ihook.setColumnValue(rowai,'ITEM_LONG_NM', v_item_id || 'v1.00');

            ihook.setColumnValue(rowcsi,'ITEM_ID', v_item_id);
            ihook.setColumnValue(rowcsi,'VER_NR', v_ver_nr);
            if (ihook.getColumnValue(rowcsi,'P_ITEM_ID') is not null) then
             if (nci_11179_2.isCSParentCSIValid(rowcsi) = false) then
                HOOKOUTPUT.QUESTION    := nci_chng_mgmt.getCSICreateQuestion(2);
                rows := t_rows(); rows.extend;          rows(rows.last) := rowai;
                rowset := t_rowset(rows, 'Administered Item', 1, 'ADMIN_ITEM');

                 rows := t_rows(); rows.extend;          rows(rows.last) := rowcsi;
                 rowsetde := t_rowset(rows, 'CSI', 1, 'NCI_CLSFCTN_SCHM_ITEM');
          hookOutput.forms := nci_chng_mgmt.getCSICreateForm(rowset, rowsetde);
         hookoutput.message := 'Parent CSI should belong to the same Classification Scheme as specified.';
             end if;
          /*      for cur1 in (select * from vw_clsfctn_schm_item where item_id = ihook.getColumnValue(rowcsi,'P_ITEM_ID') and ver_nr = ihook.getColumnValue(rowcsi,'P_ITEM_VER_NR')) loop
                    ihook.setColumnValue(rowcsi,'CS_ITEM_ID', cur1.cs_item_id);
                    ihook.setColumnValue(rowcsi,'CS_ITEM_VER_NR', cur1.cs_item_VER_NR);
                end loop; */
            end if;
            -- Context is context of CS
             if (nci_11179_2.isCSParentCSIValid(rowcsi) = true) then
            for cur1 in (select * from admin_item where item_id = ihook.getColumnValue(rowcsi,'CS_ITEM_ID') and ver_nr = ihook.getColumnValue(rowcsi,'CS_ITEM_VER_NR')) loop
                ihook.setColumnValue(rowai, 'CNTXT_ITEM_ID', cur1.CNTXT_ITEM_ID);
                ihook.setColumnValue(rowai, 'CNTXT_VER_NR', cur1.CNTXT_VER_NR);
            end loop;

            rows := t_rows();    rows.extend;    rows(rows.last) := rowai;
            action := t_actionrowset(rows, 'Administered Item (No Sequence)', 2,1,'update');
            actions.extend;    actions(actions.last) := action;

            rows := t_rows();    rows.extend;    rows(rows.last) := rowcsi;
            action := t_actionrowset(rows, 'CSI', 2,2,'update');
            actions.extend;    actions(actions.last) := action;

            hookoutput.message := 'CSI updated Successfully with ID ' || v_item_id ;
            hookoutput.actions := actions;
            end if;
    end if;

  V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
  nci_util.debugHook('GENERAL', v_data_out);
END;


procedure spDeleteCSI ( v_data_in IN CLOB, v_data_out OUT CLOB, v_usr_id  IN varchar2)
as
 hookInput t_hookInput;
  hookOutput t_hookOutput := t_hookOutput();
  showRowset t_showableRowset;
  rowai t_row;
  rowcsi t_row;
  forms t_forms;
  form1 t_form;
  row t_row;
  rows  t_rows;
  row_ori t_row;
  rowset            t_rowset;
  rowsetde            t_rowset;
 v_item_id number;
 v_ver_nr number(4,2);
  cnt integer;

    actions t_actions := t_actions();
  action t_actionRowset;
  i integer := 0;
 BEGIN
  hookinput                    := Ihook.gethookinput (v_data_in);
  hookoutput.invocationnumber  := hookinput.invocationnumber;
  hookoutput.originalrowset    := hookinput.originalrowset;
     row_ori := hookInput.originalRowset.rowset(1);

   if (ihook.getColumnValue(row_ori,'LVL') <> 100) then
   raise_application_error(-20000, 'Please select a CSI to delete.');
   return;
   end if;
     v_item_id := ihook.getColumnValue(row_ori,'ITEM_ID');
          v_ver_nr := ihook.getColumnValue(row_ori,'VER_NR');

   for cur in (select ai.* from admin_item ai, nci_clsfctn_schm_item csi where p_item_id= v_item_id and p_item_ver_nr = v_ver_nr and nvl(ai.fld_delete,0) = 0
   and csi.item_id = ai.item_id and csi.ver_nr = ai.ver_nr and upper(ai.admin_stus_nm_dn) not like '%DELETED%') loop
    raise_application_error(-20000, 'Select CSI has children nodes. Please move children before deleting.');
    end loop;

   for cur in (select * from NCI_CSI_ALT_DEFNMS where  NCI_PUB_ID =v_item_id and NCI_VER_NR = v_ver_nr and nvl(fld_delete,0) = 0) loop
        raise_application_error(-20000, 'CSI linked to Alternate Names or Definition classifications. Please delete before CSI can be deleted.');
    end loop;


   for cur in (select * from NCI_ADMIN_ITEM_REL where  P_ITEM_ID= v_item_id and P_ITEM_VER_NR = v_ver_nr and rel_typ_id = 65 and nvl(fld_delete,0) = 0) loop
        raise_application_error(-20000, 'Classifications found for this CSI. Please delete classification before CSI can be deleted.');
    end loop;

   row := t_row();
          nci_11179.spReturnAIRow(v_item_id, v_ver_nr, row);
            ihook.setColumnValue(row,'ADMIN_STUS_ID', 77);
              ihook.setColumnValue(row,'UNTL_DT', to_char(sysdate, DEFAULT_TS_FORMAT) );

            rows := t_rows();    rows.extend;    rows(rows.last) := row;
            action := t_actionrowset(rows, 'Administered Item (No Sequence)', 2,1,'update');
            actions.extend;    actions(actions.last) := action;


            hookoutput.message := 'CSI deleted Successfully with ID ' || v_item_id ;
            hookoutput.actions := actions;


  V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);

END;

PROCEDURE spCreateDE (v_data_in IN CLOB,    v_data_out OUT CLOB, v_usr_id  IN varchar2, v_src in varchar2)
AS
    hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();
    showRowset t_showableRowset;
    rowai t_row;
    rowde t_row;
    forms t_forms;
    form1 t_form;
    c_ver_suffix varchar2(5) := 'v1.00';
    row t_row;
    rows  t_rows;
    row_ori t_row;
    rowset            t_rowset;
    rowsetai            t_rowset;
    rowsetde            t_rowset;
         v_item_id  number;
         v_item_type_id  number;

    v_prop_long_nm varchar2(255);
    v_prop_def  varchar2(2000);
    v_dec_item_id number;
    v_str  varchar2(255);
    v_nm  varchar2(255);
    v_id number;
    v_ver_nr number(4,2);
    cnt integer;
    actions t_actions := t_actions();
    action t_actionRowset;
    v_msg varchar2(1000);
    i integer := 0;
    v_err  integer;
    column  t_column;
    v_item_nm varchar2(255);
    v_cncpt_nm varchar2(255);
    v_long_nm varchar2(255);
    v_item_def varchar2(4000);
    v_oc_id number;
    v_unq_id number;
    v_unq_ver number(4,2);
    v_temp_id  number;
    v_temp_ver number(4,2);
    is_valid boolean;
    V_valid boolean;
    v_err_str varchar2(4000);
BEGIN
  hookinput                    := Ihook.gethookinput (v_data_in);
  hookoutput.invocationnumber  := hookinput.invocationnumber;
  hookoutput.originalrowset    := hookinput.originalrowset;
    if hookInput.invocationNumber = 0 then
    if (v_src = 'C') then -- create new
          HOOKOUTPUT.QUESTION    := nci_chng_mgmt.getDECreateQuestion(1,true);
          row := t_row();
          rows := t_rows();
       nci_11179_2.setStdAttr(row);
             ihook.setColumnValue(row, 'ADMIN_ITEM_TYP_ID', 4);
          ihook.setColumnValue(row, 'ITEM_NM', v_dflt_txt);
          ihook.setColumnValue(row, 'ITEM_DESC', v_dflt_txt);
          ihook.setColumnValue(row, 'ITEM_LONG_NM', v_dflt_txt);
                   rows.extend;
          rows(rows.last) := row;
          rowset := t_rowset(rows, 'Administered Item', 1, 'ADMIN_ITEM');
          rows := t_rows();
          row := t_row();
          ihook.setColumnValue(row, 'PREF_QUEST_TXT', v_dflt_txt);
          rows.extend;
          rows(rows.last) := row;
          rowsetde := t_rowset(rows, 'Data Element', 1, 'DE');
          hookOutput.forms := nci_chng_mgmt.getDECreateForm(rowset, rowsetde);
    end if;
    if (v_src = 'E') then -- create from Existing

    row_ori :=  hookInput.originalRowset.rowset(1);
    v_item_id := ihook.getColumnValue(row_ori, 'ITEM_ID');
    v_ver_nr := ihook.getColumnValue(row_ori, 'VER_NR');
    v_item_type_id := ihook.getColumnValue(row_ori, 'ADMIN_ITEM_TYP_ID');


    if (v_item_type_id <> 4) then -- 4 - CDE in table OBJ_KEY
        raise_application_error(-20000,'!!! This functionality is only applicable for CDE !!!');
    end if;

        HOOKOUTPUT.QUESTION    := nci_chng_mgmt.getDECreateQuestion(2,true);
        row := row_ori;
        rows := t_rows();
       nci_11179_2.setStdAttr(row);
             ihook.setColumnValue(row, 'ITEM_ID', -1);
 ihook.setColumnValue(row, 'ITEM_LONG_NM', v_dflt_txt);

         rows.extend;
        rows(rows.last) := row;
        rowsetai := t_rowset(rows, 'Administered Item', 1, 'ADMIN_ITEM'); -- Default values for form
        rows := t_rows();
        row := t_row();
        -- Copy DE specific attributes
        nci_11179.spReturnSubtypeRow (v_item_id, v_ver_nr, 4, row );
        rows.extend;
        rows(rows.last) := row;
        rowsetde := t_rowset(rows, 'Data Element', 1, 'DE'); -- Default values for form
        hookOutput.forms := nci_chng_mgmt.getDECreateForm(rowsetai, rowsetde);
  end if;
  ELSE
      forms              := hookInput.forms;
      form1              := forms(1);
      rowai := form1.rowset.rowset(1);
      form1              := forms(2);
      rowde := form1.rowset.rowset(1);
       row := t_row();
      rows := t_rows();

      v_valid := true;

      for cur in (select ai.item_id from  admin_item ai, de de
            where ai.item_id = de.item_id and ai.ver_nr = de.ver_nr
            and de.de_conc_item_id = ihook.getColumnValue(rowde, 'DE_CONC_ITEM_ID')
            and de.de_conc_ver_nr =  ihook.getColumnValue(rowde, 'DE_CONC_VER_NR')
            and de.val_dom_item_id =  ihook.getColumnValue(rowde, 'VAL_DOM_ITEM_ID')
            and de.val_dom_ver_nr =  ihook.getColumnValue(rowde, 'VAL_DOM_VER_NR')
            and ai.cntxt_item_id = ihook.getColumnValue(rowai, 'CNTXT_ITEM_ID')
            and  ai.cntxt_ver_nr = ihook.getColumnValue(rowai, 'CNTXT_VER_NR')) loop
                v_valid := false;
                 hookoutput.message := 'Duplicate CDE found based on DEC/VD/Context: ' ||cur.item_id;
        end loop;


      if (v_valid = true) then
          nci_11179_2.stdAIValidation(rowai, 4,v_valid, v_err_str);
        if (v_valid = false) then
        hookoutput.message := v_err_str;
        end if;
        end if;

-- Derivation rule/Derivation Type
    if (v_valid = true and ( (ihook.getColumnValue (rowde, 'DERV_TYP_ID') is not null and ihook.getColumnValue (rowde, 'DERV_RUL') is null) or
        (ihook.getColumnValue (rowde, 'DERV_TYP_ID') is null and ihook.getColumnValue (rowde, 'DERV_RUL') is not null))) then
                v_valid := false;
                hookoutput.message := 'Derivation Type or Derivation Rule is missing. ';
        end if;

    select substr(dec.item_nm || ' ' || vd.item_nm,1,255) ,substr(dec.item_desc || ':' || vd.item_desc,  1, 4000) into v_item_nm, v_item_def from admin_item dec, admin_item vd
            where dec.item_id = ihook.getColumnValue(rowde, 'DE_CONC_ITEM_ID') and dec.ver_nr =  ihook.getColumnValue(rowde, 'DE_CONC_VER_NR')
            and vd.item_id =  ihook.getColumnValue(rowde, 'VAL_DOM_ITEM_ID') and vd.ver_nr = ihook.getColumnValue(rowde, 'VAL_DOM_VER_NR');

   if hookinput.answerid = 1 or v_valid = false then --Validate

        ihook.setColumnValue(rowai,'ITEM_NM', v_item_nm);

        ihook.setColumnValue(rowai,'ITEM_DESC',v_item_def);
        ihook.setColumnValue(rowai,'ADMIN_ITEM_TYP_ID',4);

        if hookinput.answerid = 1 and v_valid = true then --Validate
            hookoutput.message := 'Validation Successful';
        end if;

          rows.extend;
          rows(rows.last) := rowai;
          rowset := t_rowset(rows, 'Administered Item', 1, 'ADMIN_ITEM');
          rows := t_rows();
            rows.extend;
          rows(rows.last) := rowde;
          rowsetde := t_rowset(rows, 'Data Element', 1, 'DE');
           v_valid := false;
          hookOutput.forms := nci_chng_mgmt.getDECreateForm(rowset, rowsetde);
          if (v_src = 'E') then
          HOOKOUTPUT.QUESTION    := nci_chng_mgmt.getDECreateQuestion(2,v_valid);
          else
          HOOKOUTPUT.QUESTION    := nci_chng_mgmt.getDECreateQuestion(1,v_valid);
          end if;

          --V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);

    end if;

    if (hookinput.answerid = 2 and v_valid = true) then

       v_id := nci_11179.getItemId;
       row := t_row();
        ihook.setColumnValue(rowai,'ITEM_ID', v_id);
        ihook.setColumnValue(rowai,'ADMIN_ITEM_TYP_ID', 4);

         select substr(dec.item_nm || ' ' || vd.item_nm,1,255) ,substr(dec.item_desc || ':' || vd.item_desc,  1, 4000) into v_item_nm, v_item_def from admin_item dec, admin_item vd
            where dec.item_id = ihook.getColumnValue(rowde, 'DE_CONC_ITEM_ID') and dec.ver_nr =  ihook.getColumnValue(rowde, 'DE_CONC_VER_NR')
            and vd.item_id =  ihook.getColumnValue(rowde, 'VAL_DOM_ITEM_ID') and vd.ver_nr = ihook.getColumnValue(rowde, 'VAL_DOM_VER_NR');

        if ( ihook.getColumnValue(rowai,'ITEM_LONG_NM')= v_dflt_txt or ihook.getColumnValue(rowai,'ITEM_LONG_NM') is null or upper(ihook.getColumnValue(rowai,'ITEM_LONG_NM')) = 'SYSGEN') then
        ihook.setColumnValue(rowai,'ITEM_LONG_NM', ihook.getColumnValue(rowde, 'DE_CONC_ITEM_ID') || 'v'
        || trim(to_char(ihook.getColumnValue(rowde, 'DE_CONC_VER_NR'), '9999.99')) || ':' || ihook.getColumnValue(rowde, 'VAL_DOM_ITEM_ID') || 'v' ||
        trim(to_char(ihook.getColumnValue(rowde, 'VAL_DOM_VER_NR'), '9999.99')));
        end if;
        if ( ihook.getColumnValue(rowai,'ITEM_NM')= v_dflt_txt) then
        ihook.setColumnValue(rowai,'ITEM_NM', v_item_nm);
        end if;
        if ( ihook.getColumnValue(rowai,'ITEM_DESC')= v_dflt_txt) then
        ihook.setColumnValue(rowai,'ITEM_DESC',v_item_def);
        end if;
        if (ihook.getColumnValue(rowde, 'PREF_QUEST_TXT') = v_dflt_txt) then
        ihook.setColumnValue(rowde, 'PREF_QUEST_TXT', 'Data Element ' || v_item_nm|| ' does not have Preferred Question Text.'   );
        end if;

    rows := t_rows();
    rows.extend;
    rows(rows.last) := rowai;
    action := t_actionrowset(rows, 'Administered Item (No Sequence)', 2,1,'insert');
    actions.extend;
    actions(actions.last) := action;


    ihook.setColumnValue(rowde,'ITEM_ID', v_id);
    ihook.setColumnValue(rowde,'VER_NR', 1.00);

             rows := t_rows();
    rows.extend;
    rows(rows.last) := rowde;

    action := t_actionrowset(rows, 'Data Element', 2,2,'insert');
    actions.extend;
    actions(actions.last) := action;

   if (ihook.getColumnValue(rowde, 'PREF_QUEST_TXT')=v_dflt_txt) then
   ihook.setColumnValue(rowde, 'PREF_QUEST_TXT', 'Data Element ' || v_item_nm|| ' does not have Preferred Question Text.'   );
   end if;



    if (ihook.getColumnValue(rowde, 'PREF_QUEST_TXT') is not null) then
        row := t_row ();
        ihook.setColumnValue(row,'ITEM_ID', v_id);
    ihook.setColumnValue(row,'VER_NR', 1.00);
     ihook.setColumnValue(row,'REF_NM', substr(ihook.getColumnValue(rowde, 'PREF_QUEST_TXT'),1,255));
     ihook.setColumnValue(row,'REF_DESC', ihook.getColumnValue(rowde, 'PREF_QUEST_TXT'));
     ihook.setColumnValue(row,'LANG_ID', 1000);
     ihook.setColumnValue(row,'NCI_CNTXT_ITEM_ID',ihook.getColumnValue(rowai, 'CNTXT_ITEM_ID')  );
     ihook.setColumnValue(row,'NCI_CNTXT_VER_NR',ihook.getColumnValue(rowai, 'CNTXT_VER_NR')  );
     ihook.setColumnValue(row,'REF_TYP_ID', 80);

     ihook.setColumnValue(row,'REF_ID', -1);
     rows := t_rows();
     rows.extend;
    rows(rows.last) := row;
    action := t_actionrowset(rows, 'References (for hook insert)', 2,3,'insert');
    actions.extend;
    actions(actions.last) := action;
    end if;

    -- Add derivation components if Createe from Existing
    -- if Derivation Type is set and there are components in the original DDE
    if (v_src = 'E') then
        row_ori :=  hookInput.originalRowset.rowset(1);
        v_item_id := ihook.getColumnValue(row_ori, 'ITEM_ID');
        v_ver_nr := ihook.getColumnValue(row_ori, 'VER_NR');

        if (ihook.getColumnValue(rowde, 'DERV_TYP_ID') is not null ) then
          nci_11179_2.copyDDEComponents(v_item_id, v_ver_nr, v_id, 1, actions);
        end if;
    end if;
          hookoutput.message := 'CDE Created Successfully with ID ' || v_id ;
        hookoutput.actions := actions;
 end if;
 end if;
  V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);

END;


PROCEDURE spCreateCS (v_data_in IN CLOB,    v_data_out OUT CLOB, v_usr_id  IN varchar2)
AS
    hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();
    showRowset t_showableRowset;
    rowai t_row;
    rowcs t_row;
    forms t_forms;
    form1 t_form;
    c_ver_suffix varchar2(5) := 'v1.00';
    row t_row;
    rows  t_rows;
    rowset            t_rowset;
    rowsetai            t_rowset;
    rowsetcs            t_rowset;
         v_item_id  number;
         v_item_typ_id  number;

    v_str  varchar2(255);
    v_nm  varchar2(255);
    v_id number;
    v_ver_nr number(4,2);

    actions t_actions := t_actions();
    action t_actionRowset;
    v_long_nm varchar2(255);

    v_temp_id  number;
    v_temp_ver number(4,2);
    v_valid boolean;

BEGIN
  hookinput                    := Ihook.gethookinput (v_data_in);
  hookoutput.invocationnumber  := hookinput.invocationnumber;
  hookoutput.originalrowset    := hookinput.originalrowset;
  v_item_typ_id := 9;

    if hookInput.invocationNumber = 0 then
           HOOKOUTPUT.QUESTION    := getCSCreateQuestion;
          row := t_row();
          rows := t_rows();
          ihook.setColumnValue(row, 'CURRNT_VER_IND', 1);
          ihook.setColumnValue(row, 'VER_NR', 1.0);
          ihook.setColumnValue(row, 'ADMIN_STUS_ID', 66);
          ihook.setColumnValue(row, 'REGSTR_STUS_ID', 9);
          ihook.setColumnValue(row, 'ADMIN_ITEM_TYP_ID', v_item_typ_id);
          ihook.setColumnValue(row, 'ITEM_LONG_NM', v_dflt_txt);
          rows.extend;
          rows(rows.last) := row;
          rowsetai := t_rowset(rows, 'Administered Item', 1, 'ADMIN_ITEM');
           rows := t_rows();
          row := t_row();
            ihook.setColumnValue(row, 'ITEM_ID', -1);
          ihook.setColumnValue(row, 'VER_NR', 1);
            rows.extend;
          rows(rows.last) := row;

          rowsetcs := t_rowset(rows, 'Classification Scheme', 1, 'CLSFCTN_SCHM');

          hookOutput.forms := nci_chng_mgmt.getCSCreateForm(rowsetai, rowsetcs);


  ELSE
      forms              := hookInput.forms;
      form1              := forms(1);
      rowai := form1.rowset.rowset(1);
      form1              := forms(2);
      rowcs := form1.rowset.rowset(1);
      v_valid := true;
          nci_11179_2.stdAIValidation(rowai, v_item_typ_id ,v_valid, v_err_str);
        if (v_valid = false) then
        hookoutput.message := v_err_str;
        end if;


        if v_valid = false then --Validate
            rows := t_rows();
            rows.extend;          rows(rows.last) := rowai;
            rowset := t_rowset(rows, 'Administered Item', 1, 'ADMIN_ITEM');
            rows := t_rows();
            rows.extend;          rows(rows.last) := rowcs;
            rowsetcs := t_rowset(rows, 'Classification Scheme', 1, 'CLSFCTN_SCHM');
            v_valid := false;
             hookOutput.forms := nci_chng_mgmt.getCSCreateForm(rowset, rowsetcs);
            HOOKOUTPUT.QUESTION    := nci_chng_mgmt.getCSCreateQuestion;
          --V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);

        end if;

        if ( v_valid = true) then
            v_id := nci_11179.getItemId;
                ihook.setColumnValue(rowai,'ITEM_ID', v_id);
                ihook.setColumnValue(rowai,'ADMIN_ITEM_TYP_ID', v_item_typ_id);

                 if ( ihook.getColumnValue(rowai,'ITEM_LONG_NM')= v_dflt_txt) then
                    ihook.setColumnValue(rowai,'ITEM_LONG_NM', v_id ||'v1.00');
                end if;

            rows := t_rows();
            rows.extend;    rows(rows.last) := rowai;
            action := t_actionrowset(rows, 'Administered Item (No Sequence)', 2,1,'insert');
            actions.extend;
            actions(actions.last) := action;

             ihook.setColumnValue(rowcs,'ITEM_ID', v_id);
            ihook.setColumnValue(rowcs,'VER_NR', 1.00);
             rows := t_rows();
            rows.extend;    rows(rows.last) := rowcs;

            action := t_actionrowset(rows, 'Classification Scheme', 2,2,'insert');
            actions.extend;
            actions(actions.last) := action;
            hookoutput.message := 'CS Created Successfully with ID ' || v_id ;
                hookoutput.actions := actions;
        end if;
 end if;
  V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
  nci_util.debugHook('GENERAL', v_data_out);
END;

PROCEDURE spDEValCreateImport (rowform in out t_row, v_op in varchar2, actions in out t_actions, v_val_ind in out boolean)
AS
    c_ver_suffix varchar2(5) := 'v1.00';
    row t_row;
    rows  t_rows;

    v_dec_item_id number;
    v_dec_ver_nr number(4,2);
    v_vd_item_id number;
    v_vd_ver_nr number(4,2);

    v_nm  varchar2(255);
    v_id number;
    action t_actionRowset;
    v_item_nm varchar2(255);
    v_dec_item_nm varchar2(255);
    v_dec_item_def varchar2(4000);
    v_vd_item_nm varchar2(255);
    v_vd_item_def  varchar2(4000);
    v_item_def varchar2(4000);

BEGIN
       row := t_row();
       rows := t_rows();

-- if DEC specified or found, if VD specified
        v_dec_item_id := nvl(ihook.getColumnValue(rowform, 'DE_CONC_ITEM_ID') ,ihook.getColumnValue(rowform, 'DE_CONC_ITEM_ID_FND'));
        v_dec_ver_nr := nvl(ihook.getColumnValue(rowform, 'DE_CONC_VER_NR') ,ihook.getColumnValue(rowform, 'DE_CONC_VER_NR_FND'));
        v_vd_item_id := ihook.getColumnValue(rowform, 'VAL_DOM_ITEM_ID') ;
        v_vd_ver_nr := ihook.getColumnValue(rowform, 'VAL_DOM_VER_NR') ;


        if (v_op = 'V') and v_dec_item_id is not null and v_vd_item_id is not null then  --- check if CDE is a duplicate
            for cur in (select ai.item_id item_id from admin_item ai, de de
            where ai.item_id = de.item_id and ai.ver_nr = de.ver_nr
            and de.de_conc_item_id = v_dec_item_id
            and de.de_conc_ver_nr =  v_dec_ver_nr
            and de.val_dom_item_id =  v_vd_item_id
            and de.val_dom_ver_nr =  v_vd_ver_nr
            and ai.cntxt_item_id = ihook.getColumnValue(rowform, 'CNTXT_ITEM_ID')
            and  ai.cntxt_ver_nr = ihook.getColumnValue(rowform, 'CNTXT_VER_NR')) loop
                v_val_ind := false;
                ihook.setColumnValue(rowform, 'CTL_VAL_MSG', 'Duplicate CDE found : ' || cur.item_id);
                return;
            end loop;
         end if;

        if (v_op = 'V') and ihook.getColumnValue(rowform, 'CDE_ITEM_LONG_NM') is not null then  --- check if CDE short name specirfied
       -- raise_application_Error(-20000, ihook.getColumnValue(rowform, 'CDE_ITEM_LONG_NM'));
            for cur in (select ai.item_id item_id from admin_item ai, de de
            where ai.item_id = de.item_id and ai.ver_nr = de.ver_nr
            and ai.ITEM_LONG_NM=ihook.getColumnValue(rowform,'CDE_ITEM_LONG_NM')
            and  ai.ver_nr =  1
            and ai.cntxt_item_id = ihook.getColumnValue(rowform, 'CNTXT_ITEM_ID')
            and  ai.cntxt_ver_nr = ihook.getColumnValue(rowform, 'CNTXT_VER_NR')) loop
                v_val_ind := false;
                ihook.setColumnValue(rowform, 'CTL_VAL_MSG', ihook.getColumnValue(rowform, 'CTL_VAL_MSG') || 'Duplicate CDE found based on context/short name: ' || cur.item_id || chr(13));
                return;
            end loop;
        end if;



    if (v_op = 'C') then -- create
        row := t_row();

    -- Item name - DE name if specified; DEC NAme - specified/found/generated; vd name - specified/generated
   --     raise_application_error(-20000, 'Front' || v_dec_item_id);

        if (v_dec_item_id is not null) then
                select item_nm, item_desc into v_dec_item_nm, v_dec_item_def from admin_item where item_id = v_dec_item_id and ver_nr = v_dec_ver_nr;
        else
                v_dec_item_nm := ihook.getColumnValue(rowform, 'GEN_DE_CONC_NM');
                v_dec_item_def := substr(ihook.getColumnValue(rowform, 'ITEM_1_DEF')  || ':' || ihook.getColumnValue(rowform, 'ITEM_2_DEF'),1,4000);
        end if;

        if (v_vd_item_id is not null) then
                select item_nm, item_desc into v_vd_item_nm, v_vd_item_def from admin_item where item_id = v_vd_item_id and ver_nr = v_vd_ver_nr;
        else
                v_vd_item_nm := ihook.getColumnValue(rowform, 'VAL_DOM_NM')  ;
                v_vd_item_def := ihook.getColumnValue(rowform, 'ITEM_3_DEF');
        end if;

        if (ihook.getColumnValue(rowform, 'CDE_ITEM_NM') is not null) then
            ihook.setColumnValue(row, 'ITEM_NM',ihook.getColumnValue(rowform, 'CDE_ITEM_NM'));
        else
            ihook.setColumnValue(row, 'ITEM_NM',substr(v_dec_item_nm || ' ' || v_vd_item_nm, 1, 255));
        end if;
    -- item def - DEC def - specified/found.genetered; vd def - specified/generated
 --  raise_application_error(-20000, 'Above ' || v_dec_item_def || 'After');
   -- raise_application_error(-20000, 'Above ' );

          ihook.setColumnValue(row, 'ITEM_DESC',substr(v_dec_item_def || ' ' || v_vd_item_def,1,4000));
          ihook.setColumnValue(row, 'ITEM_DESC',v_dec_item_def);
            ihook.setColumnValue(row, 'PREF_QUEST_TXT',nvl(ihook.getColumnValue(rowform, 'PREF_QUEST_TXT'),'Data Element ' || v_item_nm|| ' does not have Preferred Question Text.'   ));
            ihook.setColumnValue(rowform, 'PREF_QUEST_TXT',nvl(ihook.getColumnValue(rowform, 'PREF_QUEST_TXT'),'Data Element ' || v_item_nm|| ' does not have Preferred Question Text.'   ));

       v_id := nci_11179.getItemId;

        ihook.setColumnValue(row,'ITEM_ID', v_id);
        ihook.setColumnValue(row,'VER_NR', 1);
        ihook.setColumnValue(row,'CURRNT_VER_IND', 1);
        ihook.setColumnValue(row,'ADMIN_ITEM_TYP_ID', 4);

        ihook.setColumnValue(row,'ITEM_LONG_NM', nvl( ihook.getColumnValue(rowform, 'CDE_ITEM_LONG_NM'), v_id || c_ver_suffix));

        ihook.setColumnValue(row,'CNTXT_ITEM_ID', ihook.getColumnValue(rowform,'CNTXT_ITEM_ID'));
        ihook.setColumnValue(row,'CNTXT_VER_NR', ihook.getColumnValue(rowform,'CNTXT_VER_NR'));
        ihook.setColumnValue(row,'ADMIN_STUS_ID',66);
        ihook.setColumnValue(row,'REGSTR_STUS_ID',9);
        ihook.setColumnValue(row,'DE_CONC_ITEM_ID',nvl(v_dec_item_id, ihook.getColumnValue(rowform, 'DE_CONC_ITEM_ID_CREAT') ));
        ihook.setColumnValue(row,'DE_CONC_VER_NR',nvl(v_dec_ver_nr, 1 ));
        ihook.setColumnValue(row,'VAL_DOM_ITEM_ID',nvl(v_vd_item_id, ihook.getColumnValue(rowform, 'VAL_DOM_ITEM_ID_CREAT') ));
        ihook.setColumnValue(row,'VAL_DOM_VER_NR',nvl(v_vd_ver_nr, 1 ));
  --  raise_application_error(-20000, 'Here' || ihook.getColumnValue(row, 'ITEM_DESC') );

        rows.extend;
        rows(rows.last) := row;
        action := t_actionrowset(rows, 'Administered Item (No Sequence)', 2,10,'insert');
        actions.extend;
        actions(actions.last) := action;

        action := t_actionrowset(rows, 'Data Element', 2,11,'insert');
        actions.extend;
        actions(actions.last) := action;

        row := t_row ();
        ihook.setColumnValue(row,'ITEM_ID', v_id);
    ihook.setColumnValue(row,'VER_NR', 1.00);
     ihook.setColumnValue(row,'REF_NM', substr(ihook.getColumnValue(rowform, 'PREF_QUEST_TXT'),1,255));
     ihook.setColumnValue(row,'REF_DESC', ihook.getColumnValue(rowform, 'PREF_QUEST_TXT'));
     ihook.setColumnValue(row,'LANG_ID', 1000);
     ihook.setColumnValue(row,'NCI_CNTXT_ITEM_ID',ihook.getColumnValue(rowform, 'CNTXT_ITEM_ID')  );
     ihook.setColumnValue(row,'NCI_CNTXT_VER_NR',ihook.getColumnValue(rowform, 'CNTXT_VER_NR')  );
     ihook.setColumnValue(row,'REF_TYP_ID', 80);

     ihook.setColumnValue(row,'REF_ID', -1);
     rows := t_rows();
     rows.extend;
    rows(rows.last) := row;
    action := t_actionrowset(rows, 'References (for hook insert)', 2,12,'insert');
    actions.extend;
    actions(actions.last) := action;
    ihook.setColumnValue(rowform, 'CTL_VAL_MSG', ihook.getColumnValue(rowform, 'CTL_VAL_MSG') || 'CDE Created Successfully with ID ' || v_id ||  chr(13)) ;


 end if;

END;

PROCEDURE spDECreateFrom ( v_data_in IN CLOB, v_data_out OUT CLOB, v_usr_id  IN varchar2) as
        hookInput t_hookInput;
        hookOutput t_hookOutput := t_hookOutput();
        row_ori  t_row;
        row  t_row;
        rowai  t_row;
        rowde  t_row;
        rows t_rows;
        forms t_forms;
        form1 t_form;
        v_item_id  number;
        v_ver_nr  number(4,2);
        v_ori_rep_cls number;
        rowset            t_rowset;
        rowsetai  t_rowset;
        rowsetde  t_rowset;
        v_item_nm varchar2(255);
        v_cncpt_nm varchar2(255);
        v_long_nm varchar2(255);
        v_item_desc varchar2(4000);
        v_count  number;
        v_valid boolean;
        v_unq_id number;
        v_unq_ver number(4,2);
        v_temp_id number;
        v_temp_vr number(4,2);
        v_item_type_id number;
        actions t_actions := t_actions();
        action t_actionRowset;
begin
    -- Standard header
    hookinput                    := Ihook.gethookinput (v_data_in);
    hookoutput.invocationnumber  := hookinput.invocationnumber;
    hookoutput.originalrowset    := hookinput.originalrowset;

    -- Get the selected row
    row_ori :=  hookInput.originalRowset.rowset(1);
    v_item_id := ihook.getColumnValue(row_ori, 'ITEM_ID');
    v_ver_nr := ihook.getColumnValue(row_ori, 'VER_NR');
    v_item_type_id := ihook.getColumnValue(row_ori, 'ADMIN_ITEM_TYP_ID');


    if (v_item_type_id <> 4) then -- 4 - CDE in table OBJ_KEY
        raise_application_error(-20000,'!!! This functionality is only applicable for CDE !!!');
    end if;
if hookInput.invocationNumber = 0 then
        HOOKOUTPUT.QUESTION    := nci_chng_mgmt.getDECreateQuestion(2,true);
        row := row_ori;
        rows := t_rows();
      nci_11179_2.setStdAttr(row);
        ihook.setColumnValue(row, 'ITEM_LONG_NM', v_dflt_txt);

             rows.extend;
        rows(rows.last) := row;
        rowsetai := t_rowset(rows, 'Administered Item', 1, 'ADMIN_ITEM'); -- Default values for form
        rows := t_rows();
        row := t_row();
        -- Copy DE specific attributes
        nci_11179.spReturnSubtypeRow (v_item_id, v_ver_nr, 4, row );
        rows.extend;
        rows(rows.last) := row;
        rowsetde := t_rowset(rows, 'Data Element', 1, 'DE'); -- Default values for form
        hookOutput.forms := nci_chng_mgmt.getDECreateForm(rowsetai, rowsetde);

--      raise_application_error(-20000, 'You are not authorized to insert/update or delete in this context. 2');
--        return;
    --spDECommon(rowsetai,rowsetst, 'insert', hookinput, hookoutput);
  ELSE
        forms              := hookInput.forms;
        form1              := forms(1);
        rowai := form1.rowset.rowset(1);
        form1              := forms(2);
        rowde := form1.rowset.rowset(1);
        row := t_row();
        rows := t_rows();
        v_valid := true;


        v_item_nm:=ihook.getColumnValue(rowai,'ITEM_NM');
        v_item_desc:=ihook.getColumnValue(rowai,'ITEM_DESC');
              v_valid := true;

            -- for cur in (

            select count(*) into v_temp_id from admin_item ai, de de
            where ai.item_id = de.item_id and ai.ver_nr = de.ver_nr
           -- and ai.ITEM_LONG_NM=ihook.getColumnValue(rowai,'ITEM_LONG_NM')
           -- and  ai.ver_nr =  ihook.getColumnValue(rowai, 'VER_NR')
            and de.de_conc_item_id = ihook.getColumnValue(rowde, 'DE_CONC_ITEM_ID')
            and de.de_conc_ver_nr =  ihook.getColumnValue(rowde, 'DE_CONC_VER_NR')
            and de.val_dom_item_id =  ihook.getColumnValue(rowde, 'VAL_DOM_ITEM_ID')
            and de.val_dom_ver_nr =  ihook.getColumnValue(rowde, 'VAL_DOM_VER_NR')
            and ai.cntxt_item_id = ihook.getColumnValue(rowai, 'CNTXT_ITEM_ID')
            and  ai.cntxt_ver_nr = ihook.getColumnValue(rowai, 'CNTXT_VER_NR');--)

            select count(*) into v_unq_id from admin_item ai, de de
            where ai.item_id = de.item_id and ai.ver_nr = de.ver_nr
            and ai.ITEM_LONG_NM=ihook.getColumnValue(rowai,'ITEM_LONG_NM')
            and  ai.ver_nr =  ihook.getColumnValue(rowai, 'VER_NR')
            and ai.cntxt_item_id = ihook.getColumnValue(rowai, 'CNTXT_ITEM_ID')
            and  ai.cntxt_ver_nr = ihook.getColumnValue(rowai, 'CNTXT_VER_NR');


        --loop
        IF v_temp_id>0 or v_unq_id>0 then
        IF v_temp_id>0 then
         select max(ai.item_id),max(ai.ver_nr) into v_temp_id ,v_temp_vr from admin_item ai, de de
            where ai.item_id = de.item_id and ai.ver_nr = de.ver_nr
           -- and ai.ITEM_LONG_NM=ihook.getColumnValue(rowai,'ITEM_LONG_NM')
           -- and  ai.ver_nr =  ihook.getColumnValue(rowai, 'VER_NR')
            and de.de_conc_item_id = ihook.getColumnValue(rowde, 'DE_CONC_ITEM_ID')
            and de.de_conc_ver_nr =  ihook.getColumnValue(rowde, 'DE_CONC_VER_NR')
            and de.val_dom_item_id =  ihook.getColumnValue(rowde, 'VAL_DOM_ITEM_ID')
            and de.val_dom_ver_nr =  ihook.getColumnValue(rowde, 'VAL_DOM_VER_NR')
            and ai.cntxt_item_id = ihook.getColumnValue(rowai, 'CNTXT_ITEM_ID')
            and  ai.cntxt_ver_nr = ihook.getColumnValue(rowai, 'CNTXT_VER_NR');--)
        --hookoutput.message := 'Duplicate CDE found: ' || v_temp_id;
        hookoutput.message := 'Duplicate CDE found: ' ||get_AI_id(v_temp_id,v_temp_vr);
        END IF;
        IF v_unq_id>0 then
          select max(ai.item_id),max(ai.ver_nr) into v_unq_id ,v_unq_ver  from admin_item ai, de de
            where ai.item_id = de.item_id and ai.ver_nr = de.ver_nr
            and ai.ITEM_LONG_NM=ihook.getColumnValue(rowai,'ITEM_LONG_NM')
            and  ai.ver_nr =  ihook.getColumnValue(rowai, 'VER_NR')
            and ai.cntxt_item_id = ihook.getColumnValue(rowai, 'CNTXT_ITEM_ID')
            and  ai.cntxt_ver_nr = ihook.getColumnValue(rowai, 'CNTXT_VER_NR');

          hookoutput.message := 'Unique constraint violated. The CDE '||get_AI_id(v_unq_id,v_unq_ver )||' with the same Short Name and Context is found.';

        --hookoutput.message := 'Unique constraint violated. The CDE '||v_unq_id||'v'||ihook.getColumnValue(rowai, 'VER_NR')||' with the same Short Name and Context is found.';
        END IF;
         rows.extend;
          rows(rows.last) := rowai;
          rowset := t_rowset(rows, 'Administered Item', 1, 'ADMIN_ITEM');
          rows := t_rows();
            rows.extend;
          rows(rows.last) := rowde;
          rowsetde := t_rowset(rows, 'Data Element', 1, 'DE');
           v_valid := false;
          hookOutput.forms := nci_chng_mgmt.getDECreateForm(rowset, rowsetde);
          HOOKOUTPUT.QUESTION    := nci_chng_mgmt.getDECreateQuestion(2,v_valid);
          V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
          return;
		 -- exit;
         --end loop;
          end if;


  IF HOOKINPUT.ANSWERID = 1 or hookInput.invocationNumber = 1 then--Validate
        v_item_nm:=ihook.getColumnValue(rowai,'ITEM_NM');
        v_item_desc:=ihook.getColumnValue(rowai,'ITEM_DESC');
        v_valid := true;

         select substr(dec.item_nm || ' ' || vd.item_nm,1,255) ,substr(dec.item_desc || ':' || vd.item_desc,  1, 4000) into v_item_nm, v_item_desc from admin_item dec, admin_item vd
         where dec.item_id = ihook.getColumnValue(rowde, 'DE_CONC_ITEM_ID') and dec.ver_nr =  ihook.getColumnValue(rowde, 'DE_CONC_VER_NR')
         and vd.item_id =  ihook.getColumnValue(rowde, 'VAL_DOM_ITEM_ID') and vd.ver_nr = ihook.getColumnValue(rowde, 'VAL_DOM_VER_NR');
         ihook.setColumnValue(rowai, 'ITEM_NM', v_item_nm);
         ihook.setColumnValue(rowai, 'ITEM_DESC', v_item_desc);

 for cur in (select ai.item_id,ai.ver_nr from admin_item ai, de de
        where ai.item_id = de.item_id and ai.ver_nr = de.ver_nr
        and de.de_conc_item_id = ihook.getColumnValue(rowde, 'DE_CONC_ITEM_ID')
            and de.de_conc_ver_nr =  ihook.getColumnValue(rowde, 'DE_CONC_VER_NR')
            and de.val_dom_item_id =  ihook.getColumnValue(rowde, 'VAL_DOM_ITEM_ID')
            and de.val_dom_ver_nr =  ihook.getColumnValue(rowde, 'VAL_DOM_VER_NR')
            and ai.cntxt_item_id = ihook.getColumnValue(rowai, 'CNTXT_ITEM_ID')
            and  ai.cntxt_ver_nr = ihook.getColumnValue(rowai, 'CNTXT_VER_NR'))
        loop
        hookoutput.message := 'Duplicate CDE found: ' || get_AI_id(cur.item_id,cur.ver_nr);
        --hookoutput.message := 'Duplicate CDE found: ' ||get_AI_id(v_temp_id,ihook.getColumnValue(rowai, 'VER_NR'));
        v_valid := false;

       rows := t_rows();
         ihook.setColumnValue(rowai, 'ITEM_NM', v_item_nm);
         ihook.setColumnValue(rowai, 'ITEM_DESC', v_item_desc);

        rows.extend;
        rows(rows.last) := rowai;
        rowsetai := t_rowset(rows, 'Administered Item', 1, 'ADMIN_ITEM'); -- Default values for form
        rows := t_rows();
        row := t_row();
        rows := t_rows();
        rows.extend;
        rows(rows.last) := rowde;
        rowsetde := t_rowset(rows, 'Data Element', 1, 'DE'); -- Default values for form

        hookOutput.forms := nci_chng_mgmt.getDECreateForm(rowsetai, rowsetde);
        HOOKOUTPUT.QUESTION    := nci_chng_mgmt.getDECreateQuestion(2,v_valid);
               V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
       return;
       END LOOP;

       if hookinput.answerid = 1 or v_valid = false then --Validate

        ihook.setColumnValue(rowai, 'ITEM_NM', v_item_nm);
        ihook.setColumnValue(rowai, 'ITEM_DESC', v_item_desc);

          rows.extend;
          rows(rows.last) := rowai;
          rowset := t_rowset(rows, 'Administered Item', 1, 'ADMIN_ITEM');
          rows := t_rows();
            rows.extend;
          rows(rows.last) := rowde;
          rowsetde := t_rowset(rows, 'Data Element', 1, 'DE');
           v_valid := false;
          hookOutput.forms := nci_chng_mgmt.getDECreateForm(rowset, rowsetde);
          HOOKOUTPUT.QUESTION    := nci_chng_mgmt.getDECreateQuestion(2,v_valid);
          --V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);

    end if;

end if;


  if (hookinput.answerid = 2 and v_valid = true) then
        row := t_row();
        v_item_id := nci_11179.getItemId;
select count(*) into v_unq_id from admin_item ai, de de
            where ai.item_id = de.item_id and ai.ver_nr = de.ver_nr
            and ai.ITEM_LONG_NM=ihook.getColumnValue(rowai,'ITEM_LONG_NM')
            and  ai.ver_nr =  ihook.getColumnValue(rowai, 'VER_NR')
            and ai.cntxt_item_id = ihook.getColumnValue(rowai, 'CNTXT_ITEM_ID')
            and  ai.cntxt_ver_nr = ihook.getColumnValue(rowai, 'CNTXT_VER_NR');
  IF v_unq_id>0 then
            select max(ai.item_id)  into v_unq_id from admin_item ai, de de
            where ai.item_id = de.item_id and ai.ver_nr = de.ver_nr
            and ai.ITEM_LONG_NM=ihook.getColumnValue(rowai,'ITEM_LONG_NM')
            and  ai.ver_nr =  ihook.getColumnValue(rowai, 'VER_NR')
            and ai.cntxt_item_id = ihook.getColumnValue(rowai, 'CNTXT_ITEM_ID')
            and  ai.cntxt_ver_nr = ihook.getColumnValue(rowai, 'CNTXT_VER_NR');
           hookoutput.message := 'Unique constraint violated. The CDE '||get_AI_id(v_unq_id,ihook.getColumnValue(rowai, 'VER_NR'))||' with the same Short Name and Context is found.';
         rows.extend;
          rows(rows.last) := rowai;
          rowset := t_rowset(rows, 'Administered Item', 1, 'ADMIN_ITEM');
          rows := t_rows();
            rows.extend;
          rows(rows.last) := rowde;
          rowsetde := t_rowset(rows, 'Data Element', 1, 'DE');
           v_valid := false;
          hookOutput.forms := nci_chng_mgmt.getDECreateForm(rowset, rowsetde);
          HOOKOUTPUT.QUESTION    := nci_chng_mgmt.getDECreateQuestion(1,v_valid);
          V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
          return;
          END IF;
        ihook.setColumnValue(rowai,'ITEM_ID', v_item_id);
        ihook.setColumnValue(rowai,'VER_NR', 1.00);
        ihook.setColumnValue(rowai,'ADMIN_ITEM_TYP_ID', 4);


--        ihook.setColumnValue(rowai,'ITEM_NM', v_item_nm);
--        ihook.setColumnValue(rowai,'ITEM_DESC', v_item_desc);
		if (ihook.getColumnValue(rowde, 'PREF_QUEST_TXT') is null) then
        ihook.setColumnValue(rowde, 'PREF_QUEST_TXT', 'Data Element ' || v_item_nm|| ' does not have Preferred Question Text.'   );
        end if;
        rows := t_rows();
        rows.extend;
        rows(rows.last) := rowai;
        action := t_actionrowset(rows, 'Administered Item (No Sequence)', 2,1,'insert');
        actions.extend;
        actions(actions.last) := action;


        ihook.setColumnValue(rowde,'ITEM_ID', v_item_id);
        ihook.setColumnValue(rowde,'VER_NR', 1.00);

        rows := t_rows();
        rows.extend;
        rows(rows.last) := rowde;

        action := t_actionrowset(rows, 'Data Element', 2,2,'insert');
        actions.extend;
        actions(actions.last) := action;


        hookoutput.message := 'CDE Created Successfully with ID ' || v_item_id ;
        hookoutput.actions := actions;
        end if;
 --   raise_application_error(-20000, 'Count ' || actions.count);

  end if;

  V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
END;


function getCSICreateQuestion(v_from in number) return t_question is
  question t_question;
  answer t_answer;
  answers t_answers;
begin

 ANSWERS                    := T_ANSWERS();
 if (v_from = 1) then -- create
    ANSWER                     := T_ANSWER(1, 1, 'Create CSI');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
    QUESTION               := T_QUESTION('Create New CSI', ANSWERS);
else
    ANSWER                     := T_ANSWER(1, 1, 'Update CSI');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
    QUESTION               := T_QUESTION('Edit CSI', ANSWERS);
end if;
return question;
end;


function getCSCreateQuestion return t_question is
  question t_question;
  answer t_answer;
  answers t_answers;
begin

 ANSWERS                    := T_ANSWERS();
    ANSWER                     := T_ANSWER(1, 1, 'Create CS');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
    QUESTION               := T_QUESTION('Create New Classification Scheme', ANSWERS);

return question;
end;

function getVDCreateQuestion (v_first in Boolean) return t_question is
  question t_question;
  answer t_answer;
  answers t_answers;
begin

 ANSWERS                    := T_ANSWERS();

    ANSWER                     := T_ANSWER(1, 1, 'Review and Validate');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;

     if (v_first = false) then
    ANSWER                     := T_ANSWER(2, 2, 'Create Rep Term');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
    end if;
      if (v_first = false) then
        ANSWER                     := T_ANSWER(3, 3, 'Create/Save');
        ANSWERS.EXTEND;
        ANSWERS(ANSWERS.LAST) := ANSWER;
    end if;
    QUESTION               := T_QUESTION('Create/Edit', ANSWERS);

return question;
end;


function getDECreateQuestion(v_from in number,v_first in boolean) return t_question is
  question t_question;
  answer t_answer;
  answers t_answers;
begin
    ANSWERS                    := T_ANSWERS();

    ANSWER                     := T_ANSWER(1, 1, 'Review and Validate');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;

    if (v_first = false) then
    ANSWER                     := T_ANSWER(2, 2, 'Create');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
    end if;
    If v_from=1 then
    QUESTION               := T_QUESTION('Create New CDE', ANSWERS);
    else
    QUESTION               := T_QUESTION('Create CDE from Existing', ANSWERS);
    end IF;
return question;
end;

function getDECreateForm (v_rowset1 in t_rowset, v_rowset2 in t_rowset) return t_forms is
  forms t_forms;
  form1 t_form;
begin
    forms                  := t_forms();
    form1                  := t_form('Administered Item (Hook Creation)', 2,1);
    form1.rowset :=v_rowset1;
    forms.extend;    forms(forms.last) := form1;
    form1                  := t_form('Data Element(hook creation)', 2,1);

    form1.rowset :=v_rowset2;
    forms.extend;    forms(forms.last) := form1;
  return forms;
end;


function getCSICreateForm (v_rowset1 in t_rowset, v_rowset2 in t_rowset) return t_forms is
  forms t_forms;
  form1 t_form;
begin
    forms                  := t_forms();
    form1                  := t_form('Administered Item (No Short Name)', 2,1);
    form1.rowset :=v_rowset1;
    forms.extend;    forms(forms.last) := form1;
    form1                  := t_form('CSI (Hook Creation)', 2,1);

    form1.rowset :=v_rowset2;
    forms.extend;    forms(forms.last) := form1;
  return forms;
end;


function getCSCreateForm (v_rowset1 in t_rowset, v_rowset2 in t_rowset) return t_forms is
  forms t_forms;
  form1 t_form;
begin
    forms                  := t_forms();
    form1                  := t_form('Administered Item (Hook Creation)', 2,1);
    form1.rowset :=v_rowset1;
    forms.extend;    forms(forms.last) := form1;
    form1                  := t_form('Classification Scheme (Create Hook)', 2,1);

    form1.rowset :=v_rowset2;
    forms.extend;    forms(forms.last) := form1;
  return forms;
end;

procedure createAIWithConcept(rowform in out t_row, idx in integer,v_item_typ_id in integer, actions in out t_actions) as
v_nm  varchar2(255);
v_long_nm varchar2(255);
v_def  varchar2(4000);
row t_row;
rows t_rows;
 action t_actionRowset;
 v_cncpt_id  number;
 v_cncpt_ver_nr number(4,2);
 v_id integer;
 j integer;
i integer;
v_obj_nm  varchar2(100);
v_temp varchar2(4000);
begin
        v_id := nci_11179.getItemId;

       rows := t_rows();
   --     raise_application_error(-20000,'OC');
       v_nm := '';
       v_long_nm := '';
       v_def := '';
          j := 0;
          for i in reverse 0..10 loop

     --  raise_application_error(-20000, 'Test'  ||ihook.getColumnValue(rowform, 'CNCPT_' || idx  ||'_ITEM_ID_' || 4));

          v_cncpt_id := ihook.getColumnValue(rowform, 'CNCPT_' || idx  ||'_ITEM_ID_' || i);
             v_cncpt_ver_nr :=  ihook.getColumnValue(rowform, 'CNCPT_' || idx || '_VER_NR_' || i);
          if( v_cncpt_id is not null) then
    --   raise_application_error(-20000, 'Test'  || i || v_cncpt_id);
           for cur in (select item_nm, item_long_nm, item_desc from admin_item where item_id = v_cncpt_id and ver_nr = v_cncpt_ver_nr) loop
            row := t_row();
            ihook.setColumnValue(row,'ITEM_ID', v_id);
            ihook.setColumnValue(row,'VER_NR', 1);
            ihook.setColumnValue(row,'CNCPT_ITEM_ID',v_cncpt_id);
            ihook.setColumnValue(row,'CNCPT_VER_NR', v_cncpt_ver_nr);
            ihook.setColumnValue(row,'NCI_ORD', j);
            v_temp := v_temp || i || ':' ||  v_cncpt_id;
            if j = 0 then
            ihook.setColumnValue(row,'NCI_PRMRY_IND', 1);
            else ihook.setColumnValue(row,'NCI_PRMRY_IND', 0);
            end if;
            rows.extend;
            rows(rows.last) := row;
            v_nm := trim(cur.item_nm) || ' ' || v_nm ;
            v_long_nm := cur.item_long_nm || ':' || v_long_nm   ;
            v_def := substr( cur.item_desc || '_' || v_def,1,4000);
            j := j+ 1;
        end loop;
        end if;
        end loop;
       action := t_actionrowset(rows, 'CNCPT_ADMIN_ITEM', 1,6,'insert');
        actions.extend;
        actions(actions.last) := action;

        rows := t_rows();
        row := t_row();
        v_long_nm := substr(v_long_nm,1, length(v_long_nm)-1);
        v_nm := substr(trim(v_nm),1, c_nm_len);
        -- if lenght of short name is greater than 30, then use IDv1.00
        if (length(v_long_nm) > 30) then
            v_long_nm := v_id || c_ver_suffix;
        end if;

    -- raise_application_error (-20000, v_nm || '$$$' || v_long_nm);
        ihook.setColumnValue(row,'ITEM_ID', v_id);
        ihook.setColumnValue(row,'VER_NR', 1);
        ihook.setColumnValue(row,'CURRNT_VER_IND', 1);
        ihook.setColumnValue(row,'ADMIN_ITEM_TYP_ID', v_item_typ_id);
        ihook.setColumnValue(row,'ADMIN_STUS_ID',66 );
        ihook.setColumnValue(row,'ITEM_LONG_NM', v_long_nm);
        ihook.setColumnValue(row,'ITEM_DESC', substr(v_def, 1, length(v_def)-1));
        ihook.setColumnValue(row,'ITEM_NM', v_nm);
        ihook.setColumnValue(row,'CNTXT_ITEM_ID', ihook.getColumnValue(rowform,'CNTXT_ITEM_ID'));
        ihook.setColumnValue(row,'CNTXT_VER_NR', ihook.getColumnValue(rowform,'CNTXT_VER_NR'));
        rows.extend;
        rows(rows.last) := row;
    -- raise_application_error(-20000, 'HEre ' || v_nm || v_long_nm || v_def);
        ihook.setColumnValue(rowform,'ITEM_' || idx || '_LONG_NM', v_long_nm);
        ihook.setColumnValue(rowform,'ITEM_' || idx || '_DEF', substr(v_def, 1, length(v_def)-1));
        ihook.setColumnValue(rowform,'ITEM_' || idx || '_NM', v_nm);
        ihook.setColumnValue(rowform, 'ITEM_' || idx || '_ID', v_id);
         ihook.setColumnValue(rowform, 'ITEM_' || idx || '_VER_NR', 1);

        action := t_actionrowset(rows, 'Administered Item (No Sequence)', 2,1,'insert');
        actions.extend;
        actions(actions.last) := action;

       case v_item_typ_id
       when 5 then v_obj_nm := 'Object Class';
       when 6 then v_obj_nm := 'Property';
        end case;
        action := t_actionrowset(rows, v_obj_nm, 2,2,'insert');
        actions.extend;
        actions(actions.last) := action;


end;


procedure createDE (rowform in t_row, actions in out t_actions, v_id out  number) as
v_nm  varchar2(255);
v_long_nm varchar2(255);
v_def  varchar2(4000);
row t_row;
rows t_rows;
 action t_actionRowset;
 --v_id number;
begin
   rows := t_rows();
   row := t_row();
     v_id := nci_11179.getItemId;
        ihook.setColumnValue(row,'ITEM_ID', v_id);
      --  raise_application_error (-20000, ihook.getColumnValue(rowform,'CONC_DOM_ITEM_ID')  || ihook.getColumnValue(rowform, 'ITEM_1_ID') || ihook.getColumnValue(rowform, 'ITEM_2_ID'));
        ihook.setColumnValue(row,'VER_NR', 1);
        ihook.setColumnValue(row,'CURRNT_VER_IND', 1);
        ihook.setColumnValue(row,'ADMIN_ITEM_TYP_ID', 2);
   --     ihook.setColumnValue(row,'ITEM_LONG_NM', ihook.getColumnValue(rowform, 'ITEM_1_LONG_NM')  || ':' || ihook.getColumnValue(rowform, 'ITEM_2_LONG_NM'));
        ihook.setColumnValue(row,'ITEM_LONG_NM',  v_id || c_ver_suffix);
        ihook.setColumnValue(row,'ITEM_NM',  ihook.getColumnValue(rowform, 'ITEM_1_NM')  || ' ' || ihook.getColumnValue(rowform, 'ITEM_2_NM'));
        ihook.setColumnValue(row,'ITEM_DESC',substr(ihook.getColumnValue(rowform, 'ITEM_1_DEF')  || ':' || ihook.getColumnValue(rowform, 'ITEM_2_DEF'),1,4000));
        ihook.setColumnValue(row,'CNTXT_ITEM_ID', ihook.getColumnValue(rowform,'CNTXT_ITEM_ID'));
        ihook.setColumnValue(row,'CNTXT_VER_NR', ihook.getColumnValue(rowform,'CNTXT_VER_NR'));
        ihook.setColumnValue(row,'ADMIN_STUS_ID',66);
        ihook.setColumnValue(row,'CONC_DOM_ITEM_ID',nvl(ihook.getColumnValue(rowform,'CONC_DOM_ITEM_ID'),1) );
        ihook.setColumnValue(row,'CONC_DOM_VER_NR',nvl(ihook.getColumnValue(rowform,'CONC_DOM_VER_NR'),1) );
        ihook.setColumnValue(row,'OBJ_CLS_ITEM_ID',nvl(ihook.getColumnValue(rowform, 'ITEM_1_ID'),1) );
        ihook.setColumnValue(row,'OBJ_CLS_VER_NR',nvl(ihook.getColumnValue(rowform, 'ITEM_1_VER_NR'),1) );
        ihook.setColumnValue(row,'PROP_ITEM_ID',nvl(ihook.getColumnValue(rowform, 'ITEM_2_ID'),1));
        ihook.setColumnValue(row,'PROP_VER_NR',nvl(ihook.getColumnValue(rowform, 'ITEM_2_VER_NR'),1));
        ihook.setColumnValue(row,'LST_UPD_DT',sysdate );
        rows.extend;
        rows(rows.last) := row;
--raise_application_error(-20000, 'Deep' || ihook.getColumnValue(row,'CNTXT_ITEM_ID') || 'ggg'|| ihook.getColumnValue(row,'ADMIN_STUS_ID') || 'GGGG' || ihook.getColumnValue(row,'ITEM_ID'));

        action := t_actionrowset(rows, 'Administered Item (No Sequence)', 2,7,'insert');
        actions.extend;
        actions(actions.last) := action;

      action := t_actionrowset(rows, 'Data Element Concept', 2,8,'insert');
       actions.extend;
        actions(actions.last) := action;

--r
end;

PROCEDURE spDEPrefQuestPost
  (
    v_data_in IN CLOB,
    v_data_out OUT CLOB)
AS
  hookInput t_hookInput;
  hookOutput t_hookOutput := t_hookOutput();
   actions t_actions := t_actions();
  action t_actionRowset;
  row t_row;
  rows  t_rows;
    row_ori t_row;
  action_rows       t_rows := t_rows();
  action_row		    t_row;
  rowset            t_rowset;
  v_add integer :=0;
  v_action_typ varchar2(30);
  v_item_id  number;
  v_ver_nr  number(4,2);
  v_nm_id number;
  v_cntxt_id number;
  v_cntxt_ver_nr number(4,2);
  i integer := 0;
  column  t_column;
  msg varchar2(4000);
BEGIN
  hookinput                    := Ihook.gethookinput (v_data_in);
  hookoutput.invocationnumber  := hookinput.invocationnumber;
  hookoutput.originalrowset    := hookinput.originalrowset;
    rows := t_rows();

    row_ori := hookInput.originalRowset.rowset(1);
    v_item_id := ihook.getColumnValue(row_ori, 'ITEM_ID');
    v_ver_nr := ihook.getColumnValue(row_ori, 'VER_NR');

    if (ihook.getColumnValue(row_ori, 'PREF_QUEST_TXT') is not null) then
    select cntxt_item_id, cntxt_ver_nr into v_cntxt_id, v_cntxt_ver_nr from admin_item where item_id = v_item_id and ver_nr = v_ver_nr;

        row := t_row ();
        ihook.setColumnValue(row,'ITEM_ID', v_item_id);
    ihook.setColumnValue(row,'VER_NR', v_ver_nr);
     ihook.setColumnValue(row,'REF_NM', substr(ihook.getColumnValue(row_ori, 'PREF_QUEST_TXT'),1,255));
     ihook.setColumnValue(row,'REF_DESC', ihook.getColumnValue(row_ori, 'PREF_QUEST_TXT'));
     ihook.setColumnValue(row,'LANG_ID', 1000);
     ihook.setColumnValue(row,'NCI_CNTXT_ITEM_ID',v_cntxt_id );
     ihook.setColumnValue(row,'NCI_CNTXT_VER_NR', v_cntxt_ver_nr );
     ihook.setColumnValue(row,'REF_TYP_ID', 80);

     ihook.setColumnValue(row,'REF_ID', -1);
     v_action_typ := 'insert';
     for cur in (select REF_id from  REF where item_id = v_item_id and ver_nr = v_ver_nr and ref_typ_id = 80) loop
     ihook.setColumnValue(row,'REF_ID', cur.ref_id);
     v_action_typ := 'update';

     end loop;

     rows.extend;
    rows(rows.last) := row;
    action := t_actionrowset(rows, 'References (for Edit)', 2,0,v_action_typ);
    actions.extend;
    actions(actions.last) := action;
    hookoutput.actions := actions;

    end if;
  V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
END;

PROCEDURE spClassificationNMDef ( v_data_in IN CLOB, v_data_out OUT CLOB, v_usr_id  IN varchar2, v_typ in varchar2)
AS
  hookInput t_hookInput;
  hookOutput t_hookOutput := t_hookOutput();
   actions t_actions := t_actions();
  action t_actionRowset;
  row t_row;
  rows  t_rows;
    row_ori t_row;
    row_sel t_row;
    v_obj  varchar2(100);
  action_rows       t_rows := t_rows();
  action_row		    t_row;
  rowset            t_rowset;
 question    t_question;
answer     t_answer;
answers     t_answers;
showrowset	t_showablerowset;
forms     t_forms;
formGroup    t_form;
form1  t_form;
rowform t_row;
v_itemid     ADMIN_ITEM.ITEM_ID%TYPE;
v_vernr  ADMIN_ITEM.VER_NR%TYPE;
v_tbl_nm  varchar2(255);
v_found boolean;
  v_temp integer;
  v_stg_ai_id number;
  v_id number;
  i integer := 0;
  column  t_column;
  msg varchar2(4000);
BEGIN
  hookinput                    := Ihook.gethookinput (v_data_in);
  hookoutput.invocationnumber  := hookinput.invocationnumber;
  hookoutput.originalrowset    := hookinput.originalrowset;
  row_ori :=  hookInput.originalRowset.rowset(1);
  v_itemid := ihook.getColumnValue(row_ori, 'ITEM_ID');
  v_VERNR := ihook.getColumnValue(row_ori, 'VER_NR');
    if (v_typ = 'DESIGNATION') then
         v_id := ihook.getColumnValue(row_ori, 'NM_ID');
         v_obj := 'Classification level Name/Definition';
    else
         v_id := ihook.getColumnValue(row_ori, 'DEF_ID');
         v_obj := 'Classification level Definition';
   end if;
    rows := t_rows();


    if hookInput.invocationNumber = 0  then

    rows := t_rows();

        for cur in (select ITEM_ID, VER_NR from NCI_CLSFCTN_SCHM_ITEM  where (CS_ITEM_ID, CS_ITEM_VER_NR) in ( select item_id, ver_nr from admin_item ai, onedata_md.vw_usr_row_filter v
        where nvl(ai.fld_delete,0)= 0  and ai.cntxt_item_id = v.CNTXT_ITEM_ID and ai.CNTXT_VER_NR = v.cntxt_VER_NR and ai.admin_item_typ_id = 9 and  upper(v.USR_ID) = upper(v_usr_id) and v.ACTION_TYP = 'I') )loop
		   row := t_row();
	   	   iHook.setcolumnvalue (ROW, 'ITEM_ID', cur.ITEM_ID);
		   iHook.setcolumnvalue (ROW, 'VER_NR', cur.VER_NR);
		   rows.extend;
		   rows (rows.last) := row;
      	   v_found := true;
	    end loop;



        if (v_found) then
             showrowset := t_showablerowset (rows, 'CSI Node', 2, 'single');
            hookoutput.showrowset := showrowset;
       	 answers := t_answers();
        answer := t_answer(1, 1, 'Add Classification');
        answers.extend;          answers(answers.last) := answer;
        answer := t_answer(2, 2, 'Delete Classification');
        answers.extend;          answers(answers.last) := answer;

	   	 question := t_question('Choose Option', answers);
       	 hookOutput.question := question;
        else
            hookoutput.message := 'No classification scheme found in your authorized context.';
         end if;

    end if;

  	if hookInput.invocationNumber = 1 then
      rows := t_rows();

      row_sel := hookInput.selectedRowset.rowset(1);
            row := t_row();
            select count(*) into v_temp from NCI_CSI_ALT_DEFNMS where NMDEF_id = v_id
            and NCI_VER_NR = ihook.getColumnValue(row_sel,'VER_NR') and NCI_PUB_ID = ihook.getColumnValue(row_sel,'ITEM_ID') ;
            if ((v_temp = 0 and hookinput.answerid =1) or (v_temp=1 and hookinput.answerid = 2) ) then
                ihook.setcolumnvalue(row,'NCI_VER_NR', ihook.getColumnValue(row_sel,'VER_NR'));
                ihook.setcolumnvalue(row,'NCI_PUB_ID', ihook.getColumnValue(row_sel,'ITEM_ID'));
                ihook.setcolumnvalue(row,'NMDEF_ID', v_id);
                ihook.setcolumnvalue(row,'TYP_NM', v_typ);
                rows.extend;
                rows(rows.last) := row;
                if (hookinput.answerid = 1) then -- Add
                    action := t_actionrowset(rows, v_obj, 2,1,'insert');
                    actions.extend;
                    actions(actions.last) := action;
                else
                    action := t_actionrowset(rows, v_obj, 2,2,'delete');
                    actions.extend;
                    actions(actions.last) := action;
                    action := t_actionrowset(rows, v_obj, 2,3,'purge');
                    actions.extend;
                    actions(actions.last) := action;
                end if;
                hookoutput.actions := actions;
            end if;
    end if; -- invocation number
  V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
END;

PROCEDURE spClassification
  (
    v_data_in IN CLOB,
    v_data_out OUT CLOB,
    v_usr_id  IN varchar2)
AS
  hookInput t_hookInput;
  hookOutput t_hookOutput := t_hookOutput();
   actions t_actions := t_actions();
  action t_actionRowset;
  row t_row;
  rows  t_rows;
    row_ori t_row;
    row_sel t_row;
    v_id integer;
  action_rows       t_rows := t_rows();
  action_row		    t_row;
  rowset            t_rowset;
 question    t_question;
answer     t_answer;
answers     t_answers;
showrowset	t_showablerowset;
forms     t_forms;
formGroup    t_form;
form1  t_form;
rowform t_row;
v_itemid     ADMIN_ITEM.ITEM_ID%TYPE;
v_vernr  ADMIN_ITEM.VER_NR%TYPE;
v_tbl_nm  varchar2(255);
v_found boolean;
  v_temp integer;
  v_stg_ai_id number;
  i integer := 0;
  column  t_column;
  msg varchar2(4000);
BEGIN
  hookinput                    := Ihook.gethookinput (v_data_in);
  hookoutput.invocationnumber  := hookinput.invocationnumber;
  hookoutput.originalrowset    := hookinput.originalrowset;
  row_ori :=  hookInput.originalRowset.rowset(1);
  v_itemid := ihook.getColumnValue(row_ori, 'ITEM_ID');
  v_VERNR := ihook.getColumnValue(row_ori, 'VER_NR');


    -- Initial invocation
    if hookInput.invocationNumber = 0  then

        rows := t_rows();
        for cur in (select ITEM_ID, VER_NR from NCI_CLSFCTN_SCHM_ITEM where (CS_ITEM_ID, CS_ITEM_VER_NR) in ( select item_id, ver_nr from admin_item ai, onedata_md.vw_usr_row_filter v
        where nvl(ai.fld_delete,0)= 0  and ai.cntxt_item_id = v.CNTXT_ITEM_ID and ai.CNTXT_VER_NR = v.cntxt_VER_NR and ai.admin_item_typ_id = 9 and  upper(v.USR_ID) = upper(v_usr_id) and v.ACTION_TYP = 'I') )loop
		   row := t_row();
	   	   iHook.setcolumnvalue (ROW, 'ITEM_ID', cur.ITEM_ID);
		   iHook.setcolumnvalue (ROW, 'VER_NR', cur.VER_NR);
		   rows.extend;
		   rows (rows.last) := row;
      	   v_found := true;
	    end loop;

        if (v_found) then
             showrowset := t_showablerowset (rows, 'CSI Node', 2, 'single');
            hookoutput.showrowset := showrowset;
       	 answers := t_answers();
        answer := t_answer(1, 1, 'Add Classification');
        answers.extend;          answers(answers.last) := answer;
        answer := t_answer(2, 2, 'Delete Classification');
        answers.extend;          answers(answers.last) := answer;

	   	 question := t_question('Choose Option', answers);
       	 hookOutput.question := question;
        else
            hookoutput.message := 'No classification scheme found in your authorized context.';
         end if;
    end if;

   if hookInput.invocationNumber = 1  then

        row_sel := hookInput.selectedRowset.rowset(1);
        v_found := false;
        rows := t_rows();

                for i in 1..hookinput.originalrowset.rowset.count loop
                    row := t_row();
                    row_ori := hookInput.originalRowset.rowset(i);

                    select count(*) into v_temp from NCI_ADMIN_ITEM_REL where c_item_id = ihook.getColumnValue(row_ori,'ITEM_ID') and c_item_ver_nr = ihook.getColumnValue(row_ori,'VER_NR')
                    and P_ITEM_VER_NR = ihook.getColumnValue(row_sel,'VER_NR') and P_ITEM_ID = ihook.getColumnValue(row_sel,'ITEM_ID') and rel_typ_id = 65;

                    if ((v_temp = 0 and hookinput.answerid = 1) or (v_temp=1 and hookinput.answerid=2)) then
                        row := t_row();
                        ihook.setcolumnvalue(row,'C_ITEM_ID', ihook.getColumnValue(row_ori,'ITEM_ID'));
                        ihook.setcolumnvalue(row,'C_ITEM_VER_NR', ihook.getColumnValue(row_ori,'VER_NR'));
                        ihook.setcolumnvalue(row,'P_ITEM_VER_NR', ihook.getColumnValue(row_sel,'VER_NR'));
                        ihook.setcolumnvalue(row,'P_ITEM_ID', ihook.getColumnValue(row_sel,'ITEM_ID'));
                        ihook.setcolumnvalue(row,'REL_TYP_ID', 65);
                        rows.extend;
                        rows(rows.last) := row;
                        v_found := true;
                    end if;
                end loop;

                v_tbl_nm := 'Classifications (Insert)';

                if (v_found= true and hookinput.answerid = 1) then
                        action := t_actionrowset(rows, v_tbl_nm, 2,1,'insert');
                        actions.extend;        actions(actions.last) := action;
                        hookoutput.actions := actions;
         --               raise_application_error(-20000,'In here');
                end if;

                if (v_found= true and hookinput.answerid = 2) then
                        action := t_actionrowset(rows, v_tbl_nm, 2,2,'delete');
                        actions.extend;                    actions(actions.last) := action;
                        action := t_actionrowset(rows, v_tbl_nm, 2,3,'purge');
                        actions.extend;                    actions(actions.last) := action;
                        hookoutput.actions := actions;
                end if;

         end if;
  V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
  nci_util.debugHook('GENERAL', v_data_out);
END;

PROCEDURE spDesignateNew
  (
    v_data_in IN CLOB,
    v_data_out OUT CLOB,
    v_usr_id  IN varchar2)
AS
  hookInput t_hookInput;
  hookOutput t_hookOutput := t_hookOutput();

  actions t_actions := t_actions();
  action t_actionRowset;
  row t_row;
  rows  t_rows;
  row_ori t_row;
  rowform t_row;
  action_rows       t_rows := t_rows();
  action_row		    t_row;
  rowset            t_rowset;

  question    t_question;
  answer     t_answer;
  answers     t_answers;

  forms     t_forms;
  form1  t_form;

  v_temp integer;
  v_nm_typ_id integer;
  v_default_txt varchar2(30) := 'Default is Context Name.' ;
  v_cntxt_nm  varchar2(255);
  v_cnt integer;
    v_found boolean;
BEGIN
  hookinput                    := Ihook.gethookinput (v_data_in);
  hookoutput.invocationnumber  := hookinput.invocationnumber;
  hookoutput.originalrowset    := hookinput.originalrowset;

   select obj_key_id into v_nm_typ_id from obj_key where obj_key_desc = 'USED_BY' and obj_typ_id = 11;
    v_cnt := 0; -- number of designations

  if hookInput.invocationNumber = 0  then
     	 answers := t_answers();
  	   	 answer := t_answer(1, 1, 'Designate');
         answers.extend;          answers(answers.last) := answer;
  --       answer := t_answer(2, 2, 'Undesignate');
   --      answers.extend;          answers(answers.last) := answer;
      question := t_question('Choose Option', answers);
       	 hookOutput.question := question;
         row := t_row();


        ihook.setColumnValue(row, 'NM_TYP_ID', v_nm_typ_id);
        ihook.setColumnValue(row, 'NM_DESC',v_default_txt); -- Default values
        ihook.setColumnValue(row, 'LANG_ID',1000); -- Default values
        rows := t_rows(); rows.extend;    rows(rows.last) := row;
        rowset := t_rowset(rows, 'Alternate Names', 1, 'ALT_NMS'); -- Default values for form

        forms                  := t_forms();
        form1                  := t_form('Alternate Names', 2,1);
        form1.rowset :=rowset;
        forms.extend;    forms(forms.last) := form1;
        hookoutput.forms := forms;
  	elsif hookInput.invocationNumber = 1 then
        forms              := hookInput.forms;
        form1              := forms(1);
        rowform := form1.rowset.rowset(1);  -- entered values from user
        rows := t_rows();
        if (hookinput.answerid = 1) then
            ihook.setColumnValue(rowform,'NM_ID', -1);
            for i in 1..hookinput.originalrowset.rowset.count loop
                 v_found := false;
                    row_ori :=  hookInput.originalRowset.rowset(i);
                    if (ihook.getColumnValue(row_ori, 'ADMIN_ITEM_TYP_ID') = 4 and ihook.getColumnValue(row_ori, 'ADMIN_STUS_ID') in (65,75,76)) then
                        row := rowform;
                        ihook.setColumnValue(row,'ITEM_ID',ihook.getColumnValue(row_ori,'ITEM_ID'));
                        ihook.setColumnValue(row,'VER_NR',ihook.getColumnValue(row_ori,'VER_NR'));

                        if ( ihook.getColumnValue(rowform,'NM_DESC') != v_default_txt) then -- Get context name
                            select count(*) into v_temp from alt_nms where
                            cntxt_item_id = ihook.getColumnValue(rowform,'CNTXT_ITEM_ID') and cntxt_ver_nr = ihook.getColumnValue(rowform,'CNTXT_VER_NR')
                            and item_id = ihook.getColumnValue(rowform,'ITEM_ID') and ver_nr = ihook.getColumnValue(rowform,'VER_NR')
                            and nm_typ_id =   ihook.getColumnValue(rowform,'NM_TYP_ID') and nm_desc = ihook.getColumnValue(rowform,'NM_DESC');

                            if (v_temp = 0) then -- Row does not exist
                                    rows.extend;
                                    rows(rows.last) := row;
                                v_found := true;
                            end if;
                        end if;

            -- Default used by row

                select item_nm into v_cntxt_nm from vw_cntxt where item_id = ihook.getColumnValue(rowform,'CNTXT_ITEM_ID') and ver_nr = ihook.getColumnValue(rowform,'CNTXT_VER_NR');
                    ihook.setColumnValue(row,'NM_DESC', v_cntxt_nm);
                    ihook.setColumnValue(row,'NM_TYP_ID', v_nm_typ_id);


              -- If row already exists
                    select count(*) into v_temp from alt_nms where
                    cntxt_item_id = ihook.getColumnValue(rowform,'CNTXT_ITEM_ID') and cntxt_ver_nr = ihook.getColumnValue(rowform,'CNTXT_VER_NR')
                    and item_id = ihook.getColumnValue(rowform,'ITEM_ID') and ver_nr = ihook.getColumnValue(rowform,'VER_NR')
                    and nm_typ_id =   v_nm_typ_id and nm_desc = ihook.getColumnValue(rowform,'NM_DESC');

                    if (v_temp = 0) then -- Row does not exist
                        rows.extend;
                        rows(rows.last) := row;
                        v_found := true;

                    end if;
                end if;
            if (v_found) then
                    v_cnt := v_cnt + 1;
            end if;
        end loop;

                   if (rows.count > 0) then
                        action := t_actionrowset(rows, 'Alternate Names', 2,1,'insert');
                            actions.extend;
                            actions(actions.last) := action;
                    end if;
                             hookoutput.message := 'Only CDEs with Release/Released Non-Compliant and Draft-Mod have been designated. Total Designated: ' || v_cnt;

       end if;
       end if;
    if (hookinput.answerId = 2) then -- undesignate
       rows := t_rows();
       for i in 1..hookinput.originalrowset.rowset.count loop
                    row_ori :=  hookInput.originalRowset.rowset(i);
                    if (ihook.getColumnValue(row_ori, 'ADMIN_ITEM_TYP_ID') = 4 ) then
                         for cur in (select * from alt_nms where item_id = ihook.getColumnValue(row_ori,'ITEM_ID') and ver_nr = ihook.getColumnValue(row_ori,'VER_NR')
                        and NM_TYP_ID = v_nm_typ_id and CNTXT_ITEM_ID = ihook.getColumnValue(rowform,'CNTXT_ITEM_ID')
                        and CNTXT_VER_NR = ihook.getColumnValue(rowform,'CNTXT_VER_NR') ) loop
                            row := t_row();
                            ihook.setColumnValue(row, 'NM_ID', cur.NM_ID);
     rows.extend;
                            rows(rows.last) := row;
                        end loop;
                    end if;
        end loop;
        if (rows.count > 0) then

                    action := t_actionrowset(rows, 'Alternate Names', 2,1,'delete');
                    actions.extend;
                    actions(actions.last) := action;
                    action := t_actionrowset(rows, 'Alternate Names', 2,2,'purge');
                    actions.extend;
                    actions(actions.last) := action;
           hookoutput.message := 'Only CDEs have been undesignated. Total Undesignated: ' || rows.count;
        end if;
    end if;

if (actions.count > 0) then
  hookoutput.actions := actions;

end if;

  V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
  nci_util.debugHook('GENERAL', v_data_out);
END;

PROCEDURE spUndesignate
  (
    v_data_in IN CLOB,
    v_data_out OUT CLOB,
    v_usr_id  IN varchar2)
AS
  hookInput t_hookInput;
  hookOutput t_hookOutput := t_hookOutput();

  actions t_actions := t_actions();
  action t_actionRowset;
  row t_row;
  rows  t_rows;
  row_ori t_row;
  rowform t_row;
  action_rows       t_rows := t_rows();
  action_row		    t_row;
  rowset            t_rowset;

  question    t_question;
  answer     t_answer;
  answers     t_answers;

  forms     t_forms;
  form1  t_form;

  v_temp integer;
  v_nm_typ_id integer;
  v_default_txt varchar2(30) := 'Default is Context Name.' ;
  v_cntxt_nm  varchar2(255);
  v_cnt integer;
    v_found boolean;
BEGIN
  hookinput                    := Ihook.gethookinput (v_data_in);
  hookoutput.invocationnumber  := hookinput.invocationnumber;
  hookoutput.originalrowset    := hookinput.originalrowset;

   select obj_key_id into v_nm_typ_id from obj_key where obj_key_desc = 'USED_BY' and obj_typ_id = 11;
    v_cnt := 0; -- number of designations
  if hookInput.invocationNumber = 0  then
     	 answers := t_answers();
  	      answer := t_answer(2, 2, 'Undesignate');
         answers.extend;          answers(answers.last) := answer;
      question := t_question('Choose Option', answers);
       	 hookOutput.question := question;
         row := t_row();




        forms                  := t_forms();
        form1                  := t_form('Designate Context Form', 2,1);
        form1.rowset :=rowset;
        forms.extend;    forms(forms.last) := form1;
        hookoutput.forms := forms;
  	elsif hookInput.invocationNumber = 1 then
        forms              := hookInput.forms;
        form1              := forms(1);
        rowform := form1.rowset.rowset(1);  -- entered values from user
        rows := t_rows();
    --    raise_application_error(-20000, ihook.getColumnValue(rowform,'CNTXT_ITEM_ID'));

        if (hookinput.answerId = 2) then -- undesignate
       rows := t_rows();
       for i in 1..hookinput.originalrowset.rowset.count loop
                    row_ori :=  hookInput.originalRowset.rowset(i);
                    if (ihook.getColumnValue(row_ori, 'ADMIN_ITEM_TYP_ID') = 4 ) then
                         for cur in (select * from alt_nms where item_id = ihook.getColumnValue(row_ori,'ITEM_ID') and ver_nr = ihook.getColumnValue(row_ori,'VER_NR')
                        and NM_TYP_ID = v_nm_typ_id and CNTXT_ITEM_ID = ihook.getColumnValue(rowform,'ITEM_ID')
                        and CNTXT_VER_NR = ihook.getColumnValue(rowform,'VER_NR') ) loop
                            row := t_row();
                            ihook.setColumnValue(row, 'NM_ID', cur.NM_ID);
     rows.extend;
                            rows(rows.last) := row;
                        end loop;
                    end if;
        end loop;
        if (rows.count > 0) then

                    action := t_actionrowset(rows, 'Alternate Names', 2,1,'delete');
                    actions.extend;
                    actions(actions.last) := action;
                    action := t_actionrowset(rows, 'Alternate Names', 2,2,'purge');
                    actions.extend;
                    actions(actions.last) := action;
           hookoutput.message := 'Only CDEs have been undesignated. Total Undesignated: ' || rows.count;
        else
        hookoutput.message := 'No CDEs have been undesignated.';
        end if;
    end if;

if (actions.count > 0) then
  hookoutput.actions := actions;

end if;
end if;
  V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
 -- nci_util.debugHook('GENERAL', v_data_out);
END;

-- Classify/Unclassify for Super Curators
PROCEDURE spClassifyUnclassify
  (
    v_data_in IN CLOB,
    v_data_out OUT CLOB,
    v_usr_id  IN varchar2)
AS
  hookInput t_hookInput;
  hookOutput t_hookOutput := t_hookOutput();

  actions t_actions := t_actions();
  action t_actionRowset;
  row t_row;
  rows  t_rows;
  row_ori t_row;
  rowform t_row;
  action_rows       t_rows := t_rows();
  action_row		    t_row;
  rowset            t_rowset;

  question    t_question;
  answer     t_answer;
  answers     t_answers;

  forms     t_forms;
  form1  t_form;

  v_temp integer;
  v_cmp integer;
  v_cnt integer;
  v_default_txt varchar2(30) := 'Default is Context Name.' ;

BEGIN
  hookinput                    := Ihook.gethookinput (v_data_in);
  hookoutput.invocationnumber  := hookinput.invocationnumber;
  hookoutput.originalrowset    := hookinput.originalrowset;

    if hookInput.invocationNumber = 0  then
            answers := t_answers();
            answer := t_answer(1, 1, 'Classify');
            answers.extend;          answers(answers.last) := answer;

            answer := t_answer(2, 2, 'Unclassify');
            answers.extend;          answers(answers.last) := answer;
            question := t_question('Choose Option', answers);

            hookOutput.question := question;

        -- Form only has only pop-up to select Classification
            forms                  := t_forms();
            form1                  := t_form('Unclassify (Hook)', 2,1);
            forms.extend;    forms(forms.last) := form1;

            hookoutput.forms := forms;
  	elsif hookInput.invocationNumber = 1 then
            forms              := hookInput.forms;
            form1              := forms(1);
            rowform := form1.rowset.rowset(1);  -- entered values from user
            rows := t_rows();
            ihook.setColumnValue(rowform, 'REL_TYP_ID', 65);

            v_cnt := 0;   -- Count of total added rows

            v_cmp := hookinput.answerid - 1; -- 0 if classify, 1 if unclassify

            for i in 1..hookinput.originalrowset.rowset.count loop

                row_ori :=  hookInput.originalRowset.rowset(i);
                row := rowform;

                ihook.setColumnValue(row,'C_ITEM_ID',ihook.getColumnValue(row_ori,'ITEM_ID'));
                ihook.setColumnValue(row,'C_ITEM_VER_NR',ihook.getColumnValue(row_ori,'VER_NR'));

            -- check if row exists if unclassify and not exists if classify

                    select count(*) into v_temp from nci_admin_item_rel where
                    p_item_id =  ihook.getColumnValue(rowform,'P_ITEM_ID') and
                    p_item_ver_nr = ihook.getColumnValue(rowform,'P_ITEM_VER_NR') and
                    c_item_id = ihook.getColumnValue(row_ori,'ITEM_ID') and
                    c_item_ver_nr = ihook.getColumnValue(row_ori,'VER_NR') and
                    rel_typ_id = 65;

                    if (v_temp = v_cmp) then -- 0 if classify, 1 if unclassify
                        rows.extend;  rows(rows.last) := row;
                        v_cnt := v_cnt + 1;
                    end if;
            end loop;

            if rows.count > 0 then
                if (hookinput.answerid = 1) then -- Classify
                        action := t_actionrowset(rows, 'NCI CSI - DE Relationship', 2,1,'insert');
                        actions.extend; actions(actions.last) := action;
                        hookoutput.message := v_cnt || ' items classified.';

                else
                            action := t_actionrowset(rows, 'NCI CSI - DE Relationship', 2,1,'delete');
                            actions.extend; actions(actions.last) := action;
                            action := t_actionrowset(rows, 'NCI CSI - DE Relationship', 2,2,'purge');
                            actions.extend;  actions(actions.last) := action;
                            hookoutput.message := v_cnt || ' items unclassified.';
                end if;
                hookoutput.actions := actions;
            end if;
    end if;
    V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
END;

FUNCTION get_AI_id(P_ID NUMBER,P_VER in number) RETURN VARCHAR2
IS
V_DN VARCHAR2(355);
V_LN VARCHAR2(255);
V_type number;
V_VER varchar(10);
BEGIN

V_VER:=to_char(P_VER);

IF instr(V_ver,'.')=0 then
V_DN :=P_ID||'v'||V_ver||'.00';

ELSIF instr(V_ver,'.')>0 and length (substr (V_VER,INSTR(V_VER,'.')+1))<2 then
V_DN :=P_ID||'v'||substr (V_VER,1,INSTR(V_VER,'.')-1)||'.'||substr (V_VER,INSTR(V_VER,'.')+1)||'0';

ELSE
V_DN :=P_ID||'v'||substr (V_VER,1,INSTR(V_VER,'.')-1)||'.'||substr (V_VER,INSTR(V_VER,'.')+1);
end if ;

RETURN V_DN;
END;
END;
/


DROP PACKAGE BODY ONEDATA_WA.NCI_DEC_MGMT;

CREATE OR REPLACE PACKAGE BODY ONEDATA_WA.nci_DEC_MGMT AS

-- All DEC creation and import routines.
-- Standard concept-related entity creation

c_long_nm_len  integer := 30;
c_nm_len integer := 255;
c_ver_suffix varchar2(5) := 'v1.00';
v_dflt_txt    varchar2(100) := 'Enter text or auto-generated.';

v_int_cncpt_id  number := 2433736;


PROCEDURE spBulkUpdateDEC
  (
    v_data_in IN CLOB,
    v_data_out OUT CLOB,
    v_usr_id  IN varchar2)
AS
  hookInput t_hookInput;
  hookOutput t_hookOutput := t_hookOutput();

  actions t_actions := t_actions();
  action t_actionRowset;
  row t_row;
  rows  t_rows;
  rowscd t_rows;
  row_ori t_row;
  rowform t_row;
  action_rows       t_rows := t_rows();
  action_row		    t_row;
  rowset            t_rowset;

  question    t_question;
  answer     t_answer;
  answers     t_answers;

  forms     t_forms;
  form1  t_form;
    v_item_id number;
    v_ver_nr number(4,2);
  v_temp integer;
  v_nm_typ_id integer;

  v_cnt integer;
    v_found boolean;
BEGIN
  hookinput                    := Ihook.gethookinput (v_data_in);
  hookoutput.invocationnumber  := hookinput.invocationnumber;
  hookoutput.originalrowset    := hookinput.originalrowset;


  if hookInput.invocationNumber = 0  then
     	 answers := t_answers();
  	   	 answer := t_answer(1, 1, 'Bulk Update');
         answers.extend;          answers(answers.last) := answer;
         question := t_question('Choose Option', answers);
       	 hookOutput.question := question;
         row := t_row();
        rows := t_rows();

        ihook.setColumnValue(row, 'ITEM_ID', -1);
        ihook.setColumnValue(row, 'VER_NR',-1); -- Default values
     rows.extend;               rows(rows.last) := row;
        rowset := t_rowset(rows, 'Data Element Concept (Bulk Update Hook)', 1, 'DE_CONC'); -- Default values for form

        forms                  := t_forms();
        form1                  := t_form('Data Element Concept (Bulk Update Hook)', 2,1);
        form1.rowset :=rowset;
        forms.extend;    forms(forms.last) := form1;
        hookoutput.forms := forms;
  	elsif hookInput.invocationNumber = 1 then
        forms              := hookInput.forms;
        form1              := forms(1);
        rowform := form1.rowset.rowset(1);  -- entered values from user
        rows := t_rows();
        rowscd := t_rows();
        for i in 1..hookinput.originalrowset.rowset.count loop
                row_ori :=  hookInput.originalRowset.rowset(i);
                if (ihook.getColumnValue(row_ori, 'ADMIN_ITEM_TYP_ID') = 2) then
                    v_item_id :=ihook.getColumnValue(row_ori, 'ITEM_ID');
                    v_ver_nr :=ihook.getColumnValue(row_ori, 'VER_NR');
                      if (ihook.getColumnValue(rowform, 'ADMIN_STUS_ID') is not null or ihook.getColumnValue(rowform, 'REGSTR_STUS_ID') is not null or
                   ihook.getColumnValue(rowform, 'CNTXT_ITEM_ID') is not null ) then
                        row := row_ori;
                        ihook.setColumnValue(row, 'ADMIN_STUS_ID', nvl(ihook.getColumnValue(rowform, 'ADMIN_STUS_ID'), ihook.getColumnValue(row_ori, 'ADMIN_STUS_ID')));
                        ihook.setColumnValue(row, 'REGSTR_STUS_ID', nvl(ihook.getColumnValue(rowform, 'REGSTR_STUS_ID'), ihook.getColumnValue(row_ori, 'REGSTR_STUS_ID')));
                        ihook.setColumnValue(row, 'CNTXT_ITEM_ID', nvl(ihook.getColumnValue(rowform, 'CNTXT_ITEM_ID'), ihook.getColumnValue(row_ori, 'CNTXT_ITEM_ID')));
                       ihook.setColumnValue(row, 'CNTXT_VER_NR', nvl(ihook.getColumnValue(rowform, 'CNTXT_VER_NR'), ihook.getColumnValue(row_ori, 'CNTXT_VER_NR')));
                   rows.extend;               rows(rows.last) := row;
                    end if;
                    if (ihook.getColumnValue(rowform, 'CONC_DOM_ITEM_ID') is not null ) then
                        row := t_row();
                        nci_11179.spReturnSubTypeRow(v_item_id, v_ver_nr,2, row);
                        ihook.setColumnValue(row, 'CONC_DOM_ITEM_ID', ihook.getColumnValue(rowform, 'CONC_DOM_ITEM_ID'));
                        ihook.setColumnValue(row, 'CONC_DOM_VER_NR', ihook.getColumnValue(rowform, 'CONC_DOM_VER_NR'));
                            rowscd.extend;               rowscd(rowscd.last) := row;
                    end if;
                end if;
        end loop;

               if (rows.count > 0) then
                    action := t_actionrowset(rows, 'Administered Item (No Sequence)', 2,1,'update');
                        actions.extend;
                        actions(actions.last) := action;
                end if;
                 if (rowscd.count > 0) then
                    action := t_actionrowset(rowscd, 'Data Element Concept', 2,1,'update');
                        actions.extend;
                        actions(actions.last) := action;
                end if;
    end if;



if (actions.count > 0) then
  hookoutput.actions := actions;
       hookoutput.message := 'Data Element Concepts updated: ' || greatest(rowscd.count, rows.count);

else
       hookoutput.message := 'Only Data Element Concept will be updated.';

end if;
  V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
-- nci_util.debugHook('GENERAL',v_data_out);
END;



-- Utility procedure to parse the Concept string and update the drop-downs.
-- k is the index 1 - OC, 2 - Prop; For all other item types always 1.

procedure valUsingStr (rowform in out t_row, k in integer, v_item_typ in integer) as
i integer;
v_str varchar2(255);
cnt integer;
v_nm varchar2(255);
v_cncpt_nm varchar2(255);
v_def varchar2(255);
v_item_id number;
v_ver_nr number;
v_long_nm varchar2(255);
begin

    -- Set all the concept drop-down to null

           for i in  1..10 loop
                        ihook.setColumnValue(rowform, 'CNCPT_' || k  ||'_ITEM_ID_' || i,'');
                        ihook.setColumnValue(rowform, 'CNCPT_' || k || '_VER_NR_' || i, '');
            end loop;

    --  Only parse if string is not null

            if (ihook.getColumnValue(rowform, 'CNCPT_CONCAT_STR_' || k) is not null) then
                v_str := trim(ihook.getColumnValue(rowform, 'CNCPT_CONCAT_STR_'|| k));
                cnt := nci_11179.getwordcount(v_str);
                v_nm := '';
                for i in  1..cnt loop
                        v_cncpt_nm := nci_11179.getWord(v_str, i, cnt);
                        ihook.setColumnValue(rowform, 'CNCPT_' || k  ||'_ITEM_ID_' || i,'');
                        ihook.setColumnValue(rowform, 'CNCPT_' || k || '_VER_NR_' || i, '');
                        for cur in(select item_id, item_nm , item_long_nm from admin_item where admin_item_typ_id = 49 and upper(item_long_nm) = upper(trim(v_cncpt_nm))) loop
                                ihook.setColumnValue(rowform, 'CNCPT_' || k  ||'_ITEM_ID_' || i,cur.item_id);
                                ihook.setColumnValue(rowform, 'CNCPT_' || k || '_VER_NR_' || i, 1);
                                v_nm := trim(v_nm || ':' || cur.item_long_nm);
                        end loop;
                end loop;

  -- Check if concept combination esits. If it sodes, set the ITEM_k_ID and ITEM_k_VER_NR.

                nci_11179.CncptCombExists(substr(v_nm,2),v_item_typ,v_item_id, v_ver_nr,v_long_nm, v_def);
                ihook.setColumnValue(rowform, 'ITEM_' || k  ||'_ID',v_item_id);
                ihook.setColumnValue(rowform, 'ITEM_' || k || '_VER_NR', v_ver_nr);
                ihook.setColumnValue(rowform,'ITEM_' || k || '_LONG_NM', trim(substr(v_nm,2)));
                ihook.setColumnValue(rowform,'ITEM_' || k || '_DEF', v_def);
                ihook.setColumnValue(rowform,'ITEM_' || k || '_NM', v_long_nm);
            end if;

            end;


-- Create from existing. Only the start point is different. Else - everything the same as New.

PROCEDURE spDECCreateFrom ( v_data_in IN CLOB, v_data_out OUT CLOB) as
  hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();
    row_ori  t_row;
    row  t_row;
    rows t_rows;
    v_item_id  number;
    v_ver_nr  number(4,2);
    v_ori_rep_cls number;
    v_item_type_id number;
    v_oc_item_id number;
    v_prop_item_id number;
    v_oc_ver_nr number(4,2);
    v_prop_ver_nr number(4,2);
    v_conc_dom_item_id number;
    v_conc_dom_ver_nr number(4,2);
    rowsetai  t_rowset;
    rowsetcncpt  t_rowset;
begin
    -- Standard header
    hookinput                    := Ihook.gethookinput (v_data_in);
    hookoutput.invocationnumber  := hookinput.invocationnumber;
    hookoutput.originalrowset    := hookinput.originalrowset;

    -- Get the selected row
    row_ori :=  hookInput.originalRowset.rowset(1);
    v_item_id := ihook.getColumnValue(row_ori, 'ITEM_ID');
    v_ver_nr := ihook.getColumnValue(row_ori, 'VER_NR');
    v_item_type_id := ihook.getColumnValue(row_ori, 'ADMIN_ITEM_TYP_ID');

    -- check that a selected AI is DEC type
    if (v_item_type_id <> 2) then
        raise_application_error(-20000,'!!! This functionality is only applicable for DEC !!!');
    end if;


    row := row_ori;
    ihook.setColumnValue(row, 'ITEM_ID', -1);
      nci_11179_2.setStdAttr(row);
                 ihook.setColumnValue(row, 'ADMIN_ITEM_TYP_ID', 2);
                        ihook.setColumnValue(row, 'ITEM_LONG_NM', v_dflt_txt);

   --       ihook.setColumnValue(row, 'ITEM_NM', v_dflt_txt);
    --      ihook.setColumnValue(row, 'ITEM_DESC', v_dflt_txt);
       --   ihook.setColumnValue(row, 'ITEM_LONG_NM', v_dflt_txt);
    rows := t_rows();    rows.extend;    rows(rows.last) := row;
     rowsetai := t_rowset(rows, 'Administered Item', 1, 'ADMIN_ITEM'); -- Default values for AI form

     row := t_row();

    select obj_cls_item_id, obj_cls_ver_nr, prop_item_id, prop_ver_nr, conc_dom_item_id, conc_dom_ver_nr into v_oc_item_id, v_oc_ver_nr, v_prop_item_id, v_prop_ver_nr ,
    v_conc_dom_item_id, v_conc_dom_ver_nr
    from de_conc where item_id = v_item_id and ver_nr = v_ver_nr;

     -- Copy subtype specific attributes into concept drop-down
    nci_11179.spReturnConceptRow (v_oc_item_id, v_oc_ver_nr, 5, 1, row );
    nci_11179.spReturnConceptRow (v_prop_item_id, v_prop_ver_nr, 6, 2, row );

    --  Set the conceptual domain and default for dummy internal ID.
    ihook.setColumnValue(row, 'STG_AI_ID', 1);
    ihook.setColumnValue(row, 'CONC_DOM_ITEM_ID', v_conc_dom_item_id);
    ihook.setColumnValue(row, 'CONC_DOM_VER_NR', v_conc_dom_ver_nr);

    rows := t_rows();    rows.extend;    rows(rows.last) := row;
    rowsetcncpt := t_rowset(rows, 'AI Creation With Concepts', 1, 'NCI_STG_AI_CNCPT_CREAT'); -- Default values for form

    spDECCommon(rowsetai,rowsetcncpt ,'insert',2, hookinput, hookoutput);

    V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
    nci_util.debugHook('GENERAL',v_data_out);

end;


-- Create new DEC
PROCEDURE spDECCreateNew ( v_data_in IN CLOB, v_data_out OUT CLOB)
as
  hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();
    row_ori  t_row;
    row  t_row;
    rows t_rows;
     rowsetai  t_rowset;
     rowsetcncpt t_rowset;
begin
    -- Standard header
    hookinput                    := Ihook.gethookinput (v_data_in);
    hookoutput.invocationnumber  := hookinput.invocationnumber;
    hookoutput.originalrowset    := hookinput.originalrowset;


    -- Default for new row. Dummy Identifier has to be set else error.
    row := t_row();
          row := t_row();
          nci_11179_2.setStdAttr(row);
          ihook.setColumnValue(row, 'ADMIN_ITEM_TYP_ID', 2);
          ihook.setColumnValue(row, 'ITEM_NM', v_dflt_txt);
          ihook.setColumnValue(row, 'ITEM_DESC', v_dflt_txt);
          ihook.setColumnValue(row, 'ITEM_LONG_NM', v_dflt_txt);

    rows := t_rows(); rows.extend;    rows(rows.last) := row;
    rowsetai := t_rowset(rows, 'Administered Item', 1, 'ADMIN_ITEM'); -- Default values for AI form
     row := t_row();
        ihook.setColumnValue(row, 'STG_AI_ID', 1);

    rows := t_rows();    rows.extend;    rows(rows.last) := row;
    rowsetcncpt := t_rowset(rows, 'AI Creation With Concepts', 1, 'NCI_STG_AI_CNCPT_CREAT'); -- Default values for form

    spDECCommon(rowsetai,rowsetcncpt, 'insert',1, hookinput, hookoutput);

    V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
    nci_util.debugHook('GENERAL',v_data_out);
end;

-- Edit an existing DEC

PROCEDURE spDECEdit ( v_data_in IN CLOB, v_data_out OUT CLOB, v_usr_id  IN varchar2)
as
    hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();
    row_ori  t_row;
    row  t_row;
    rows t_rows;
    v_item_id  number;
    v_ver_nr  number(4,2);
    v_ori_rep_cls number;
    v_item_type_id number;
    v_oc_item_id number;
    v_prop_item_id number;
    v_oc_ver_nr number(4,2);
    v_prop_ver_nr number(4,2);
      v_conc_dom_item_id number;
    v_conc_dom_ver_nr number(4,2);

    rowsetai  t_rowset;
    rowsetcncpt  t_rowset;


begin
    -- Standard header
    hookInput                    := Ihook.gethookinput (v_data_in);
    hookOutput.invocationnumber  := hookInput.invocationnumber;
    hookOutput.originalrowset    := hookInput.originalrowset;

    -- Get the selected row
    row_ori :=  hookInput.originalRowset.rowset(1);
    v_item_id := ihook.getColumnValue(row_ori, 'ITEM_ID');
    v_ver_nr := ihook.getColumnValue(row_ori, 'VER_NR');
    v_item_type_id := ihook.getColumnValue(row_ori, 'ADMIN_ITEM_TYP_ID');


    -- Check if user is authorized to edit
    if (nci_11179_2.isUserAuth(v_item_id, v_ver_nr, v_usr_id) = false) then
        raise_application_error(-20000, 'You are not authorized to insert/update or delete in this context. ');
        return;
    end if;

    -- check that a selected AI is DEC type
    if (v_item_type_id <> 2) then
        raise_application_error(-20000,'!!! This functionality is only applicable for DEC !!!');
    end if;

    row := row_ori;

    rows := t_rows();    rows.extend;    rows(rows.last) := row;
     rowsetai := t_rowset(rows, 'Administered Item', 1, 'ADMIN_ITEM'); -- Default values for AI form

    --  Only AI row is submitted with the hook. We need to get the sub-type details and populate the OC/Prop concepts
    row := t_row();

    select obj_cls_item_id, obj_cls_ver_nr, prop_item_id, prop_ver_nr, conc_dom_item_id, conc_dom_ver_nr into v_oc_item_id, v_oc_ver_nr, v_prop_item_id, v_prop_ver_nr ,
    v_conc_dom_item_id, v_conc_dom_ver_nr
    from de_conc where item_id = v_item_id and ver_nr = v_ver_nr;

     -- Copy OC and Prop concepts
    nci_11179.spReturnConceptRow (v_oc_item_id, v_oc_ver_nr, 5, 1, row );
    nci_11179.spReturnConceptRow (v_prop_item_id, v_prop_ver_nr, 6, 2, row );

    -- Internal dummy is is set to 1. Existing CD is populated.
    ihook.setColumnValue(row, 'STG_AI_ID', 1);
    ihook.setColumnValue(row, 'CONC_DOM_ITEM_ID', v_conc_dom_item_id);
    ihook.setColumnValue(row, 'CONC_DOM_VER_NR', v_conc_dom_ver_nr);


    rows := t_rows();    rows.extend;    rows(rows.last) := row;
    rowsetcncpt := t_rowset(rows, 'DEC Create Edit (Hook)', 1, 'NCI_STG_AI_CNCPT_CREAT');

    spDECCommon(rowsetai,rowsetcncpt,  'update',3, hookinput, hookoutput);

    V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);

nci_util.debugHook('GENERAL', v_data_out);

end;


-- Common routine for DEC - Create or Update
-- v_init is the initial rowset to populate.
-- v_op is insert or update
PROCEDURE       spDECCommon ( v_init in t_rowset,  v_init_cncpt in t_rowset, v_op  in varchar2, v_src in integer, hookInput in t_hookInput, hookOutput in out t_hookOutput)
AS
rowform t_row;
forms t_forms;
form1 t_form;

row t_row;
rows  t_rows;
row_ori t_row;
rowai t_row;
rowset            t_rowset;
v_oc_item_id number;
v_oc_ver_nr number;
v_prop_item_id number;
v_prop_ver_nr number;
v_dec_item_id number;
v_str  varchar2(255);
v_nm  varchar2(255);
v_item_id number;
v_ver_nr number(4,2);
cnt integer;

actions t_actions := t_actions();
action t_actionRowset;
i integer := 0;
v_dec_nm varchar2(255);
v_cncpt_nm varchar2(255);
v_long_nm varchar2(255);
v_def varchar2(4000);
v_oc_id number;
v_prop_id number;
v_temp_id  number;
v_temp_ver number(4,2);
v_oc_str varchar2(4000);
v_prop_str varchar2(4000);
rowsetcncpt t_rowset;
v_err_str  varchar2(4000);

is_valid boolean;
begin
    if hookInput.invocationNumber = 0 then
        --  Get question. Either create or edit
          HOOKOUTPUT.QUESTION    := getDECQuestion(v_op, v_src);

   row := t_row();

    -- Send initial rowset to create the form.
          hookOutput.forms :=getDECCreateForm(v_init, v_init_cncpt);
    else
        forms              := hookInput.forms;
        form1              := forms(1);
        rowai := form1.rowset.rowset(1);
        form1              := forms(2);
        rowform := form1.rowset.rowset(1);
        -- Copy context from AI row to be used in OC and Prop creation
        ihook.setColumnValue(rowform, 'CNTXT_ITEM_ID', ihook.getColumnValue(rowai, 'CNTXT_ITEM_ID'));
         ihook.setColumnValue(rowform, 'CNTXT_VER_NR', ihook.getColumnValue(rowai, 'CNTXT_VER_MR'));

        row := t_row();        rows := t_rows();
        is_valid := true;

        if HOOKINPUT.ANSWERID = 1 or Hookinput.answerid = 3 then  -- Validate using string
            for k in  1..2  loop
                    for i in  1..10 loop
                            ihook.setColumnValue(rowform, 'CNCPT_' || k  ||'_ITEM_ID_' || i,'');
                            ihook.setColumnValue(rowform, 'CNCPT_' || k || '_VER_NR_' || i, '');
                    end loop;
            end loop;
            for k in  1..2  loop -- both OC and Prop
                createValAIWithConcept(rowform , k,4+k,'V','STRING',actions);
            end loop;
        end if;

        if HOOKINPUT.ANSWERID = 2 or Hookinput.answerid = 4 then  -- Validate using drop-down
            for k in  1..2  loop -- Both OC and prop
               createValAIWithConcept(rowform , k,4+k,'V','DROP-DOWN',actions);
            end loop;
        end if;

    -- Show generated name
       ihook.setColumnValue(rowform, 'GEN_STR',replace(ihook.getColumnValue(rowform,'ITEM_1_NM') ||  ' ' || ihook.getColumnValue(rowform,'ITEM_2_NM'),'Integer::','') ) ;
       ihook.setColumnValue(rowform, 'CTL_VAL_MSG', 'VALIDATED');
   -- ihook.setColumnValue(row,'ITEM_NM', v_nm, 'Integer::',''));

    -- Check if DEC is a duplicate. Removed Context from the test as per Denise.
       v_item_id := -1;

  -- If update, then need to get the Item_id to exclude from duplicate check
       if (lower(v_op) = 'update') then
            row_ori :=  hookInput.originalRowset.rowset(1);
            v_item_id := ihook.getColumnValue(row_ori,'ITEM_ID');
            v_ver_nr := ihook.getColumnValue(row_ori,'VER_NR');
       end if;


         if (   ihook.getColumnValue(rowform, 'ITEM_1_ID') is not null and ihook.getColumnValue(rowform, 'ITEM_2_ID') is not null) then
            select cncpt_concat into v_oc_str from nci_admin_item_ext where item_id = ihook.getColumnValue(rowform, 'ITEM_1_ID') and ver_nr= ihook.getColumnValue(rowform, 'ITEM_1_VER_NR');
            select cncpt_concat into v_prop_str from nci_admin_item_ext where item_id = ihook.getColumnValue(rowform, 'ITEM_2_ID') and ver_nr= ihook.getColumnValue(rowform, 'ITEM_2_VER_NR');
            for oc_cur in (select ai.item_id, ai.ver_nr from admin_item ai, nci_admin_item_ext e where ai.item_id = e.item_id and ai.ver_nr = e.ver_nr and e.cncpt_concat = v_oc_str and ai.admin_item_typ_id = 5) loop
            for prop_cur in (select ai.item_id, ai.ver_nr from admin_item ai, nci_admin_item_ext e where ai.item_id = e.item_id and ai.ver_nr = e.ver_nr and e.cncpt_concat = v_prop_str and ai.admin_item_typ_id = 6) loop
               for cur in (select de_conc.* from de_conc, admin_item ai where obj_cls_item_id =  oc_cur.item_id and obj_cls_ver_nr =  oc_cur.ver_nr and
               prop_item_id = prop_cur.item_id and prop_ver_nr =  prop_cur.ver_nr and
               cntxt_item_id = ihook.getColumnValue(rowai, 'CNTXT_ITEM_ID') and cntxt_ver_nr = ihook.getColumnValue(rowai, 'CNTXT_VER_NR') and
              de_conc.item_id = ai.item_id and de_conc.ver_nr = ai.ver_nr and de_conc.item_id <> v_item_id
             ) loop
                    ihook.setColumnValue(rowform, 'CTL_VAL_MSG', 'DUPLICATE DEC found:' || cur.item_id || 'v' || cur.ver_nr);
                    is_valid := false;
              end loop;
              end loop;
              end loop;
        end if;

        if (   ihook.getColumnValue(rowform, 'CNCPT_1_ITEM_ID_1') is null or ihook.getColumnValue(rowform, 'CNCPT_2_ITEM_ID_1') is null) then
                  ihook.setColumnValue(rowform, 'CTL_VAL_MSG', 'OC or PROP missing.');
                  is_valid := false;
        end if;

          v_err_str := '';
        nci_11179_2.stdAIValidation(rowai, 2,is_valid, v_err_str );
    --    nci_11179_2.stdCncptRowValidation(rowform, 1,is_valid, v_err_str );
     --   nci_11179_2.stdCncptRowValidation(rowform, 2,is_valid, v_err_str );
        if (v_err_str is not null) then
            ihook.setColumnValue(rowform, 'CTL_VAL_MSG', v_err_Str);
        end if;


         -- If any of the test fails or if the user has triggered validation, then go back to the screen.
        if (is_valid=false or hookinput.answerid = 1 or hookinput.answerid = 2) then

                hookoutput.message := ihook.getColumnValue(rowform, 'CTL_VAL_MSG');
                ihook.setColumnValue(rowai, 'ITEM_NM', ihook.getColumnValue(rowform, 'GEN_STR'));
       --         ihook.setColumnValue(rowform, 'CNTXT_VER_NR', ihook.getColumnValue(rowai, 'CNTXT_VER_MR'));
                ihook.setColumnValue(rowai, 'ADMIN_ITEM_TYP_ID', 2);

                rows := t_rows();
                rows.extend;
                rows(rows.last) := rowai;
                rowset := t_rowset(rows, 'Administered Item', 1, 'ADMIN_ITEM');


                rows := t_rows();
                rows.extend;
                rows(rows.last) := rowform;
                rowsetcncpt := t_rowset(rows, 'AI Creation With Concepts', 1, 'NCI_STG_AI_CNCPT_CREAT');
                hookOutput.forms := getDECCreateForm(rowset, rowsetcncpt);
                HOOKOUTPUT.QUESTION    := getDECQuestion(v_op, v_src);
        end if;

    -- If all the tests have passed and the user has asked for create, then create DEC and optionally OC and Prop.

    IF HOOKINPUT.ANSWERID in ( 3,4)  and is_valid = true THEN  -- Create
        createValAIWithConcept(rowform , 1,5,'C','DROP-DOWN',actions); -- OC
        createValAIWithConcept(rowform , 2,6,'C','DROP-DOWN',actions); -- Property

    --If Create DEC
    if (upper(v_op) = 'INSERT') then

        createDEC(rowai, rowform, actions, v_item_id);
        hookoutput.message := 'DEC Created Successfully with ID ' || v_item_id ;
    else
    -- Update DEC. Get the selected row, update name, definition, context.
        row := t_row();
        row_ori :=  hookInput.originalRowset.rowset(1);

        v_item_id := ihook.getColumnValue(row_ori,'ITEM_ID');
        v_ver_nr := ihook.getColumnValue(row_ori,'VER_NR');

        --- Update name, definition, context
            row := rowai;

               ihook.setColumnValue(row, 'ADMIN_ITEM_TYP_ID', 2);
     ihook.setColumnValue(row, 'ITEM_DESC',substr(ihook.getColumnValue(rowform, 'ITEM_1_DEF')  || ':' || ihook.getColumnValue(rowform, 'ITEM_2_DEF'),1,4000));
         ihook.setColumnValue(row,'ITEM_NM',  replace(ihook.getColumnValue(rowform, 'ITEM_1_NM')  || ' ' || ihook.getColumnValue(rowform, 'ITEM_2_NM'),'Integer::',''));

            --  ihook.setColumnValue(row, 'ADMIN_STUS_ID', ihook.getColumnValue(rowform,'ADMIN_STUS_ID'));
           -- ihook.setColumnValue(row, 'REGSTR_STUS_ID', ihook.getColumnValue(rowform,'REGSTR_STUS_ID'));
      --      raise_application_error(-20000,  ihook.getColumnValue(rowform,'ITEM_LONG_NM'));
          --  ihook.setColumnValue(row, 'ITEM_LONG_NM', ihook.getColumnValue(rowform,'ITEM_LONG_NM'));
           rows := t_rows();    rows.extend;    rows(rows.last) := row;
             action := t_actionrowset(rows, 'Administered Item (No Sequence)', 2,10,'update');
            actions.extend;
            actions(actions.last) := action;

           row := t_row();

           -- Get the current DEC row. Update OC, Prop, CD.
            nci_11179.spReturnSubtypeRow (v_item_id, v_ver_nr, 2, row );
            ihook.setColumnValue(row, 'OBJ_CLS_ITEM_ID', ihook.getColumnValue(rowform,'ITEM_1_ID'));
            ihook.setColumnValue(row, 'OBJ_CLS_VER_NR', ihook.getColumnValue(rowform,'ITEM_1_VER_NR'));
            ihook.setColumnValue(row, 'PROP_ITEM_ID', ihook.getColumnValue(rowform,'ITEM_2_ID'));
            ihook.setColumnValue(row, 'PROP_VER_NR', ihook.getColumnValue(rowform,'ITEM_2_VER_NR'));
            ihook.setColumnValue(row, 'CONC_DOM_ITEM_ID', ihook.getColumnValue(rowform,'CONC_DOM_ITEM_ID'));
            ihook.setColumnValue(row, 'CONC_DOM_VER_NR', ihook.getColumnValue(rowform,'CONC_DOM_VER_NR'));

             rows := t_rows();    rows.extend;    rows(rows.last) := row;
             action := t_actionrowset(rows, 'Data Element Concept', 2,11,'update');
            actions.extend;
            actions(actions.last) := action;
    end if;  -- End update if
    if (actions.count > 0) then
        hookoutput.actions := actions;
    end if;
end if; -- End creation if.
     -- raise_application_error(-20000,'Inside');

end if; -- not first invocation if

END;


--Used in Import  v_op - 'V'  validate, 'C' create
procedure spDECValCreateImport ( rowform in out t_row,  v_op  in varchar2, actions in out t_actions, v_val_ind in out boolean)
AS
  forms t_forms;
  form1 t_form;

  row t_row;
  rows  t_rows;
  row_ori t_row;
  rowset            t_rowset;
  v_oc_item_id number;
  v_oc_ver_nr number;
  v_oc_long_nm varchar2(255);
  v_oc_nm varchar2(255);
  v_prop_nm varchar2(255);
  v_oc_def  varchar2(2000);

  v_prop_item_id number;
  v_prop_ver_nr number;
  v_prop_long_nm varchar2(255);
  v_prop_def  varchar2(2000);
  v_dec_item_id number;
 v_str  varchar2(255);
 v_nm  varchar2(255);
 v_item_id number;
 v_ver_nr number(4,2);
  cnt integer;

  v_msg varchar2(1000);
  i integer := 0;
  v_err  integer;
  column  t_column;
  v_dec_nm varchar2(255);
  v_cncpt_nm varchar2(255);
  v_long_nm varchar2(255);
  v_def varchar2(4000);
  v_oc_id number;
  v_prop_id number;
  v_temp_id  number;
  v_temp_ver number(4,2);
  is_valid boolean;
begin
    -- Show generated name
    if (ihook.getColumnValue(rowform, 'DE_CONC_ITEM_ID') is null) then --- only execute if not specified
       ihook.setColumnValue(rowform, 'GEN_DE_CONC_NM',ihook.getColumnValue(rowform,'ITEM_1_NM') ||  ' ' || ihook.getColumnValue(rowform,'ITEM_2_NM') ) ;
    -- Check if DEC is a duplicate. Removed Context from the test as per Denise.

        ihook.setColumnValue(rowform, 'DE_CONC_ITEM_ID_FND', '');
        ihook.setColumnValue(rowform, 'DE_CONC_VER_NR_FND', '' );
     --       raise_application_error(-20000, 'Front' ||  ihook.getColumnValue(rowform, 'ITEM_1_ID'));

       if (   ihook.getColumnValue(rowform, 'ITEM_1_ID') is not null and ihook.getColumnValue(rowform, 'ITEM_2_ID') is not null) then
              for cur in (select de_conc.* from de_conc, admin_item ai where obj_cls_item_id =  ihook.getColumnValue(rowform, 'ITEM_1_ID') and obj_cls_ver_nr =  ihook.getColumnValue(rowform, 'ITEM_1_VER_NR') and
               prop_item_id = ihook.getColumnValue(rowform, 'ITEM_2_ID') and prop_ver_nr =  ihook.getColumnValue(rowform, 'ITEM_2_VER_NR') and
              de_conc.item_id = ai.item_id and de_conc.ver_nr = ai.ver_nr and ai.currnt_ver_ind = 1
             ) loop
                    ihook.setColumnValue(rowform, 'DE_CONC_ITEM_ID_FND', cur.item_id );
                    ihook.setColumnValue(rowform, 'DE_CONC_VER_NR_FND', cur.ver_nr );
               end loop;
              return;
        end if;
        if (   ihook.getColumnValue(rowform, 'CNCPT_1_ITEM_ID_1') is null or ihook.getColumnValue(rowform, 'CNCPT_2_ITEM_ID_1') is null) then
                  ihook.setColumnValue(rowform, 'CTL_VAL_MSG', ihook.getColumnValue(rowform, 'CTL_VAL_MSG') || 'OC or PROP missing.' || chr(13));
                  v_val_ind:= false;
        end if;

            if (   ihook.getColumnValue(rowform, 'CONC_DOM_ITEM_ID') is null ) then
                ihook.setColumnValue(rowform, 'CTL_VAL_MSG', ihook.getColumnValue(rowform, 'CTL_VAL_MSG') || 'DEC Conceptual Domain is missing.' || chr(13));
                  v_val_ind:= false;
        end if;

         rows := t_rows();

    IF v_val_ind = true and v_op = 'C' and ihook.getColumnValue(rowform, 'DE_CONC_ITEM_ID_FND') is null THEN  -- Create
   -- raise_application_error(-20000, 'here');
        createValAIWithConcept(rowform , 1,5,'C','DROP-DOWN',actions); -- OC
        createValAIWithConcept(rowform , 2,6,'C','DROP-DOWN',actions); -- Property
        createDECImport(rowform, actions);

    end if;
end if;
     -- raise_application_error(-20000,'Inside');


END;


--- Used to create VM with no concepts. Can be used for any Admin Item Type where there are no concepts but a string is to be used for comparison.
procedure createAIWithoutConcept(rowform in out t_row, idx in integer, v_item_typ_id in integer, v_long_nm in varchar2, v_desc in varchar2, actions in out t_actions) as
v_def  varchar2(4000);
row t_row;
rows t_rows;
 action t_actionRowset;

 v_temp_id  number;
 v_temp_ver number(4,2);
 v_item_id  number;
 v_ver_nr number(4,2);
 v_id integer;

v_obj_nm  varchar2(100);
v_temp varchar2(4000);
begin


    for cur in (select ai.item_id, ai.ver_nr from nci_admin_item_ext e, admin_item ai where ai.item_id = e.item_id and ai.ver_nr = e.ver_nr
    and upper(cncpt_concat_nm) = upper(v_long_nm) and ai.admin_item_typ_id = v_item_typ_id) loop
        ihook.setColumnValue(rowform,'ITEM_' || idx || '_ID',cur.item_id);
        ihook.setColumnValue(rowform,'ITEM_' || idx || '_VER_NR',cur.ver_nr);
         ihook.setColumnValue(rowform,'CTL_VAL_MSG', 'Reusing Existing VM: ' || cur.item_id);
        return;
    end loop;
        v_id := nci_11179.getItemId;
        rows := t_rows();
        row := t_row();

        ihook.setColumnValue(rowform,'CTL_VAL_MSG', 'VM Created: ' || v_id);

     -- to return values to calling program
       ihook.setColumnValue(rowform,'ITEM_' || idx || '_ID', v_id);
       ihook.setColumnValue(rowform,'ITEM_' || idx || '_VER_NR', 1);

        ihook.setColumnValue(row,'ITEM_ID', v_id);
        ihook.setColumnValue(row,'ADMIN_ITEM_TYP_ID', v_item_typ_id);
        nci_11179_2.setStdAttr(row);
        nci_11179_2.setItemLongNm (row, v_id);
        ihook.setColumnValue(row,'ITEM_DESC',v_desc);
        ihook.setColumnValue(row,'ITEM_NM', v_long_nm);
        ihook.setColumnValue(row,'CNTXT_ITEM_ID', ihook.getColumnValue(rowform,'CNTXT_ITEM_ID'));
        ihook.setColumnValue(row,'CNTXT_VER_NR', ihook.getColumnValue(rowform,'CNTXT_VER_NR'));
        ihook.setColumnValue(row,'CNCPT_CONCAT', v_long_nm);
        ihook.setColumnValue(row,'CNCPT_CONCAT_DEF',v_long_nm);
        ihook.setColumnValue(row,'CNCPT_CONCAT_NM', v_long_nm);
          ihook.setColumnValue(row,'LST_UPD_DT',sysdate );

        rows.extend;
        rows(rows.last) := row;
    -- raise_application_error(-20000, 'HEre ' || v_nm || v_long_nm || v_def);


        action := t_actionrowset(rows, 'Administered Item (No Sequence)', 2,1,'insert');
        actions.extend;
        actions(actions.last) := action;


        action := t_actionrowset(rows, 'NCI AI Extension (Hook)', 2,3,'insert');
        actions.extend;
        actions(actions.last) := action;

       case v_item_typ_id
       when 5 then v_obj_nm := 'Object Class';
       when 6 then v_obj_nm := 'Property';
       when 53 then v_obj_nm := 'Value Meaning';
       when 7 then v_obj_nm := 'Representation Class';

        end case;
        action := t_actionrowset(rows, v_obj_nm, 2,2,'insert');
        actions.extend;
        actions(actions.last) := action;

end;

-- v_mode : V - Validate, C - Validation and Create;  v_cncpt_src:  STRING: String; DROP-DOWN: Drop-downs
procedure createValAIWithConcept(rowform in out t_row, idx in integer,v_item_typ_id in integer,v_mode in varchar2, v_cncpt_src in varchar2, actions in out t_actions) as
v_nm  varchar2(255);
v_long_nm varchar2(255);
v_def  varchar2(4000);
row t_row;
rows t_rows;
 action t_actionRowset;
 v_cncpt_id  number;
 v_cncpt_ver_nr number(4,2);
 v_temp_id  number;
 v_temp_ver number(4,2);
 v_item_id  number;
 v_ver_nr number(4,2);
 v_id integer;
 v_long_nm_suf  varchar2(255);
 v_long_nm_suf_int  varchar2(255);
 j integer;
i integer;
cnt integer;
v_str varchar2(255);
v_obj_nm  varchar2(100);
v_temp varchar2(4000);
v_cncpt_nm varchar2(255);
begin

-- If use string to create concept drop-down

             v_nm := '';
                v_long_nm := '';
                v_def := '';
        v_long_nm_suf := '';
                v_long_nm_suf_int := '';

if (v_cncpt_src ='STRING') then
      if (ihook.getColumnValue(rowform, 'CNCPT_CONCAT_STR_' || idx) is not null) then
                v_str := trim(ihook.getColumnValue(rowform, 'CNCPT_CONCAT_STR_'|| idx));
                cnt := nci_11179.getwordcount(v_str);

                for i in  1..cnt loop
                        v_cncpt_nm := nci_11179.getWord(v_str, i, cnt);
                        ihook.setColumnValue(rowform, 'CNCPT_' || idx  ||'_ITEM_ID_' || i,'');
                        ihook.setColumnValue(rowform, 'CNCPT_' || idx || '_VER_NR_' || i, '');
                        for cur in(select item_id, item_nm , item_long_nm, item_desc from admin_item where admin_item_typ_id = 49 and upper(item_long_nm) = upper(trim(v_cncpt_nm))) loop
                                ihook.setColumnValue(rowform, 'CNCPT_' || idx  ||'_ITEM_ID_' || i,cur.item_id);
                                ihook.setColumnValue(rowform, 'CNCPT_' || idx || '_VER_NR_' || i, 1);
                                    v_long_nm_suf := trim(v_long_nm_suf || ':' || cur.item_long_nm);
                                     v_long_nm_suf_int := trim(v_long_nm_suf_int || ':' || cur.item_long_nm);
                                v_nm := trim(v_nm || ' ' || cur.item_nm);
                                           v_def := substr( v_def || '_' ||cur.item_desc  ,1,4000);
             end loop;
                end loop;
                for i in  cnt+1..10 loop
                        ihook.setColumnValue(rowform, 'CNCPT_' || idx  ||'_ITEM_ID_' || i,'');
                        ihook.setColumnValue(rowform, 'CNCPT_' || idx || '_VER_NR_' || i, '');
                end loop;
            end if;

end if;

-- If drop-downs to be used to check existing or new

if (v_cncpt_src ='DROP-DOWN') then
                for i in 1..10 loop
                        v_temp_id := ihook.getColumnValue(rowform, 'CNCPT_' || idx  ||'_ITEM_ID_' || i);
                        v_temp_ver := ihook.getColumnValue(rowform, 'CNCPT_' || idx || '_VER_NR_' || i);
                        if (v_temp_id is not null) then
                        for cur in(select item_id, item_nm , item_long_nm , item_desc from admin_item where admin_item_typ_id = 49 and item_id = v_temp_id and ver_nr = v_temp_ver) loop
                          --       v_dec_nm := trim(v_dec_nm || ' ' || cur.item_nm) ;
                                  v_def := substr( v_def || '_' ||cur.item_desc  ,1,4000);
                              if (cur.item_id = v_int_cncpt_id and trim(ihook.getColumnValue(rowform,'CNCPT_INT_' || idx || '_' || i) ) is not null) then --- integer concept
                                        v_long_nm_suf_int := trim(v_long_nm_suf_int || ':' || cur.item_long_nm) || '::' || trim(ihook.getColumnValue(rowform,'CNCPT_INT_' || idx || '_' || i));
                                         v_nm := trim(v_nm || ' ' || cur.item_nm) || '::' ||  trim(ihook.getColumnValue(rowform,'CNCPT_INT_' || idx || '_' || i)) ;
                                         v_def := v_def || '::' ||  trim(ihook.getColumnValue(rowform,'CNCPT_INT_' || idx || '_' || i));
                                else
                                      v_nm := trim(v_nm || ' ' || cur.item_nm);
                                        v_long_nm_suf_int := trim(v_long_nm_suf_int || ':' || cur.item_long_nm);

                                end if;
                                   v_long_nm_suf := trim(v_long_nm_suf || ':' || cur.item_long_nm);


                         end loop;
                        end if;
                end loop;

  end if;

                    ihook.setColumnValue(rowform,'ITEM_' || idx || '_LONG_NM', substr(v_long_nm_suf,2));
                     if (v_item_typ_id = 53) then
                            ihook.setColumnValue(rowform,'ITEM_' || idx || '_NM', replace(v_nm, 'Integer::',''));
                    else
                            ihook.setColumnValue(rowform,'ITEM_' || idx || '_NM', v_nm);
                    end if;

           --     ihook.setColumnValue(rowform,'ITEM_' || idx || '_NM', v_nm);
             ihook.setColumnValue(rowform,'ITEM_' || idx || '_DEF', substr(v_def,2));
            ihook.setColumnValue(rowform,'ITEM_' || idx || '_LONG_NM_INT', substr(v_long_nm_suf_int,2));

-- Check if combo exists. If it does, then v_item_id will be set.

    CncptCombExistsNew (rowform , substr(v_long_nm_suf_int,2), v_item_typ_id, idx , v_item_id, v_ver_nr);

-- If not existing and mode is Create, then create the actions.

    if ((v_mode = 'C' AND V_ITEM_ID  is null) or (v_mode = 'O'))  then --- Create; O is override. Create a duplicate
        v_id := nci_11179.getItemId;
     --   raise_application_error(-20000, v_long_nm_suf_int);
        rows := t_rows();
        j := 0;
    --    v_nm := '';
     --   v_long_nm := '';
      --  v_def := '';
        for i in reverse 0..10 loop
            v_cncpt_id := ihook.getColumnValue(rowform, 'CNCPT_' || idx  ||'_ITEM_ID_' || i);
             v_cncpt_ver_nr :=  ihook.getColumnValue(rowform, 'CNCPT_' || idx || '_VER_NR_' || i);
            if( v_cncpt_id is not null) then
                for cur in (select item_nm, item_long_nm, item_desc from admin_item where item_id = v_cncpt_id and ver_nr = v_cncpt_ver_nr) loop
                        row := t_row();
                        ihook.setColumnValue(row,'ITEM_ID', v_id);
                        ihook.setColumnValue(row,'VER_NR', 1);
                        ihook.setColumnValue(row,'CNCPT_ITEM_ID',v_cncpt_id);
                        ihook.setColumnValue(row,'CNCPT_VER_NR', v_cncpt_ver_nr);
                        ihook.setColumnValue(row,'NCI_ORD', j);
                        v_temp := v_temp || i || ':' ||  v_cncpt_id;

                        if j = 0 then
                            ihook.setColumnValue(row,'NCI_PRMRY_IND', 1);
                        else ihook.setColumnValue(row,'NCI_PRMRY_IND', 0);
                        end if;
                         if (v_cncpt_id = v_int_cncpt_id and trim(ihook.getColumnValue(rowform,'CNCPT_INT_' || idx || '_' || i)) is not null) then
                       --     v_nm := trim(cur.item_nm) ||  '::' || trim(ihook.getColumnValue(rowform,'CNCPT_INT_' || idx || '_' || i)) || ' ' || v_nm ;
                            ihook.setColumnValue(row,'NCI_CNCPT_VAL',ihook.getColumnValue(rowform,'CNCPT_INT_' || idx || '_' || i));
                      --      v_def := substr(cur.item_desc || '::' || trim(ihook.getColumnValue(rowform,'CNCPT_INT_' || idx || '_' || i)) || '_' || v_def,1,4000);
                                           v_long_nm := trim(v_long_nm || ':' || cur.item_long_nm) || '::' || trim(ihook.getColumnValue(rowform,'CNCPT_INT_' || idx || '_' || i));
                   --   else
                        --    v_nm := trim(cur.item_nm) || ' ' || v_nm ;
                        --            v_def := substr( cur.item_desc || '_' || v_def,1,4000);
                         --              v_long_nm := trim(v_long_nm || ':' || cur.item_long_nm);
                         end if;
                        rows.extend;
                        rows(rows.last) := row;


                         j := j+ 1;
                end loop;
            end if;
        end loop;

        -- Insert into CNCPT_ADMIN_ITEM
       action := t_actionrowset(rows, 'Items under Concept (Hook)', 2,6,'insert');
        actions.extend;
        actions(actions.last) := action;

        rows := t_rows();
        --row := rowform;
        row := t_row();
        v_long_nm := substr(v_long_nm,2);
        v_nm := substr(trim(v_nm),1, c_nm_len);

        -- if lenght of short name is greater than 30, then use IDv1.00
        if (length(v_long_nm_suf_int) > 30) then
            v_long_nm_suf_int := v_id || c_ver_suffix;
        end if;

    -- Administered Item Row
        ihook.setColumnValue(row,'ITEM_ID', v_id);
        ihook.setColumnValue(row,'ADMIN_ITEM_TYP_ID', v_item_typ_id);
        nci_11179_2.setStdAttr(row);
        ihook.setColumnValue(row,'ITEM_LONG_NM', substr(v_long_nm_suf_int,2));
        ihook.setColumnValue(row,'ITEM_DESC', substr(v_def, 2));
     --   ihook.setColumnValue(row,'ITEM_DESC', v_def);
       if (v_item_typ_id = 53) then
        v_nm := replace(v_nm, 'Integer::', '');
       end if;
        ihook.setColumnValue(row,'ITEM_NM', v_nm);
        ihook.setColumnValue(row,'CNTXT_ITEM_ID', nvl(ihook.getColumnValue(rowform,'CNTXT_ITEM_ID'),20000000024 ));  --- NCIP
        ihook.setColumnValue(row,'CNTXT_VER_NR', nvl(ihook.getColumnValue(rowform,'CNTXT_VER_NR'),1));
        ihook.setColumnValue(row,'CNCPT_CONCAT', substr(v_long_nm_suf,2));
       ihook.setColumnValue(row,'CNCPT_CONCAT_DEF', substr(v_def, 1, length(v_def)-1));
       -- ihook.setColumnValue(row,'CNCPT_CONCAT_DEF', v_def);
        ihook.setColumnValue(row,'CNCPT_CONCAT_NM', v_nm);
        ihook.setColumnValue(row,'CNCPT_CONCAT_WITH_INT', substr(v_long_nm_suf_int,2));
        ihook.setColumnValue(row,'LST_UPD_DT',sysdate );

        rows.extend;
        rows(rows.last) := row;

        -- Update form Name/Long Name/Definition so uer can see.
       ihook.setColumnValue(rowform,'ITEM_' || idx || '_LONG_NM', v_long_nm);
        ihook.setColumnValue(rowform,'ITEM_' || idx || '_DEF', substr(v_def, 2));
        ihook.setColumnValue(rowform,'ITEM_' || idx || '_NM', v_nm);
        ihook.setColumnValue(rowform, 'ITEM_' || idx || '_ID', v_id);
         ihook.setColumnValue(rowform, 'ITEM_' || idx || '_VER_NR', 1);

        action := t_actionrowset(rows, 'Administered Item (No Sequence)', 2,1,'insert');
        actions.extend;
        actions(actions.last) := action;

      action := t_actionrowset(rows, 'NCI AI Extension (Hook)', 2,3,'insert');
        actions.extend;
        actions(actions.last) := action;

       case v_item_typ_id
            when 5 then v_obj_nm := 'Object Class';
            when 6 then v_obj_nm := 'Property';
            when 53 then v_obj_nm := 'Value Meaning';
            when 7 then v_obj_nm := 'Representation Class';
        end case;
        action := t_actionrowset(rows, v_obj_nm, 2,2,'insert');
        actions.extend;
        actions(actions.last) := action;
end if;

end;

procedure CncptCombExistsNew (rowform in out t_row, v_item_nm in varchar2, v_item_typ in integer, v_idx in number, v_item_id out number, v_item_ver_nr out number)
as
v_out integer;
v_long_nm  varchar2(30);
v_nm varchar2(255);
v_def varchar2(4000);

begin

            ihook.setColumnValue(rowform, 'ITEM_' || v_idx  ||'_ID','');
                ihook.setColumnValue(rowform, 'ITEM_' || v_idx || '_VER_NR', '');

    for cur in (select ext.* from nci_admin_item_ext ext,admin_item a
    where nvl(a.fld_delete,0) = 0 and a.item_id = ext.item_id and a.ver_nr = ext.ver_nr and cncpt_concat_with_int = v_item_nm and a.admin_item_typ_id = v_item_typ) loop
                 ihook.setColumnValue(rowform, 'ITEM_' || v_idx  ||'_ID',cur.item_id);
                 v_item_id := cur.item_id;
                 v_item_ver_nr := cur.ver_nr;
                ihook.setColumnValue(rowform, 'ITEM_' || v_idx || '_VER_NR', cur.ver_nr);
                ihook.setColumnValue(rowform,'ITEM_' || v_idx || '_LONG_NM', cur.cncpt_concat);
                ihook.setColumnValue(rowform,'ITEM_' || v_idx || '_DEF',  cur.CNCPT_CONCAT_DEF);
                ihook.setColumnValue(rowform,'ITEM_' || v_idx || '_NM', cur.CNCPT_CONCAT_NM);

    end loop;
 --   if (v_item_typ = 6) then
  --raise_application_error(-20000, v_item_nm || '  ' || v_item_id);

--end if;
end;


function getDECQuestion (v_op in varchar2, v_src in integer) return t_question
is
  question t_question;
begin
    if (upper(v_op) = 'INSERT') then
        question := getDECCreateQuestion(v_src);
    else
        question := getDECEditQuestion();
    end if;
return question;
end;

function getDECEditQuestion return t_question is
  question t_question;
  answer t_answer;
  answers t_answers;
begin
--- If Edit DEC
    ANSWERS                    := T_ANSWERS();
    ANSWER                     := T_ANSWER(2, 2, 'Validate Using Drop-Down');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
    ANSWER                     := T_ANSWER(4, 4, 'Update Using Drop-Down');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
    QUESTION               := T_QUESTION('Edit DEC', ANSWERS);

return question;
end;

function getDECCreateQuestion (v_src in integer) return t_question is
  question t_question;
  answer t_answer;
  answers t_answers;
begin
-- IF create or Create from Existing DEC
 ANSWERS                    := T_ANSWERS();
    ANSWER                     := T_ANSWER(1, 1, 'Validate Using String');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
  --  ANSWERS                    := T_ANSWERS();
    ANSWER                     := T_ANSWER(2, 2, 'Validate Using Drop-Down');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
    ANSWER                     := T_ANSWER(3, 3, 'Create Using String');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
    ANSWER                     := T_ANSWER(4, 4, 'Create Using Drop-Down');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
    if (v_src = 1) then -- Create new
    QUESTION               := T_QUESTION('Create New DEC', ANSWERS);
    else
    QUESTION               := T_QUESTION('Create DEC from Existing', ANSWERS);
    end if;

return question;
end;



procedure createDEC (rowai in t_row, rowform in t_row, actions in out t_actions, v_id out  number) as
v_nm  varchar2(255);
v_long_nm varchar2(255);
v_def  varchar2(4000);
row t_row;
rows t_rows;
 action t_actionRowset;
 --v_id number;
begin
   rows := t_rows();
   row := rowai;
     v_id := nci_11179.getItemId;
        ihook.setColumnValue(row,'ITEM_ID', v_id);
        ihook.setColumnValue(row,'VER_NR', 1);
        ihook.setColumnValue(row,'CURRNT_VER_IND', 1);
        ihook.setColumnValue(row,'ADMIN_ITEM_TYP_ID', 2);
   /*     v_long_nm := trim(ihook.getColumnValue(rowform, 'ITEM_1_LONG_NM_INT')  || ' ' || ihook.getColumnValue(rowform, 'ITEM_2_LONG_NM_INT'));
       if (    trim(ihook.getColumnValue(rowai, 'ITEM_LONG_NM')) = v_dflt_txt and length(v_long_nm) <= 30 ) then
       ihook.setColumnValue(row,'ITEM_LONG_NM', v_long_nm);
       elsif  (upper(trim(ihook.getColumnValue(rowai, 'ITEM_LONG_NM')))='SYSGEN' or (  trim(ihook.getColumnValue(rowai, 'ITEM_LONG_NM')) = v_dflt_txt and length(v_long_nm) > 30) ) then
            ihook.setColumnValue(row,'ITEM_LONG_NM', v_id || c_ver_suffix);
        else
            ihook.setColumnValue(row,'ITEM_LONG_NM', ihook.getColumnValue(rowai, 'ITEM_LONG_NM'));
        end if;
        */
       if (    trim(ihook.getColumnValue(rowai, 'ITEM_LONG_NM')) = v_dflt_txt or upper(trim(ihook.getColumnValue(rowai, 'ITEM_LONG_NM')))='SYSGEN'  ) then
            ihook.setColumnValue(row,'ITEM_LONG_NM', nci_11179_2.getStdShortName(ihook.getColumnValue(rowform,'ITEM_1_ID'), ihook.getColumnValue(rowform,'ITEM_1_VER_NR')) || ':' ||
          nci_11179_2.getStdShortName(ihook.getColumnValue(rowform,'ITEM_2_ID'), ihook.getColumnValue(rowform,'ITEM_2_VER_NR')))  ;
        else
            ihook.setColumnValue(row,'ITEM_LONG_NM', ihook.getColumnValue(rowai, 'ITEM_LONG_NM'));
        end if;

       --     raise_application_error(-20000, ihook.getColumnValue(row,'ITEM_LONG_NM') || length(v_long_nm));

        ihook.setColumnValue(row,'ITEM_NM',  replace(ihook.getColumnValue(rowform, 'ITEM_1_NM')  || ' ' || ihook.getColumnValue(rowform, 'ITEM_2_NM'),'Integer::',''));
        ihook.setColumnValue(row,'ITEM_DESC',substr(ihook.getColumnValue(rowform, 'ITEM_1_DEF')  || ':' || ihook.getColumnValue(rowform, 'ITEM_2_DEF'),1,4000));

        -- replace INTEGER :: from name
      --  v_nm := ihook.getColumnValue(row,'ITEM_NM');
      -- ihook.setColumnValue(row,'ITEM_NM', replace(v_nm, 'Integer::',''));
       ihook.setColumnValue(row,'CONC_DOM_ITEM_ID',nvl(ihook.getColumnValue(rowform,'CONC_DOM_ITEM_ID'),1) );
        ihook.setColumnValue(row,'CONC_DOM_VER_NR',nvl(ihook.getColumnValue(rowform,'CONC_DOM_VER_NR'),1) );
        ihook.setColumnValue(row,'OBJ_CLS_ITEM_ID',nvl(ihook.getColumnValue(rowform, 'ITEM_1_ID'),1) );
        ihook.setColumnValue(row,'OBJ_CLS_VER_NR',nvl(ihook.getColumnValue(rowform, 'ITEM_1_VER_NR'),1) );
        ihook.setColumnValue(row,'PROP_ITEM_ID',nvl(ihook.getColumnValue(rowform, 'ITEM_2_ID'),1));
        ihook.setColumnValue(row,'PROP_VER_NR',nvl(ihook.getColumnValue(rowform, 'ITEM_2_VER_NR'),1));
        ihook.setColumnValue(row,'LST_UPD_DT',sysdate );
        rows.extend;
        rows(rows.last) := row;

        action := t_actionrowset(rows, 'Administered Item (No Sequence)', 2,7,'insert');
        actions.extend;
        actions(actions.last) := action;

      action := t_actionrowset(rows, 'Data Element Concept', 2,8,'insert');
       actions.extend;
        actions(actions.last) := action;


end;


procedure createDECImport (rowform in out t_row, actions in out t_actions) as
v_nm  varchar2(255);
v_long_nm varchar2(255);
v_def  varchar2(4000);
row t_row;
rows t_rows;
 action t_actionRowset;
 v_id number;
begin
   rows := t_rows();
   row := t_row();
     v_id := nci_11179.getItemId;
        ihook.setColumnValue(row,'ITEM_ID', v_id);
        ihook.setColumnValue(rowform,'DE_CONC_ITEM_ID_CREAT', v_id);

      --  raise_application_error (-20000, ihook.getColumnValue(rowform,'CONC_DOM_ITEM_ID')  || ihook.getColumnValue(rowform, 'ITEM_1_ID') || ihook.getColumnValue(rowform, 'ITEM_2_ID'));
        ihook.setColumnValue(row,'VER_NR', 1);

        ihook.setColumnValue(row,'CURRNT_VER_IND', 1);
        ihook.setColumnValue(row,'ADMIN_ITEM_TYP_ID', 2);
   --     ihook.setColumnValue(row,'ITEM_LONG_NM', ihook.getColumnValue(rowform, 'ITEM_1_LONG_NM')  || ':' || ihook.getColumnValue(rowform, 'ITEM_2_LONG_NM'));
            ihook.setColumnValue(row,'ITEM_LONG_NM', v_id || c_ver_suffix);

        ihook.setColumnValue(row,'ITEM_NM',  ihook.getColumnValue(rowform, 'GEN_DE_CONC_NM'));
        ihook.setColumnValue(row,'ITEM_DESC',substr(ihook.getColumnValue(rowform, 'ITEM_1_DEF')  || ':' || ihook.getColumnValue(rowform, 'ITEM_2_DEF'),1,4000));
        ihook.setColumnValue(row,'CNTXT_ITEM_ID', ihook.getColumnValue(rowform,'CNTXT_ITEM_ID'));
        ihook.setColumnValue(row,'CNTXT_VER_NR', ihook.getColumnValue(rowform,'CNTXT_VER_NR'));
        ihook.setColumnValue(row,'ADMIN_STUS_ID',66);
         ihook.setColumnValue(row,'REGSTR_STUS_ID',9);
       ihook.setColumnValue(row,'CONC_DOM_ITEM_ID',nvl(ihook.getColumnValue(rowform,'CONC_DOM_ITEM_ID'),1) );
        ihook.setColumnValue(row,'CONC_DOM_VER_NR',nvl(ihook.getColumnValue(rowform,'CONC_DOM_VER_NR'),1) );
        ihook.setColumnValue(row,'OBJ_CLS_ITEM_ID',nvl(ihook.getColumnValue(rowform, 'ITEM_1_ID'),1) );
        ihook.setColumnValue(row,'OBJ_CLS_VER_NR',nvl(ihook.getColumnValue(rowform, 'ITEM_1_VER_NR'),1) );
        ihook.setColumnValue(row,'PROP_ITEM_ID',nvl(ihook.getColumnValue(rowform, 'ITEM_2_ID'),1));
        ihook.setColumnValue(row,'PROP_VER_NR',nvl(ihook.getColumnValue(rowform, 'ITEM_2_VER_NR'),1));
        ihook.setColumnValue(row,'LST_UPD_DT',sysdate );
        rows.extend;
        rows(rows.last) := row;
--raise_application_error(-20000, 'Deep' || ihook.getColumnValue(row,'CNTXT_ITEM_ID') || 'ggg'|| ihook.getColumnValue(row,'ADMIN_STUS_ID') || 'GGGG' || ihook.getColumnValue(row,'ITEM_ID'));

        action := t_actionrowset(rows, 'Administered Item (No Sequence)', 2,7,'insert');
        actions.extend;
        actions(actions.last) := action;

      action := t_actionrowset(rows, 'Data Element Concept', 2,8,'insert');
       actions.extend;
        actions(actions.last) := action;
 ihook.setColumnValue(rowform, 'CTL_VAL_MSG', ihook.getColumnValue(rowform, 'CTL_VAL_MSG') || 'DEC Created Successfully with ID ' || v_id||c_ver_suffix || chr(13)) ;

--r
end;
-- Create form for DEC.
function getDECCreateForm (v_rowset1 in t_rowset,v_rowset2 in t_rowset) return t_forms is
  forms t_forms;
  form1 t_form;
begin
    forms                  := t_forms();
    forms                  := t_forms();
    form1                  := t_form('Administered Item (DEC Create)', 2,1);
    form1.rowset :=v_rowset1;
    forms.extend;    forms(forms.last) := form1;
    form1                  := t_form('DEC Create Edit (Hook)', 2,1);
    form1.rowset :=v_rowset2;
    forms.extend;    forms(forms.last) := form1;
  return forms;
end;

END;
/


DROP PACKAGE BODY ONEDATA_WA.NCI_DLOAD;

CREATE OR REPLACE PACKAGE BODY ONEDATA_WA.nci_dload AS

c_long_nm_len  integer := 30;
c_nm_len integer := 255;
c_ver_suffix varchar2(5) := 'v1.00';
v_dflt_txt    varchar2(100) := 'Enter text or auto-generated.';


-- Generic create question
function getAddComponentCreateQuestion return t_question is
  question t_question;
  answer t_answer;
  answers t_answers;
begin

 ANSWERS                    := T_ANSWERS();
    ANSWER                     := T_ANSWER(1, 1, 'Add');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
    QUESTION               := T_QUESTION('Please select Items to Add.', ANSWERS);

return question;
end;


-- Generic create question
function getAddComponentCreateQuestionID return t_question is
  question t_question;
  answer t_answer;
  answers t_answers;
begin

 ANSWERS                    := T_ANSWERS();
    ANSWER                     := T_ANSWER(1, 1, 'Add');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
    QUESTION               := T_QUESTION('Please separate items with a single space between ids in order for total count of items to be correct. Select and click on Add.', ANSWERS);

return question;
end;


procedure spDeleteDloadItem  ( v_data_in IN CLOB, v_data_out OUT CLOB, v_usr_id  IN varchar2)
AS
    hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();
    actions t_actions := t_actions();
    action t_actionRowset;
    row t_row;
    rows  t_rows;
    row_ori t_row;
    v_usr_hdr  varchar2(255);
  action_rows       t_rows := t_rows();
  action_row		    t_row;
  rowset            t_rowset;


BEGIN
  hookinput                    := Ihook.gethookinput (v_data_in);
  hookoutput.invocationnumber  := hookinput.invocationnumber;
  hookoutput.originalrowset    := hookinput.originalrowset;
 rows := t_rows();

 row_ori :=  hookInput.originalRowset.rowset(1);

 select creat_usr_id into v_usr_hdr from nci_dload_hdr where
hdr_id = ihook.getColumnValue(row_ori, 'HDR_ID');
 if (upper(v_usr_hdr) <> upper(v_usr_id)) then
 raise_application_error(-20000,'You are not authorized to delete in this collection.');
 end if;
for i in 1..hookinput.originalrowset.rowset.count loop
 row_ori :=  hookInput.originalRowset.rowset(i);

            rows.extend;
            rows(rows.last) := row_ori;
    end loop;
            action             := t_actionrowset(rows, 'Download Detail', 2, 0,'delete');
            actions.extend;
            actions(actions.last) := action;

  action             := t_actionrowset(rows, 'Download Detail', 2, 1,'purge');
            actions.extend;
            actions(actions.last) := action;

            hookoutput.actions    := actions;


  V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
END;


procedure spDeleteDloadItemGuest  ( v_data_in IN CLOB, v_data_out OUT CLOB, v_usr_id  IN varchar2)
AS
    hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();
    actions t_actions := t_actions();
    action t_actionRowset;
    row t_row;
    rows  t_rows;
    row_ori t_row;
    v_usr_hdr  varchar2(255);
  action_rows       t_rows := t_rows();
  action_row		    t_row;
  rowset            t_rowset;
  row_dtl t_row;
  forms t_forms;
  form1 t_form;
  rowform t_row;

BEGIN
  hookinput                    := Ihook.gethookinput (v_data_in);
  hookoutput.invocationnumber  := hookinput.invocationnumber;
  hookoutput.originalrowset    := hookinput.originalrowset;
 rows := t_rows();

 row_ori :=  hookInput.originalRowset.rowset(1);

 select creat_usr_id into v_usr_hdr from nci_dload_hdr where
hdr_id = ihook.getColumnValue(row_ori, 'HDR_ID');
 if (upper(v_usr_hdr) <> 'GUEST') then
 raise_application_error(-20000,'You are not authorized to delete in this collection.');
 end if;

 if (hookinput.invocationNumber = 0) then
       rows := t_rows();
        row := t_row();
        nci_11179.spGetCartPin (hookoutput,'P');
    end if;

    if hookinput.invocationnumber = 1 then -- show create form
         forms              := hookInput.forms;
           form1              := forms(1);
        rowform := form1.rowset.rowset(1);

          --  raise_application_error(-20000, ihook.getColumnValue(rowform, 'HDR_ID'));
        if (validatePin(ihook.getColumnValue(row_ori, 'HDR_ID'), ihook.getColumnValue(rowform, 'GUEST_USR_PWD')) = false) then
            raise_application_error(-20000, 'Invalid Pin. Please check and try again.');
            return;
        end if;

for i in 1..hookinput.originalrowset.rowset.count loop


 row_dtl :=  hookInput.originalRowset.rowset(i);

            rows.extend;
            rows(rows.last) := row_dtl;
    end loop;
            action             := t_actionrowset(rows, 'Download Detail', 2, 0,'delete');
            actions.extend;
            actions(actions.last) := action;

  action             := t_actionrowset(rows, 'Download Detail', 2, 1,'purge');
            actions.extend;
            actions(actions.last) := action;

            hookoutput.actions    := actions;

end if;
  V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
END;


    -- Not used at this time.
procedure spCreateDloadProfile (v_data_in in clob, v_data_out out clob, v_usr_id  IN varchar2)
AS
    hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();

    forms t_forms;
    form1 t_form;
    actions t_actions := t_actions();
    action t_actionRowset;
    row t_row;
    rowsethdr            t_rowset;
    rowsetals            t_rowset;

    rows  t_rows;
    rowhdr t_row;
    rowals t_row;
    v_item_id  number;
    v_ver_nr number(4,2);
    v_temp integer;
    v_add integer :=0;
    v_already integer :=0;
    i integer := 0;
    v_id number;
begin
    hookinput := ihook.gethookinput (v_data_in);
    hookoutput.invocationnumber  := hookinput.invocationnumber;
    hookoutput.originalrowset    := hookinput.originalrowset;

    if (hookinput.invocationnumber = 0) then -- show create form
        rows := t_rows();
        row := t_row();
        ihook.setColumnValue(row, 'HDR_ID', -1);
        ihook.setColumnValue(row, 'DLOAD_FMT_ID',90 );
        rows.extend;          rows(rows.last) := row;
          rowsethdr := t_rowset(rows, 'Download Header', 1, 'NCI_DLOAD_HDR');
        rows := t_rows();
        row := t_row();
            ihook.setColumnValue(row, 'HDR_ID', -1);
        rows.extend;          rows(rows.last) := row;
          rowsetals := t_rowset(rows, 'ALS Specific', 1, 'NCI_DLOAD_HDR');

          hookOutput.forms := getALSCreateForm(rowsethdr, rowsetals, 90);
          HOOKOUTPUT.QUESTION    := getALSCreateQuestion(90);
    else --- Second invocation
         forms              := hookInput.forms;

           form1              := forms(1);
      rowhdr := form1.rowset.rowset(1);
      form1              := forms(2);
      rowals := form1.rowset.rowset(1);
        v_id := nci_11179_2.getCollectionId;
        ihook.setColumnValue(rowhdr, 'HDR_ID', v_id);
        ihook.setColumnValue(rowals, 'HDR_ID', v_id);
           ihook.setColumnValue(rowhdr, 'DLOAD_FMT_ID',90 );

       rows := t_rows();
    rows.extend;
    rows(rows.last) := rowhdr;
    action := t_actionrowset(rows, 'Download Header (Hook)', 2,1,'insert');
    actions.extend;
    actions(actions.last) := action;
      rows := t_rows();
    rows.extend;
    rows(rows.last) := rowals;
    action := t_actionrowset(rows,'ALS Specific', 2,2,'insert');
    actions.extend;
    actions(actions.last) := action;
    hookoutput.actions := actions;
    hookoutput.message := 'Collection Successfully Created with ID ' || v_id;
    end if;
    V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
--     nci_util.debugHook('GENERAL', v_data_out);
END;

function validatePin(v_hdr_id in number, v_pin in number) return boolean is
v_return boolean :=false;
begin
for cur in (select * from nci_dload_hdr where hdr_id = v_hdr_id and GUEST_USR_PWD = v_pin) loop
    v_return := true;
end loop;
return v_return;
end;
    -- Not used at this time.
procedure spCreateDloadProfileGuest (v_data_in in clob, v_data_out out clob, v_usr_id  IN varchar2)
AS
    hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();

    forms t_forms;
    form1 t_form;
    actions t_actions := t_actions();
    action t_actionRowset;
    row t_row;
    rowsethdr            t_rowset;
    rowsetals            t_rowset;

    rows  t_rows;
    rowhdr t_row;
    rowals t_row;
    v_item_id  number;
    v_ver_nr number(4,2);
    v_temp integer;
    v_add integer :=0;
    v_already integer :=0;
    i integer := 0;
    v_id number;
    v_als boolean;
    v_fmt integer;
begin
    hookinput := ihook.gethookinput (v_data_in);
    hookoutput.invocationnumber  := hookinput.invocationnumber;
    hookoutput.originalrowset    := hookinput.originalrowset;

    if (hookinput.invocationnumber = 0) then -- show create form
        rows := t_rows();
        row := t_row();
    nci_11179.spGetCartPin(hookoutput, 'I');
    end if;

    if hookinput.invocationnumber = 1 then -- show create form
        forms              := hookInput.forms;
          form1              := forms(1);
      row := form1.rowset.rowset(1);
      --row := t_row();
      rows := t_rows();
  v_fmt :=  ihook.getColumnValue(row, 'DLOAD_FMT_ID');
        ihook.setColumnValue(row, 'HDR_ID', -1);
      --  ihook.setColumnValue(row, 'DLOAD_FMT_ID',90 );
        rows.extend;          rows(rows.last) := row;
          rowsethdr := t_rowset(rows, 'Download Header (Base Object)', 1, 'NCI_DLOAD_HDR');

                rows := t_rows();
                row := t_row();
                 ihook.setColumnValue(row, 'HDR_ID', -1);
                rows.extend;          rows(rows.last) := row;
                rowsetals := t_rowset(rows, 'ALS Specific', 1, 'NCI_DLOAD_HDR');

                hookOutput.forms := getCollectionCreateFormGuest(rowsethdr, rowsetals,v_fmt);

          HOOKOUTPUT.QUESTION    := getALSCreateQuestion (v_fmt);
      end if;
    if  hookinput.invocationnumber = 2 then--- Second invocation
         forms              := hookInput.forms;
         form1              := forms(1);
        rowhdr := form1.rowset.rowset(1);
        v_als := false;
    --    raise_application_error(-20000, hookinput.answerid);

        if (hookinput.answerid = 90) then
            form1              := forms(2);
            rowals := form1.rowset.rowset(1);
            v_als := true;
        end if;
        v_id := nci_11179_2.getCollectionId;
        ihook.setColumnValue(rowhdr, 'HDR_ID', v_id);
           ihook.setColumnValue(rowhdr, 'DLOAD_FMT_ID',hookinput.answerid );

       rows := t_rows();
    rows.extend;
    rows(rows.last) := rowhdr;
    action := t_actionrowset(rows, 'Download Header (Base Object)', 2,1,'insert');
    actions.extend;
    actions(actions.last) := action;

    if v_als then
      ihook.setColumnValue(rowals, 'HDR_ID', v_id);

      rows := t_rows();
    rows.extend;
    rows(rows.last) := rowals;
    action := t_actionrowset(rows,'ALS Specific', 2,2,'insert');
    actions.extend;
    actions(actions.last) := action;
    end if;
    hookoutput.actions := actions;
    hookoutput.message := 'Collection Successfully Created with ID ' || v_id;
    end if;
    V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
     nci_util.debugHook('GENERAL', v_data_out);
END;



procedure spEditDloadProfileGuest (v_data_in in clob, v_data_out out clob, v_usr_id  IN varchar2)
AS
    hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();

    forms t_forms;
    form1 t_form;
    actions t_actions := t_actions();
    action t_actionRowset;
    row t_row;
    rowsethdr            t_rowset;
    rowsetals            t_rowset;

    rowform t_row;
    rows  t_rows;
    rowhdr t_row;
    rowals t_row;
    v_item_id  number;
    v_ver_nr number(4,2);
    v_temp integer;
    v_add integer :=0;
    v_already integer :=0;
    i integer := 0;
    v_id number;
    v_als boolean :=false;
    row_ori t_row;
begin
    hookinput := ihook.gethookinput (v_data_in);
    hookoutput.invocationnumber  := hookinput.invocationnumber;
    hookoutput.originalrowset    := hookinput.originalrowset;

    row_ori := hookInput.originalRowset.rowset(1);

   if (ihook.getColumnValue(row_ori, 'DLOAD_FMT_ID') = 90) then
    v_als := true;
    end if;
    if (hookinput.invocationnumber = 0) then -- show create form
        rows := t_rows();
        row := t_row();
        nci_11179.spGetCartPin (hookoutput,'P');
    end if;

    if hookinput.invocationnumber = 1 then -- show create form
         forms              := hookInput.forms;
           form1              := forms(1);
        rowform := form1.rowset.rowset(1);

          --  raise_application_error(-20000, ihook.getColumnValue(rowform, 'HDR_ID'));
        if (validatePin(ihook.getColumnValue(row_ori, 'HDR_ID'), ihook.getColumnValue(rowform, 'GUEST_USR_PWD')) = false) then
            raise_application_error(-20000, 'Invalid Pin. Please check and try again.');
            return;
        end if;
        rows := t_rows();
        row := row_ori;
            rows.extend;          rows(rows.last) := row;
          rowsethdr := t_rowset(rows, 'Download Header (Base Object)', 1, 'NCI_DLOAD_HDR');

        rows := t_rows();
        row := t_row();
            nci_11179.ReturnRow('select * from NCI_DLOAD_ALS where hdr_id = ' ||  ihook.getColumnValue(row_ori, 'HDR_ID'), 'NCI_DLOAD_ALS', row);
            rows.extend;          rows(rows.last) := row;

          rowsetals := t_rowset(rows, 'ALS Specific', 1, 'NCI_DLOAD_ALS');

          hookOutput.forms := getALSCreateForm(rowsethdr, rowsetals,ihook.getColumnValue(row_ori, 'DLOAD_FMT_ID'));
          HOOKOUTPUT.QUESTION    := getALSCreateQuestion(ihook.getColumnValue(row_ori, 'DLOAD_FMT_ID'));
      end if;
    if  hookinput.invocationnumber = 2 then--- Second invocation
         forms              := hookInput.forms;
         form1              := forms(1);

          rowhdr := form1.rowset.rowset(1);

        if (v_als = true) then
            form1              := forms(2);
            rowals := form1.rowset.rowset(1);
        end if;
        --ihook.setColumnValue(rowhdr, 'HDR_ID', ihook.getColumnValue);
           ihook.setColumnValue(rowhdr, 'DLOAD_FMT_ID',ihook.getColumNValue(row_ori, 'DLOAD_FMT_ID') );

       rows := t_rows();
    rows.extend;
    rows(rows.last) := rowhdr;
    action := t_actionrowset(rows, 'Download Header (Base Object)', 2,1,'update');
    actions.extend;
    actions(actions.last) := action;

    if v_als then
      ihook.setColumnValue(rowals, 'HDR_ID', ihook.getColumnValue(row_ori,'HDR_ID'));
      rows := t_rows();
    rows.extend;
    rows(rows.last) := rowals;
    action := t_actionrowset(rows,'ALS Specific', 2,2,'update');
    actions.extend;
    actions(actions.last) := action;
    end if;
    hookoutput.actions := actions;
    hookoutput.message := 'Collection successfully updated.';
    end if;
    V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
     nci_util.debugHook('GENERAL', v_data_out);
END;



-- This is to call Irina's program.
procedure spTriggerDload (v_data_in in clob, v_data_out out clob, v_usr_id  IN varchar2)
AS
    hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();

    actions t_actions := t_actions();
    action t_actionRowset;
    row t_row;
    rows  t_rows;
    row_ori t_row;
    v_item_id  number;
    v_ver_nr number(4,2);
    v_temp integer;
    v_add integer :=0;
    v_already integer :=0;
    i integer := 0;

begin
    hookinput := ihook.gethookinput (v_data_in);
    hookoutput.invocationnumber  := hookinput.invocationnumber;
    hookoutput.originalrowset    := hookinput.originalrowset;

        hookoutput.message := 'Work in progress.';
    V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
END;


-- Add from Cart.
procedure spAddComponentToDload (v_data_in in clob, v_data_out out clob, v_usr_id  IN varchar2)
AS
    hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();

    actions t_actions := t_actions();
    action t_actionRowset;
    row t_row;
    row_sel t_row;
    rows  t_rows;
    row_ori t_row;
    v_item_id  number;
    v_ver_nr number(4,2);
    v_temp integer;
    v_add integer :=0;
    v_already integer :=0;
    i integer := 0;
    v_item_typ_id integer;
    v_found boolean;

    showrowset	t_showablerowset;
begin
    hookinput := ihook.gethookinput (v_data_in);
    hookoutput.invocationnumber  := hookinput.invocationnumber;
    hookoutput.originalrowset    := hookinput.originalrowset;

    row_ori := hookInput.originalRowset.rowset(1);
    -- 92 - FOrm, 93 - CDE
    -- Depending on the type of collection, show either Forms or CDE's

    if (hookinput.invocationnumber = 0) then
        if (ihook.getColumnValue(row_ori,'DLOAD_TYP_ID') = 92) then
            v_item_typ_id := 54;
            else v_item_typ_id := 4;
        end if;
        rows := t_rows();

        -- Get items from user cart based on type
        for cur in (select c.item_id, c.ver_nr from NCI_USR_CART c, admin_item ai where c.fld_delete= 0 and cntct_secu_id = v_usr_id and ai.item_id = c.item_id and ai.ver_nr = c.ver_nr and
        ai.admin_item_typ_id = v_item_typ_id order by admin_item_typ_id) loop
		   row := t_row();
	   	   iHook.setcolumnvalue (ROW, 'ITEM_ID', cur.ITEM_ID);
		   iHook.setcolumnvalue (ROW, 'VER_NR', cur.VER_NR);
		   iHook.setcolumnvalue (ROW, 'CNTCT_SECU_ID', v_usr_id);
		   rows.extend;
		   rows (rows.last) := row;
		   v_found := true;
	    end loop;

	  if (v_found) then
       	 showrowset := t_showablerowset (rows, 'User Cart', 2, 'multi');
       	 hookoutput.showrowset := showrowset;
        hookOutput.question := getAddComponentCreateQuestion;
     else
        hookoutput.message := 'Please add forms or CDE to your cart.';
     end if;
	end if; -- First invocation

    if hookInput.invocationNumber = 1  then -- Items selected from cart. Second invocation
       rows := t_rows();
       for i in 1..hookInput.selectedRowset.rowset.count loop -- Loop thru all the selected items.
          row_sel := hookInput.selectedRowset.rowset(i);

          ihook.setColumnValue(row_sel, 'HDR_ID', ihook.getColumnValue(row_ori,'HDR_ID'));

          -- Add only if not already in collection.
          select count(*) into v_temp from nci_dload_dtl where hdr_id = ihook.getColumnValue(row_ori,'HDR_ID') and item_id = ihook.getColumnValue(row_sel,'ITEM_ID')
          and ver_nr = ihook.getColumnValue(row_sel,'VER_NR');
          if (v_temp = 0) then
          	   rows.extend;
                rows (rows.last) := row_sel;
           end if;
        end loop;

        -- If something to add.
        if (rows.count > 0) then
            action := t_actionrowset(rows, 'Download Detail', 2,0,'insert');
            actions.extend;
            actions(actions.last) := action;
            hookoutput.actions := actions;
      --  hookoutput.message := v_add || ' item(s) added successfully to cart. ' || v_already || ' item(s) selected already in yout cart';
        end if;
    end if;
V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
END;



-- Add from Cart.
procedure spAddComponentToDloadNew (v_data_in in clob, v_data_out out clob, v_usr_id  IN varchar2)
AS
    hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();
forms t_forms;
  form1 t_form;
  rowform t_row;
    actions t_actions := t_actions();
    action t_actionRowset;
    row t_row;
    row_sel t_row;
    rows  t_rows;
    row_ori t_row;
    v_item_id  number;
    v_ver_nr number(4,2);
    v_temp integer;
    v_add integer :=0;
    v_already integer :=0;
    i integer := 0;
    v_item_typ_id integer;
    v_found boolean;
    v_usr_typ char(1);
    showrowset	t_showablerowset;
begin
    hookinput := ihook.gethookinput (v_data_in);
    hookoutput.invocationnumber  := hookinput.invocationnumber;
    hookoutput.originalrowset    := hookinput.originalrowset;

    row_ori := hookInput.originalRowset.rowset(1);
    -- Check if called from Guest User or Logged in user
    if ( ihook.getColumnValue(row_ori, 'CREAT_USR_ID') = 'GUEST' or v_usr_id = 'GUEST') then
        v_usr_typ := 'G';
    else v_usr_typ := 'L' ;
    end if;

    if (hookinput.invocationnumber = 0) then
        if (v_usr_typ = 'L') then
            nci_11179.spGetCartPin(hookoutput, 'C');
        elsif (v_usr_typ ='G') then
            nci_11179.spGetCartPin(hookoutput, 'B');
        end if;

    end if;


     if (hookinput.invocationnumber = 1)  then
       forms              := hookInput.forms;
        form1              := forms(1);
        rowform := form1.rowset.rowset(1);

        if (ihook.getColumnValue(row_ori,'CREAT_USR_ID') ='GUEST') then
            if(validatePin(ihook.getColumnValue(row_ori,'HDR_ID'), ihook.getColumnValue(rowform,'GUEST_USR_PWD'))= false) then
                raise_application_error(-20000, 'You are not authorized. Wrong Pin.');
            end if;
        end if;

        if (ihook.getColumnValue(row_ori,'DLOAD_TYP_ID') = 92) then
            v_item_typ_id := 54;
            else v_item_typ_id := 4;
        end if;

        rows := t_rows();

        -- Get items from user cart based on type
        for cur in (select c.item_id, c.ver_nr from NCI_USR_CART c, admin_item ai where c.fld_delete= 0 and cntct_secu_id = v_usr_id and ai.item_id = c.item_id and ai.ver_nr = c.ver_nr and
        ai.admin_item_typ_id = v_item_typ_id and upper(guest_usr_nm) = upper(ihook.getColumnValue(rowform, 'GUEST_USR_NM')) order by admin_item_typ_id) loop
		   row := t_row();
	   	   iHook.setcolumnvalue (ROW, 'ITEM_ID', cur.ITEM_ID);
		   iHook.setcolumnvalue (ROW, 'VER_NR', cur.VER_NR);
		   iHook.setcolumnvalue (ROW, 'CNTCT_SECU_ID', v_usr_id);
		   rows.extend;
		   rows (rows.last) := row;
		   v_found := true;
	    end loop;

	  if (v_found) then
       	 showrowset := t_showablerowset (rows, 'User Cart', 2, 'multi');
       	 hookoutput.showrowset := showrowset;
        hookOutput.question := getAddComponentCreateQuestion;
     else
        hookoutput.message := 'Please add forms or CDE to your cart.';
     end if;
	end if; -- First invocation

    if hookInput.invocationNumber = 2  then -- Items selected from cart. Second invocation
       rows := t_rows();
       for i in 1..hookInput.selectedRowset.rowset.count loop -- Loop thru all the selected items.
          row_sel := hookInput.selectedRowset.rowset(i);

          ihook.setColumnValue(row_sel, 'HDR_ID', ihook.getColumnValue(row_ori,'HDR_ID'));

          -- Add only if not already in collection.
          select count(*) into v_temp from nci_dload_dtl where hdr_id = ihook.getColumnValue(row_ori,'HDR_ID') and item_id = ihook.getColumnValue(row_sel,'ITEM_ID')
          and ver_nr = ihook.getColumnValue(row_sel,'VER_NR');
          if (v_temp = 0) then
          	   rows.extend;
                rows (rows.last) := row_sel;
           end if;
        end loop;

        -- If something to add.
        if (rows.count > 0) then
            action := t_actionrowset(rows, 'Download Detail', 2,0,'insert');
            actions.extend;
            actions(actions.last) := action;
            hookoutput.actions := actions;
        hookoutput.message := rows.count || ' item(s) added successfully to collection. ' ;
        end if;
    end if;
V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
END;



procedure spAddComponentToDloadID (v_data_in in clob, v_data_out out clob, v_usr_id  IN varchar2)
AS
    hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();

    actions t_actions := t_actions();
    action t_actionRowset;
    row t_row;
    row_sel t_row;
    rows  t_rows;
    rowscart  t_rows;
    row_ori t_row;
    v_item_id  number;
    v_ver_nr number(4,2);
    v_temp integer;
    v_add integer :=0;
    i integer := 0;
    v_item_typ_id integer;
    v_found boolean;
    v_str varchar2(4000);
    cnt integer;
 forms t_forms;
  form1 t_form;
  v_cnt_valid_fmt integer;
  v_cnt_valid_type integer;
  v_cnt_already integer;
  v_invalid_fmt varchar2(50) := '';
  v_invalid_typ varchar2(100) := '';
  v_dup_str  varchar2(50) := '';
begin
    hookinput := ihook.gethookinput (v_data_in);
    hookoutput.invocationnumber  := hookinput.invocationnumber;
    hookoutput.originalrowset    := hookinput.originalrowset;

        row_ori := hookInput.originalRowset.rowset(1);
        -- 92 - FOrm, 93 - CDE
      -- Depending on the type of collection, show either Forms or CDE's
  if (ihook.getColumnValue(row_ori,'DLOAD_TYP_ID') = 92) then
        v_item_typ_id := 54;
        else v_item_typ_id := 4;
    end if;

    if (hookinput.invocationnumber = 0) then   -- First invocation
         forms                  := t_forms();
        form1                  := t_form('Add Item to Collection (Hook)', 2,1);
        forms.extend;    forms(forms.last) := form1;
        hookoutput.forms := forms;
       	 hookOutput.question := getAddComponentCreateQuestionID;
	end if;

    if hookInput.invocationNumber = 1  then  -- Seconf invocation
       rows := t_rows();
       row := t_row();

        v_cnt_valid_fmt := 0;
        v_cnt_valid_type := 0;

        forms              := hookInput.forms;
        form1              := forms(1);
        row_sel := form1.rowset.rowset(1);
        v_str := trim(ihook.getColumnValue(row_sel, 'VM_DESC_TXT'));
             cnt := nci_11179.getwordcount(v_str);

        row := t_row();
        rows := t_rows();
        rowscart := t_rows();
        ihook.setColumnValue(row, 'HDR_ID', ihook.getColumnValue(row_ori,'HDR_ID'));

         for i in  1..cnt loop
          IF (VALIDATE_CONVERSION(nci_11179.getWord(v_str, i, cnt) AS NUMBER) = 1) THEN
                        v_item_id := nci_11179.getWord(v_str, i, cnt);
                    v_cnt_valid_fmt := v_cnt_valid_fmt + 1;

        -- Only add if item is of the right type and not currently in collection.
                select count(*) into v_temp from admin_item where item_id = v_item_id and currnt_ver_ind = 1 and admin_item_typ_id = v_item_typ_id ;
                if (v_temp = 1) then
                        v_cnt_valid_type := v_cnt_valid_type + 1;
                        v_found := true;
                        for cur in (select * from admin_item where item_id = v_item_id and currnt_ver_ind = 1 and (item_id, ver_nr) not in
                        (select item_id, ver_nr from nci_dload_dtl where hdr_id = ihook.getColumnValue(row_ori,'HDR_ID'))) loop
                            ihook.setColumnValue(row, 'ITEM_ID', cur.item_id);
                            ihook.setColumnValue(row, 'VER_NR', cur.ver_nr);
                            ihook.setColumnValue(row,'CNTCT_SECU_ID', v_usr_id);
                            ihook.setColumnValue(row,'GUEST_USR_NM', 'NONE');
                            rows.extend;
                            rows (rows.last) := row;
                            v_found := false;
                            -- Add to user cart as well as per curator.
                            select count(*) into v_temp from nci_usr_cart where item_id  =cur.item_id and ver_nr = cur.ver_nr and cntct_secu_id = v_usr_id;
                              if (v_temp = 0) then
                                    rowscart.extend;
                                    rowscart (rowscart.last) := row;
                              end if;
                        end loop;
                        if (v_found = true) then  --- Duplcicate
                        v_dup_str := substr(v_dup_str || ' ' || nci_11179.getWord(v_str, i, cnt),1,50);
                        end if;
                else -- not the right type
                v_invalid_typ := substr(v_invalid_typ || ' ' || nci_11179.getWord(v_str, i, cnt),1,50);
                end if;
 else
    -- invalid format
  --  v_invalid_fmt := substr(v_invalid_fmt || ' ' || nci_11179.getWord(v_str, i, cnt),1,50);
        v_invalid_typ := substr(v_invalid_typ || ' ' || nci_11179.getWord(v_str, i, cnt),1,50);

 end if;
end loop;
        -- If Item needs to be added.
        if (rows.count > 0) then
            action := t_actionrowset(rows, 'Download Detail', 2,0,'insert');
            actions.extend;
            actions(actions.last) := action;
        end if;
            /*  If item not already in cart */
            if (rowscart.count  > 0) then
                action := t_actionrowset(rowscart, 'User Cart', 2,0,'insert');
                actions.extend;
                actions(actions.last) := action;
            end if;

        if (actions.count > 0) then
            hookoutput.actions := actions;
        end if;
  --      v_cnt_valid_fmt := cnt-v_cnt_valid_fmt;
  --      v_cnt_valid_type :=
        v_cnt_already :=  v_cnt_valid_type - nvl(rows.count,0) ;
         /*    hookoutput.message := 'Total Items: ' || cnt ||  ';    Valid format: ' || v_cnt_valid_fmt || ';    Valid Item type: ' || v_cnt_valid_type ||  ';     Already in Collection: ' || v_cnt_already || ';    Items added: ' || nvl(rows.count,0) ;
            if (v_invalid_fmt is not null) then
                hookoutput.message := hookoutput.message || ';             Invalid format sample: ' || v_invalid_fmt ;
            end if;
            if (v_invalid_typ is not null) then
                hookoutput.message := hookoutput.message || ';    Invalid type sample: ' || v_invalid_typ ;
            end if;
*/
             hookoutput.message := 'Total Items: ' || cnt ||  ';    Invalid Format/Type: ' || v_invalid_typ || ';     Duplicate: ' || v_dup_str || ';    Items added: ' || nvl(rows.count,0) ;

   end if;
V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
END;


procedure spAddComponentToDloadIDGuest (v_data_in in clob, v_data_out out clob, v_usr_id  IN varchar2)
AS
    hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();

    actions t_actions := t_actions();
    action t_actionRowset;
    row t_row;
    row_sel t_row;
    rows  t_rows;
    rowscart  t_rows;
    row_ori t_row;
    v_item_id  number;
    v_ver_nr number(4,2);
    v_temp integer;
    v_add integer :=0;
    i integer := 0;
    v_item_typ_id integer;
    v_found boolean;
    v_str varchar2(4000);
    cnt integer;
 forms t_forms;
  form1 t_form;
  v_cnt_valid_fmt integer;
  v_cnt_valid_type integer;
  v_cnt_already integer;
  v_invalid_fmt varchar2(50) := '';
  v_invalid_typ varchar2(100) := '';
  v_dup_str  varchar2(50) := '';
begin
    hookinput := ihook.gethookinput (v_data_in);
    hookoutput.invocationnumber  := hookinput.invocationnumber;
    hookoutput.originalrowset    := hookinput.originalrowset;

        row_ori := hookInput.originalRowset.rowset(1);
        -- 92 - FOrm, 93 - CDE
      -- Depending on the type of collection, show either Forms or CDE's
  if (ihook.getColumnValue(row_ori,'DLOAD_TYP_ID') = 92) then
        v_item_typ_id := 54;
        else v_item_typ_id := 4;
    end if;

    if (hookinput.invocationnumber = 0) then   -- First invocation
         forms                  := t_forms();
        form1                  := t_form('Add Item to Collection Guest (Hook)', 2,1);
        forms.extend;    forms(forms.last) := form1;
        hookoutput.forms := forms;
       	 hookOutput.question := getAddComponentCreateQuestionID;
	end if;

    if hookInput.invocationNumber = 1  then  -- Seconf invocation
       rows := t_rows();
       row := t_row();

        v_cnt_valid_fmt := 0;
        v_cnt_valid_type := 0;

        forms              := hookInput.forms;
        form1              := forms(1);
        row_sel := form1.rowset.rowset(1);

          --  raise_application_error(-20000, ihook.getColumnValue(rowform, 'HDR_ID'));
        if (validatePin(ihook.getColumnValue(row_ori, 'HDR_ID'), ihook.getColumnValue(row_sel, 'ITEM_ID')) = false) then
            raise_application_error(-20000, 'Invalid Pin. Please check and try again.');
            return;
        end if;

        v_str := trim(ihook.getColumnValue(row_sel, 'VM_DESC_TXT'));
             cnt := nci_11179.getwordcount(v_str);

        row := t_row();
        rows := t_rows();
        rowscart := t_rows();
        ihook.setColumnValue(row, 'HDR_ID', ihook.getColumnValue(row_ori,'HDR_ID'));

         for i in  1..cnt loop
          IF (VALIDATE_CONVERSION(nci_11179.getWord(v_str, i, cnt) AS NUMBER) = 1) THEN
                        v_item_id := nci_11179.getWord(v_str, i, cnt);
                    v_cnt_valid_fmt := v_cnt_valid_fmt + 1;

        -- Only add if item is of the right type and not currently in collection.
                select count(*) into v_temp from admin_item where item_id = v_item_id and currnt_ver_ind = 1 and admin_item_typ_id = v_item_typ_id ;
                if (v_temp = 1) then
                        v_cnt_valid_type := v_cnt_valid_type + 1;
                        v_found := true;
                        for cur in (select * from admin_item where item_id = v_item_id and currnt_ver_ind = 1 and (item_id, ver_nr) not in
                        (select item_id, ver_nr from nci_dload_dtl where hdr_id = ihook.getColumnValue(row_ori,'HDR_ID'))) loop
                            ihook.setColumnValue(row, 'ITEM_ID', cur.item_id);
                            ihook.setColumnValue(row, 'VER_NR', cur.ver_nr);
                            ihook.setColumnValue(row,'CNTCT_SECU_ID', v_usr_id);
                            ihook.setColumnValue(row,'GUEST_USR_NM', 'NONE');
                            rows.extend;
                            rows (rows.last) := row;
                            v_found := false;
                            -- Add to user cart as well as per curator.
          /*                  select count(*) into v_temp from nci_usr_cart where item_id  =cur.item_id and ver_nr = cur.ver_nr and cntct_secu_id = v_usr_id;
                              if (v_temp = 0) then
                                    rowscart.extend;
                                    rowscart (rowscart.last) := row;
                              end if;*/
                        end loop;
                        if (v_found = true) then  --- Duplcicate
                        v_dup_str := substr(v_dup_str || ' ' || nci_11179.getWord(v_str, i, cnt),1,50);
                        end if;
                else -- not the right type
                v_invalid_typ := substr(v_invalid_typ || ' ' || nci_11179.getWord(v_str, i, cnt),1,50);
                end if;
 else
    -- invalid format
  --  v_invalid_fmt := substr(v_invalid_fmt || ' ' || nci_11179.getWord(v_str, i, cnt),1,50);
        v_invalid_typ := substr(v_invalid_typ || ' ' || nci_11179.getWord(v_str, i, cnt),1,50);

 end if;
end loop;
        -- If Item needs to be added.
        if (rows.count > 0) then
            action := t_actionrowset(rows, 'Download Detail', 2,0,'insert');
            actions.extend;
            actions(actions.last) := action;
        end if;
            /*  If item not already in cart */
           /* if (rowscart.count  > 0) then
                action := t_actionrowset(rowscart, 'User Cart', 2,0,'insert');
                actions.extend;
                actions(actions.last) := action;
            end if;
*/
        if (actions.count > 0) then
            hookoutput.actions := actions;
        end if;
  --      v_cnt_valid_fmt := cnt-v_cnt_valid_fmt;
  --      v_cnt_valid_type :=
        v_cnt_already :=  v_cnt_valid_type - nvl(rows.count,0) ;
         /*    hookoutput.message := 'Total Items: ' || cnt ||  ';    Valid format: ' || v_cnt_valid_fmt || ';    Valid Item type: ' || v_cnt_valid_type ||  ';     Already in Collection: ' || v_cnt_already || ';    Items added: ' || nvl(rows.count,0) ;
            if (v_invalid_fmt is not null) then
                hookoutput.message := hookoutput.message || ';             Invalid format sample: ' || v_invalid_fmt ;
            end if;
            if (v_invalid_typ is not null) then
                hookoutput.message := hookoutput.message || ';    Invalid type sample: ' || v_invalid_typ ;
            end if;
*/
             hookoutput.message := 'Total Items: ' || cnt ||  ';    Invalid Format/Type: ' || v_invalid_typ || ';     Duplicate: ' || v_dup_str || ';    Items added: ' || nvl(rows.count,0) ;

   end if;
V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
END;

function getALSCreateQuestion (v_typ in integer) return t_question is
  question t_question;
  answer t_answer;
  answers t_answers;
begin
    ANSWERS                    := T_ANSWERS();
   -- raise_application_error(-20000, v_typ);
    ANSWER                     := T_ANSWER(v_typ, v_typ,  'Create');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;

    if (v_typ = 90) then
    QUESTION               := T_QUESTION('Create New RAVE ALS Collection', ANSWERS);
    else
    QUESTION               := T_QUESTION('Create New Collection', ANSWERS);

    end if;
return question;
end;

function getALSCreateForm (v_rowset1 in t_rowset, v_rowset2 in t_rowset, v_dload_typ in integer) return t_forms is
  forms t_forms;
  form1 t_form;
begin
    forms                  := t_forms();
    form1                  := t_form('Download Header (Hook)', 2,1);
    form1.rowset :=v_rowset1;
    forms.extend;    forms(forms.last) := form1;
    if (v_dload_typ = 90) then
    form1                  := t_form('ALS Specific', 2,1);

    form1.rowset :=v_rowset2;
    forms.extend;    forms(forms.last) := form1;
    end if;
  return forms;
end;

function getCollectionCreateFormGuest (v_rowset1 in t_rowset, v_rowset2 in t_rowset, v_dload_typ in integer) return t_forms is
  forms t_forms;
  form1 t_form;
begin
    forms                  := t_forms();
    form1                  := t_form('Download Header (Base Object)', 2,1);
    form1.rowset :=v_rowset1;
    forms.extend;    forms(forms.last) := form1;
    if (v_dload_typ = 90) then
    form1                  := t_form('ALS Specific', 2,1);

    form1.rowset :=v_rowset2;
    forms.extend;    forms(forms.last) := form1;
    end if;
  return forms;
end;

END;
/


DROP PACKAGE BODY ONEDATA_WA.NCI_DS;

CREATE OR REPLACE PACKAGE BODY ONEDATA_WA.nci_ds AS
c_long_nm_len  integer := 30;
c_nm_len integer := 255;
c_ver_suffix varchar2(5) := 'v1.00';
v_dflt_txt    varchar2(100) := 'Enter text or auto-generated.';

PROCEDURE            spDSRuleEnum
AS
    v_temp           INT;
    v_item_id        NUMBER;
    v_ver_nr         NUMBER (4, 2);
    v_entity      varchar2(255);
BEGIN



--delete from ncI_ds_rslt_dtl;
--commit;
delete from nci_ds_rslt;
commit;



--- Enumerated section

/*


for cur in (select * from nci_ds_hdr where (hdr_id)  in (select distinct hdr_id from nci_ds_dtl)) loop
-- Rule id 1:  Entity preferred name exact match

insert into nci_ds_rslt_dtl (hdr_id, item_id, ver_nr, perm_val_nm, rule_id, score, rule_desc)
select cur.hdr_id, de.item_id, de.ver_nr, 'NA', 1, 100, 'Preferred Name Exact Match' from   vw_de de where  upper(nvl(cur.entty_nm_usr, cur.entty_nm)) = upper(de.item_nm)
 and currnt_ver_ind = 1 and de.val_dom_typ_id = 17;
commit;

-- Rule id 2:  Entity alternate question text name exact match

insert into nci_ds_rslt_dtl (hdr_id, item_id, ver_nr, perm_val_nm, rule_id, score, rule_desc)
select distinct cur.hdr_id, r.item_id, r.ver_nr, 'NA', 2, 100, 'Question Text Exact Match' from ref r, obj_key ok, vw_de de  where upper(nvl(cur.entty_nm_usr, cur.entty_nm)) = upper(r.ref_nm)
 and
r.ref_typ_id = ok.obj_key_id and upper(obj_key_desc) like '%QUESTION%' and de.item_id = r.item_id and de.ver_nr = r.ver_nr and de.currnt_ver_ind = 1
and (cur.hdr_id,r.item_id, r.ver_nr) not in (select hdr_id, item_id, ver_nr from nci_ds_rslt_detl) and de.val_dom_typ_id = 17;
commit;



-- Rule id 3:  Entity alternate  name exact match

insert into nci_ds_rslt_dtl (hdr_id, item_id, ver_nr, perm_val_nm, rule_id, score, rule_desc)
select distinct cur.hdr_id, r.item_id, r.ver_nr, 'NA', 3, 100, 'Alternate Name Exact Match' from alt_nms r, vw_de de  where upper(nvl(cur.entty_nm_usr, cur.entty_nm)) = upper(r.nm_desc)
and de.item_id = r.item_id and de.ver_nr = r.ver_nr and de.currnt_ver_ind = 1 and de.val_dom_typ_id = 17
and (cur.hdr_id,r.item_id, r.ver_nr) not in (select hdr_id, item_id, ver_nr from nci_ds_rslt_detl);
commit;


-- Rule id 4; Only for enumerated, Like
insert into nci_ds_rslt_dtl (hdr_id, item_id, ver_nr, perm_val_nm, rule_id, score, rule_desc)
select cur.hdr_id, de.item_id, de.ver_nr, 'NA', 4, 100, 'Preferred Name Like Match' from vw_de  de where  upper(de.item_nm) like '%' || upper(nvl(cur.entty_nm_usr, cur.entty_nm))|| '%'
 and currnt_ver_ind = 1 and de.val_dom_typ_id = 17
and (cur.hdr_id, de.item_id, de.ver_nr) not in (select  hdr_id, item_id, ver_nr from nci_ds_rslt_detl) and de.val_dom_typ_id = 17;
commit;

*/

/*

-- Rule id 4; Only for enumerated, Like
insert into nci_ds_rslt_dtl (hdr_id, item_id, ver_nr, perm_val_nm, rule_id, score, rule_desc)
select cur.hdr_id, de.item_id, de.ver_nr, 'NA', 4, 100, 'Preferred Name Like Match' from vw_de  de where
 upper(nvl(cur.entty_nm_usr, cur.entty_nm)) like '%' || upper(de.item_nm) || '%'
 and currnt_ver_ind = 1 and de.val_dom_typ_id = 17
and (cur.hdr_id, de.item_id, de.ver_nr) not in (select  hdr_id, item_id, ver_nr from nci_ds_rslt_detl) and de.val_dom_typ_id = 17;
commit;
/*

insert into nci_ds_rslt_detl (hdr_id, item_id, ver_nr, perm_val_nm, rule_id, score, rule_desc)
select distinct cur.hdr_id, r.item_id, r.ver_nr, 'NA', 5, 100, 'Question Text Like Match' from ref r, obj_key ok, vw_de de  where (upper(r.ref_nm) like '%' || upper(nvl(cur.entty_nm_usr, cur.entty_nm))|| '%'
or upper(nvl(cur.entty_nm_usr, cur.entty_nm)) like '%' || upper(r.ref_nm) || '%')  and
r.ref_typ_id = ok.obj_key_id and upper(obj_key_desc) like '%QUESTION%' and r.ref_nm != '%' and de.item_id = r.item_id and de.ver_nr = r.ver_nr and de.currnt_ver_ind = 1
and (cur.hdr_id, de.item_id, de.ver_nr) not in (select  hdr_id, item_id, ver_nr from nci_ds_rslt_detl) and de.val_dom_typ_id = 17;
commit;



-- Rule id 6:  Entity alternate  name like match for non-enumerated

insert into nci_ds_rslt_detl (hdr_id, item_id, ver_nr, perm_val_nm, rule_id, score, rule_desc)
select distinct cur.hdr_id, r.item_id, r.ver_nr, 'NA', 6, 100, 'Alternate Name Like Match' from alt_nms r, vw_de de  where upper(cur.entty_nm) like  '%' || upper(r.nm_desc) || '%'
and de.item_id = r.item_id and de.ver_nr = r.ver_nr and de.currnt_ver_ind = 1 and de.val_dom_typ_id = 17
and (cur.hdr_id, de.item_id, de.ver_nr) not in (select  hdr_id, item_id, ver_nr from nci_ds_rslt_detl) and de.val_dom_typ_id = 17;
commit;
*/

--end loop;




for cur in (select hdr_id,count(*) cnt from nci_ds_dtl group by hdr_id) loop

insert into nci_ds_rslt ( HDR_ID,ITEM_ID,VER_NR, NUM_PV_IN_SRC, NUM_PV_MTCH)
select cur.hdr_id, de_item_id item_id, de_ver_nr ver_nr, cur.cnt, count(*)  from vw_nci_de_pv v, admin_item ai
where nvl(ai.currnt_ver_ind,0) = 1 and v.de_item_id = ai.item_id and v.de_ver_NR = ai.VER_NR
and (cur.hdr_id, de_item_id, de_ver_nr) in (Select hdr_id, item_id, ver_nr from nci_ds_rslt_dtl where hdr_id = cur.hdr_id)
and upper(v.perm_val_nm) in (select upper(perm_val_nm) from nci_ds_dtl where hdr_id =cur.hdr_id)
group by de_item_id,  de_ver_nr having count(*) = cur.cnt;
commit;

insert into nci_ds_rslt ( HDR_ID,ITEM_ID,VER_NR, NUM_PV_IN_SRC, NUM_PV_MTCH)
select cur.hdr_id, de_item_id item_id, de_ver_nr ver_nr,cur.cnt, count(*)  from vw_nci_de_pv v, admin_item ai
where nvl(ai.currnt_ver_ind,0) = 1 and v.de_item_id = ai.item_id and
v.de_ver_NR = ai.VER_NR and upper(V.ITEM_nm) in (select upper(perm_val_nm) from nci_ds_dtl where hdr_id =cur.hdr_id)
and (cur.hdr_id, de_item_id, de_ver_nr) in (Select hdr_id, item_id, ver_nr from nci_ds_rslt_dtl where hdr_id = cur.hdr_id)
group by de_item_id,
de_ver_nr having count(*) = cur.cnt
AND CUR.HDR_ID NOT IN (SELECT HDR_ID FROM NCI_DS_RSLT);
commit;


insert into nci_ds_rslt ( HDR_ID,ITEM_ID,VER_NR, NUM_PV_IN_SRC, NUM_PV_MTCH)
select cur.hdr_id, de_item_id item_id, de_ver_nr ver_nr,cur.cnt, count(*)  from vw_nci_de_pv v, admin_item ai
where nvl(ai.currnt_ver_ind,0) = 1 and v.de_item_id = ai.item_id and
v.de_ver_NR = ai.VER_NR and upper(v.perm_val_nm) in (select upper(perm_val_nm) from nci_ds_dtl where hdr_id =cur.hdr_id)
and (cur.hdr_id, de_item_id, de_ver_nr) in (Select hdr_id, item_id, ver_nr from nci_ds_rslt_dtl where hdr_id = cur.hdr_id)
group by de_item_id, de_ver_nr having count(*) >= cur.cnt*0.5
AND CUR.HDR_ID NOT IN (SELECT HDR_ID FROM NCI_DS_RSLT);
commit;

insert into nci_ds_rslt ( HDR_ID,ITEM_ID,VER_NR, NUM_PV_IN_SRC, NUM_PV_MTCH)
select distinct cur.hdr_id, de_item_id item_id, de_ver_nr ver_nr, cur.cnt, count(*)
from vw_nci_de_pv v, admin_item ai where nvl(ai.currnt_ver_ind,0) = 1 and v.de_item_id = ai.item_id and
v.de_ver_NR = ai.VER_NR and upper(V.ITEM_nm) in (select upper(perm_val_nm) from nci_ds_dtl where hdr_id =cur.hdr_id)
and (cur.hdr_id, de_item_id, de_ver_nr) in (Select hdr_id, item_id, ver_nr from nci_ds_rslt_dtl where hdr_id = cur.hdr_id)
group by de_item_id, de_ver_nr having count(*) > cur.cnt*0.5
AND CUR.HDR_ID NOT IN (SELECT HDR_ID FROM NCI_DS_RSLT);
commit;

/*
insert into nci_ds_rsult ( HDR_ID,ITEM_ID,VER_NR, NUM_PV_IN_SRC, NUM_PV_MTCH)
select cur.hdr_id, de_item_id item_id, de_ver_nr ver_nr, cur.cnt, count(*)  from vw_nci_de_pv v, admin_item ai where nvl(ai.currnt_ver_ind,0) = 1 and v.de_item_id = ai.item_id and
v.de_ver_NR = ai.VER_NR and upper(perm_val_nm) in (select upper(perm_val_nm) from nci_ds_dtl where hdr_id =cur.hdr_id) group by de_item_id,
de_ver_nr having count(*) = cur.cnt
AND CUR.HDR_ID NOT IN (SELECT HDR_ID FROM NCI_DS_RSULT);

commit;

insert into nci_ds_rsult ( HDR_ID,ITEM_ID,VER_NR, NUM_PV_IN_SRC, NUM_PV_MTCH)
select cur.hdr_id, de_item_id item_id, de_ver_nr ver_nr, cur.cnt, count(*)  from vw_nci_de_pv v, admin_item ai where nvl(ai.currnt_ver_ind,0) = 1 and v.de_item_id = ai.item_id and
v.de_ver_NR = ai.VER_NR and upper(V.ITEM_nm) in (select upper(perm_val_nm) from nci_ds_dtl where hdr_id =cur.hdr_id) group by de_item_id,
de_ver_nr having count(*) = cur.cnt
AND CUR.HDR_ID NOT IN (SELECT HDR_ID FROM NCI_DS_RSULT);
commit;

/*
insert into nci_ds_rsult ( HDR_ID,ITEM_ID,VER_NR, NUM_PV_IN_SRC, NUM_PV_MTCH)
select cur.hdr_id, de_item_id item_id, de_ver_nr ver_nr, cur.cnt, count(*)  from vw_nci_de_pv v, admin_item ai where nvl(ai.currnt_ver_ind,0) = 1 and v.de_item_id = ai.item_id and
v.de_ver_NR = ai.VER_NR and upper(perm_val_nm) in (select upper(perm_val_nm) from nci_ds_dtl where hdr_id =cur.hdr_id) group by de_item_id,
de_ver_nr having count(*) >= cur.cnt*0.75
AND CUR.HDR_ID NOT IN (SELECT HDR_ID FROM NCI_DS_RSULT);
commit;

insert into nci_ds_rsult ( HDR_ID,ITEM_ID,VER_NR, NUM_PV_IN_SRC, NUM_PV_MTCH)
select cur.hdr_id, de_item_id item_id, de_ver_nr ver_nr, cur.cnt, count(*)  from vw_nci_de_pv v, admin_item ai where nvl(ai.currnt_ver_ind,0) = 1 and v.de_item_id = ai.item_id and
v.de_ver_NR = ai.VER_NR and upper(V.ITEM_nm) in (select upper(perm_val_nm) from nci_ds_dtl where hdr_id =cur.hdr_id) group by de_item_id,
de_ver_nr having count(*) = cur.cnt*0.75
AND CUR.HDR_ID NOT IN (SELECT HDR_ID FROM NCI_DS_RSULT);
commit;
/* insert into nci_ds_rsult ( HDR_ID,ITEM_ID,VER_NR, NUM_PV_IN_SRC, NUM_PV_MTCH)
select cur.hdr_id, de_item_id item_id, de_ver_nr ver_nr, cur.cnt, count(*)  from vw_nci_de_pv where upper(item_nm) in (select upper(perm_val_nm) from nci_ds_dtl where hdr_id = cur.hdr_id) group by de_item_id,
de_ver_nr having count(*) >= cur.cnt/2
and ( de_item_id, de_ver_nr) not in (select  item_id,ver_nr from nci_ds_rsult where hdr_id = cur.hdr_id);
*/

commit;


end loop;


END;

PROCEDURE            spDSRuleNonEnum
AS
    v_temp           INT;
    v_item_id        NUMBER;
    v_ver_nr         NUMBER (4, 2);
    v_entity      varchar2(255);
BEGIN


--- Non enumerated section

-- Rule id 1:  Entity preferred name exact match

--for cur in (select * from nci_ds_hdr where (hdr_id) not in (select distinct hdr_id from nci_ds_dtl)) loop
--for cur in (select * from nci_ds_hdr where hdr_id = 1037) loop


delete from nci_ds_rslt;

commit;
for cur in (select * from nci_ds_hdr ) loop


insert into nci_ds_rslt (hdr_id, item_id, ver_nr,  rule_id, score, rule_desc)
select cur.hdr_id, de.item_id, de.ver_nr,  1, 100, 'Preferred Name Exact Match' from   vw_de de where upper(nvl(cur.entty_nm_usr, cur.entty_nm)) = upper(de.item_nm)
 and currnt_ver_ind = 1 and de.val_dom_typ_id = 18;
commit;

-- Rule id 2:  Entity alternate question text name exact match

insert into nci_ds_rslt (hdr_id, item_id, ver_nr,  rule_id, score, rule_desc)
select distinct cur.hdr_id, r.item_id, r.ver_nr,  2, 100, 'Question Text Exact Match' from ref r, obj_key ok, vw_de de  where upper(nvl(cur.entty_nm_usr, cur.entty_nm)) = upper(r.ref_nm)
and
r.ref_typ_id = ok.obj_key_id and upper(obj_key_desc) like '%QUESTION%' and de.item_id = r.item_id and de.ver_nr = r.ver_nr and de.currnt_ver_ind = 1
and (cur.hdr_id,r.item_id, r.ver_nr) not in (select hdr_id, item_id, ver_nr from nci_ds_rslt) and de.val_dom_typ_id = 18;
commit;



-- Rule id 3:  Entity alternate  name exact match

insert into nci_ds_rslt (hdr_id, item_id, ver_nr, rule_id, score, rule_desc)
select distinct cur.hdr_id, r.item_id, r.ver_nr, 3, 100, 'Alternate Name Exact Match' from alt_nms r, vw_de de where upper(nvl(cur.entty_nm_usr, cur.entty_nm)) = upper(r.nm_desc)
and de.item_id = r.item_id and de.ver_nr = r.ver_nr and de.currnt_ver_ind = 1 and de.val_dom_typ_id = 18
and (cur.hdr_id,r.item_id, r.ver_nr) not in (select hdr_id, item_id, ver_nr from nci_ds_rslt);
commit;


-- Rule id 4; Only for non-enumerated, Like
insert into nci_ds_rslt (hdr_id, item_id, ver_nr,  rule_id, score, rule_desc)
select distinct cur.hdr_id, de.item_id, de.ver_nr,  4, 100, 'Preferred Name Like Match' from vw_de  de where (upper(de.item_nm) like '%' || upper(nvl(cur.entty_nm_usr, cur.entty_nm)) || '%' or
upper(nvl(cur.entty_nm_usr, cur.entty_nm)) like '%' || upper(de.item_nm) || '%')
 and currnt_ver_ind = 1 and de.val_dom_typ_id = 18
 and (cur.hdr_id) not in (select distinct hdr_id from nci_ds_rslt);
commit;



-- Rule id 5:  Entity alternate question text name like match for non-enumerated

insert into nci_ds_rslt (hdr_id, item_id, ver_nr,  rule_id, score, rule_desc)
select distinct cur.hdr_id, r.item_id, r.ver_nr,  5, 100, 'Question Text Like Match' from ref r, obj_key ok, vw_de de
where (upper(r.ref_nm) like '%' || upper(nvl(cur.entty_nm_usr, cur.entty_nm)) || '%' or upper(nvl(cur.entty_nm_usr, cur.entty_nm)) like '%' || upper(r.ref_nm) || '%') and
r.ref_typ_id = ok.obj_key_id and upper(obj_key_desc) like '%QUESTION%' and r.ref_nm != '%' and de.item_id = r.item_id and de.ver_nr = r.ver_nr and de.currnt_ver_ind = 1
and (cur.hdr_id) not in (select distinct hdr_id from nci_ds_rslt) and de.val_dom_typ_id = 18;
commit;


-- Rule id 6:  Entity alternate  name like match for non-enumerated

insert into nci_ds_rslt (hdr_id, item_id, ver_nr, rule_id, score, rule_desc)
select distinct cur.hdr_id, r.item_id, r.ver_nr,  6, 100, 'Alternate Name Like Match' from alt_nms r, vw_de de
where (upper(r.nm_desc) like '%' || upper(nvl(cur.entty_nm_usr, cur.entty_nm)) || '%' or upper(nvl(cur.entty_nm_usr, cur.entty_nm)) like '%' ||  upper(r.nm_desc) || '%')
and de.item_id = r.item_id and de.ver_nr = r.ver_nr and de.currnt_ver_ind = 1 and de.val_dom_typ_id = 18
and (cur.hdr_id) not in (select distinct hdr_id from nci_ds_rslt);
commit;

end loop;


END;

procedure spDSRun ( v_data_in in clob, v_data_out out clob)

AS
    hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();

    actions t_actions := t_actions();
    action t_actionRowset;
    row t_row;
    rows  t_rows;
    row_ori t_row;
    v_val_dom_typ integer;
    v_ver_nr number(4,2);
    v_temp integer;
    v_hdr_id number;
    v_already integer :=0;
    i integer := 0;

begin
    hookinput := ihook.gethookinput (v_data_in);
    hookoutput.invocationnumber  := hookinput.invocationnumber;
    hookoutput.originalrowset    := hookinput.originalrowset;
   -- raise_application_error(-20000,v_user_id);

    delete from nci_ds_rslt_dtl;
    commit;
    
    rows := t_rows();
    for i in 1..hookinput.originalrowset.rowset.count loop  --- Iterate through all the selected rows
        row_ori := hookInput.originalRowset.rowset(i);
        v_hdr_id := ihook.getColumnValue(row_ori, 'HDR_ID');
        
        select count(*) into v_temp from nci_ds_dtl where hdr_id = v_hdr_id;
        
        if (v_temp = 0) then v_val_dom_typ := 18 ; else v_val_dom_typ := 17; end if;
        delete from nci_ds_rslt where hdr_id = v_hdr_id;
        commit;
if (v_temp = 0) then        
        for cur in (select * from nci_ds_hdr where hdr_id = v_hdr_id ) loop
            insert into nci_ds_rslt (hdr_id, item_id, ver_nr,  rule_id, score, rule_desc)
            select v_hdr_id, de.item_id, de.ver_nr,  1, 100, 'Preferred Name Exact Match' from   vw_de de where upper(nvl(cur.entty_nm_usr, cur.entty_nm)) = upper(de.item_nm)
             and currnt_ver_ind = 1
             and de.val_dom_typ_id = v_val_dom_typ;
            commit;
            
            -- Rule id 2:  Entity alternate question text name exact match
            
            insert into nci_ds_rslt (hdr_id, item_id, ver_nr,  rule_id, score, rule_desc)
            select distinct v_hdr_id, r.item_id, r.ver_nr,  2, 100, 'Question Text Exact Match' from ref r, obj_key ok, vw_de de  where upper(nvl(cur.entty_nm_usr, cur.entty_nm)) = upper(r.ref_nm)
            and
            r.ref_typ_id = ok.obj_key_id and upper(obj_key_desc) like '%QUESTION%' and de.item_id = r.item_id and de.ver_nr = r.ver_nr and de.currnt_ver_ind = 1
            and (v_hdr_id,r.item_id, r.ver_nr) not in (select hdr_id, item_id, ver_nr from nci_ds_rslt)
            and de.val_dom_typ_id = v_val_dom_typ;
            commit;

            
            
            -- Rule id 3:  Entity alternate  name exact match
            
            insert into nci_ds_rslt (hdr_id, item_id, ver_nr, rule_id, score, rule_desc)
            select distinct v_hdr_id, r.item_id, r.ver_nr, 3, 100, 'Alternate Name Exact Match' from alt_nms r, vw_de de where upper(nvl(cur.entty_nm_usr, cur.entty_nm)) = upper(r.nm_desc)
            and de.item_id = r.item_id and de.ver_nr = r.ver_nr and de.currnt_ver_ind = 1 and de.val_dom_typ_id = v_val_dom_typ
            and (v_hdr_id,r.item_id, r.ver_nr) not in (select hdr_id, item_id, ver_nr from nci_ds_rslt);
            commit;
            
            
            -- Non enumerated only
            
           -- Rule id 4; Only for non-enumerated, Like
                    insert into nci_ds_rslt (hdr_id, item_id, ver_nr,  rule_id, score, rule_desc)
                    select distinct v_hdr_id, de.item_id, de.ver_nr,  4, 100, 'Preferred Name Like Match' from vw_de  de where (upper(de.item_nm) like '%' || upper(nvl(cur.entty_nm_usr, cur.entty_nm)) || '%' or
                    upper(nvl(cur.entty_nm_usr, cur.entty_nm)) like '%' || upper(de.item_nm) || '%')
                     and currnt_ver_ind = 1 and de.val_dom_typ_id = 18
                     and (v_hdr_id) not in (select distinct hdr_id from nci_ds_rslt);
                    commit;
        
        
        
                    -- Rule id 5:  Entity alternate question text name like match for non-enumerated
                    
                    insert into nci_ds_rslt (hdr_id, item_id, ver_nr,  rule_id, score, rule_desc)
                    select distinct v_hdr_id, r.item_id, r.ver_nr,  5, 100, 'Question Text Like Match' from ref r, obj_key ok, vw_de de
                    where (upper(r.ref_nm) like '%' || upper(nvl(cur.entty_nm_usr, cur.entty_nm)) || '%' or upper(nvl(cur.entty_nm_usr, cur.entty_nm)) like '%' || upper(r.ref_nm) || '%') and
                    r.ref_typ_id = ok.obj_key_id and upper(obj_key_desc) like '%QUESTION%' and r.ref_nm != '%' and de.item_id = r.item_id and de.ver_nr = r.ver_nr and de.currnt_ver_ind = 1
                    and (v_hdr_id) not in (select distinct hdr_id from nci_ds_rslt) and de.val_dom_typ_id = 18;
                    commit;
                    
                    
                    -- Rule id 6:  Entity alternate  name like match for non-enumerated
                    
                    insert into nci_ds_rslt (hdr_id, item_id, ver_nr, rule_id, score, rule_desc)
                    select distinct v_hdr_id, r.item_id, r.ver_nr,  6, 100, 'Alternate Name Like Match' from alt_nms r, vw_de de
                    where (upper(r.nm_desc) like '%' || upper(nvl(cur.entty_nm_usr, cur.entty_nm)) || '%' or upper(nvl(cur.entty_nm_usr, cur.entty_nm)) like '%' ||  upper(r.nm_desc) || '%')
                    and de.item_id = r.item_id and de.ver_nr = r.ver_nr and de.currnt_ver_ind = 1 and de.val_dom_typ_id = 18
                    and (v_hdr_id) not in (select distinct hdr_id from nci_ds_rslt);
                    commit;
    
   
end loop;
end if;
if (v_temp > 0) then -- PV exists


for cur in (select h.* from nci_ds_hdr h where h.hdr_id = v_hdr_id ) loop

-- Rule id 1:  Entity preferred name exact match
delete from nci_ds_rslt_dtl where hdr_id = v_hdr_id;
commit;

insert into nci_ds_rslt_dtl (hdr_id, item_id, ver_nr, perm_val_nm, rule_id, score, rule_desc)
select cur.hdr_id, de.item_id, de.ver_nr, 'NA', 1, 100, 'Preferred Name Exact Match' from   vw_de de where  upper(nvl(cur.entty_nm_usr, cur.entty_nm)) = upper(de.item_nm)
 and currnt_ver_ind = 1 and de.val_dom_typ_id = 17;
--commit;

-- Rule id 2:  Entity alternate question text name exact match
insert into nci_ds_rslt_dtl (hdr_id, item_id, ver_nr, perm_val_nm, rule_id, score, rule_desc)
select distinct cur.hdr_id, r.item_id, r.ver_nr, 'NA', 2, 100, 'Question Text Exact Match' from ref r, obj_key ok, vw_de de  where upper(nvl(cur.entty_nm_usr, cur.entty_nm)) = upper(r.ref_nm)
 and
r.ref_typ_id = ok.obj_key_id and upper(obj_key_desc) like '%QUESTION%' and de.item_id = r.item_id and de.ver_nr = r.ver_nr and de.currnt_ver_ind = 1
and (cur.hdr_id,r.item_id, r.ver_nr) not in (select hdr_id, item_id, ver_nr from nci_ds_rslt_dtl) and de.val_dom_typ_id = 17;
--commit;


-- Rule id 3:  Entity alternate  name exact match
insert into nci_ds_rslt_dtl (hdr_id, item_id, ver_nr, perm_val_nm, rule_id, score, rule_desc)
select distinct cur.hdr_id, r.item_id, r.ver_nr, 'NA', 3, 100, 'Alternate Name Exact Match' from alt_nms r, vw_de de  where upper(nvl(cur.entty_nm_usr, cur.entty_nm)) = upper(r.nm_desc)
and de.item_id = r.item_id and de.ver_nr = r.ver_nr and de.currnt_ver_ind = 1 and de.val_dom_typ_id = 17
and (cur.hdr_id,r.item_id, r.ver_nr) not in (select hdr_id, item_id, ver_nr from nci_ds_rslt_dtl);
--commit;

-- Rule id 4; Only for enumerated, Like
insert into nci_ds_rslt_dtl (hdr_id, item_id, ver_nr, perm_val_nm, rule_id, score, rule_desc)
select cur.hdr_id, de.item_id, de.ver_nr, 'NA', 4, 100, 'Preferred Name Like Match' from vw_de  de where  upper(de.item_nm) like '%' || upper(nvl(cur.entty_nm_usr, cur.entty_nm))|| '%'
 and currnt_ver_ind = 1 and de.val_dom_typ_id = 17
and (cur.hdr_id, de.item_id, de.ver_nr) not in (select  hdr_id, item_id, ver_nr from nci_ds_rslt_dtl) and de.val_dom_typ_id = 17;
commit;
end loop;


for cur in (select hdr_id,count(*) cnt from nci_ds_dtl d where hdr_id = v_hdr_id  group by hdr_id) loop

insert into nci_ds_rslt ( HDR_ID,ITEM_ID,VER_NR, NUM_PV_IN_SRC, NUM_PV_MTCH)
select cur.hdr_id, de_item_id item_id, de_ver_nr ver_nr, cur.cnt, count(*)  from vw_nci_de_pv_lean v, admin_item ai
where nvl(ai.currnt_ver_ind,0) = 1 and v.de_item_id = ai.item_id and v.de_ver_NR = ai.VER_NR
and (cur.hdr_id, de_item_id, de_ver_nr) in (Select hdr_id, item_id, ver_nr from nci_ds_rslt_dtl where hdr_id = cur.hdr_id)
and upper(v.perm_val_nm) in (select upper(perm_val_nm) from nci_ds_dtl where hdr_id =cur.hdr_id)
group by de_item_id,  de_ver_nr having count(*) = cur.cnt;
--commit;

if  (sql%rowcount = 0) then
insert into nci_ds_rslt ( HDR_ID,ITEM_ID,VER_NR, NUM_PV_IN_SRC, NUM_PV_MTCH)
select cur.hdr_id, de_item_id item_id, de_ver_nr ver_nr,cur.cnt, count(*)  from vw_nci_de_pv_lean v, admin_item ai
where nvl(ai.currnt_ver_ind,0) = 1 and v.de_item_id = ai.item_id and
v.de_ver_NR = ai.VER_NR and upper(V.ITEM_nm) in (select upper(perm_val_nm) from nci_ds_dtl where hdr_id =cur.hdr_id)
and (cur.hdr_id, de_item_id, de_ver_nr) in (Select hdr_id, item_id, ver_nr from nci_ds_rslt_dtl where hdr_id = cur.hdr_id)
group by de_item_id,
de_ver_nr having count(*) = cur.cnt;
--AND CUR.HDR_ID NOT IN (SELECT HDR_ID FROM NCI_DS_RSLT);
--commit;
end if;

if  (sql%rowcount = 0) then
insert into nci_ds_rslt ( HDR_ID,ITEM_ID,VER_NR, NUM_PV_IN_SRC, NUM_PV_MTCH)
select cur.hdr_id, de_item_id item_id, de_ver_nr ver_nr,cur.cnt, count(*)  from vw_nci_de_pv_lean v, admin_item ai
where nvl(ai.currnt_ver_ind,0) = 1 and v.de_item_id = ai.item_id and
v.de_ver_NR = ai.VER_NR and upper(v.perm_val_nm) in (select upper(perm_val_nm) from nci_ds_dtl where hdr_id =cur.hdr_id)
and (cur.hdr_id, de_item_id, de_ver_nr) in (Select hdr_id, item_id, ver_nr from nci_ds_rslt_dtl where hdr_id = cur.hdr_id)
group by de_item_id, de_ver_nr having count(*) >= cur.cnt*0.5;
--AND CUR.HDR_ID NOT IN (SELECT HDR_ID FROM NCI_DS_RSLT);
--commit;
end if;

if  (sql%rowcount = 0) then
insert into nci_ds_rslt ( HDR_ID,ITEM_ID,VER_NR, NUM_PV_IN_SRC, NUM_PV_MTCH)
select distinct cur.hdr_id, de_item_id item_id, de_ver_nr ver_nr, cur.cnt, count(*)
from vw_nci_de_pv_lean v, admin_item ai where nvl(ai.currnt_ver_ind,0) = 1 and v.de_item_id = ai.item_id and
v.de_ver_NR = ai.VER_NR and upper(V.ITEM_nm) in (select upper(perm_val_nm) from nci_ds_dtl where hdr_id =cur.hdr_id)
and (cur.hdr_id, de_item_id, de_ver_nr) in (Select hdr_id, item_id, ver_nr from nci_ds_rslt_dtl where hdr_id = cur.hdr_id)
group by de_item_id, de_ver_nr having count(*) > cur.cnt*0.5;
--AND CUR.HDR_ID NOT IN (SELECT HDR_ID FROM NCI_DS_RSLT);
--commit;
end if;
commit;
     end loop; 
end if;
  update nci_ds_hdr set NUM_CDE_MTCH = (select count(*) from nci_ds_rslt where hdr_id = v_hdr_id),
  NUM_PV = v_temp
  where hdr_id = v_hdr_id;
  end loop;
  commit;
    V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
     
END;


END;
/


DROP PACKAGE BODY ONEDATA_WA.NCI_FORM_MGMT;

CREATE OR REPLACE PACKAGE BODY ONEDATA_WA.nci_form_mgmt AS
c_ver_suffix varchar2(5) := 'v1.00';
v_dflt_txt    varchar2(100) := 'Enter text or auto-generated.';


function isUserAuth(v_frm_item_id in number, v_frm_ver_nr in number,v_user_id in varchar2) return boolean  iS
v_auth boolean := false;
v_temp integer;
begin
select count(*) into v_temp from  onedata_md.vw_usr_row_filter  v, admin_item ai
        where ( ( v.CNTXT_ITEM_ID = ai.CNTXT_ITEM_ID and v.cntxt_VER_NR  = ai.CNTXT_VER_NR) or v.CNTXT_ITEM_ID = 100) and upper(v.USR_ID) = upper(v_user_id) and v.ACTION_TYP = 'I'
        and ai.item_id =v_frm_item_id and ai.ver_nr = v_frm_ver_nr;
if (v_temp = 0) then return false; else return true; end if;
end;


function getReorderForm  return t_forms is
  forms t_forms;
  form1 t_form;
begin

        forms                  := t_forms();
        form1                  := t_form('Display Order Change', 2,1);
        forms.extend;
        forms(forms.last) := form1;
  return forms;
end;


function getReorderQuestion (v_cur_disp_ord in integer)  return t_question is

  question t_question;
  answer t_answer;
  answers t_answers;
begin

        ANSWERS                    := T_ANSWERS();
        ANSWER                     := T_ANSWER(1, 1, 'Change Display Order' );
        ANSWERS.EXTEND;
        ANSWERS(ANSWERS.LAST) := ANSWER;
        QUESTION               := T_QUESTION('Current Display Order is: ' || v_cur_disp_ord , ANSWERS);


return question;
end;

Procedure spAddQuestionID (v_data_in in clob, v_data_out out clob, v_usr_id  IN varchar2)
AS
    hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();

    actions t_actions := t_actions();
    action t_actionRowset;
    row t_row;
    row_sel t_row;
    rows  t_rows;
    rowscart  t_rows;
    rowsrep  t_rows;
    rowsvv  t_rows;

    row_ori t_row;
    v_item_id  number;
    v_ver_nr number(4,2);
    v_temp integer;
    v_add integer :=0;
    i integer := 0;
    v_item_typ_id integer;
    v_found boolean;
    v_str varchar2(4000);
    v_disp_ord integer;
    v_vvid number;
    cnt integer;
    rep integer;
    v_id number;
    j integer;
 forms t_forms;
  form1 t_form;
  v_cnt_valid_fmt integer;
  v_cnt_valid_type integer;
  v_cnt_already integer;
  v_invalid_fmt varchar2(50) := '';
  v_invalid_typ varchar2(100) := '';
  v_dup_str  varchar2(50) := '';
begin
    hookinput := ihook.gethookinput (v_data_in);
    hookoutput.invocationnumber  := hookinput.invocationnumber;
    hookoutput.originalrowset    := hookinput.originalrowset;

        row_ori := hookInput.originalRowset.rowset(1);
        -- 92 - FOrm, 93 - CDE
      -- Depending on the type of collection, show either Forms or CDE's

     v_item_typ_id := 4;

    if (hookinput.invocationnumber = 0) then   -- First invocation
         forms                  := t_forms();
        form1                  := t_form('Add Item to Collection (Hook)', 2,1);
        forms.extend;    forms(forms.last) := form1;
        hookoutput.forms := forms;
       	 hookOutput.question := nci_dload.getAddComponentCreateQuestion;
	end if;

    if hookInput.invocationNumber = 1  then  -- Second invocation
          v_cnt_valid_fmt := 0;
            v_cnt_valid_type := 0;

            forms              := hookInput.forms;
            form1              := forms(1);
            row_sel := form1.rowset.rowset(1);
            v_str := trim(ihook.getColumnValue(row_sel, 'VM_DESC_TXT'));
            cnt := nci_11179.getwordcount(v_str);

     --       Display order and repetitions
            select nvl(max(disp_ord)+1,0) into v_disp_ord from NCI_ADMIN_ITEM_REL_ALT_KEY where P_ITEM_ID =ihook.getColumnValue(row_ori,'C_ITEM_ID')  and
              P_ITEM_VER_NR = ihook.getColumnValue(row_ori,'C_ITEM_VER_NR') and rel_typ_id = 63;
                            rep := ihook.getColumnValue(row_ori, 'REP_NO');
            rows := t_rows();
            rowsvv := t_rows();
            rowsrep := t_rows();
            rowscart := t_rows();

            for i in  1..cnt loop
                  IF (VALIDATE_CONVERSION(nci_11179.getWord(v_str, i, cnt) AS NUMBER) = 1) THEN
                            v_item_id := nci_11179.getWord(v_str, i, cnt);
                            v_cnt_valid_fmt := v_cnt_valid_fmt + 1;

                    -- Only add if item is of the right type and not currently in collection.
                           select count(*) into v_temp from admin_item where item_id = v_item_id and currnt_ver_ind = 1 and admin_item_typ_id = v_item_typ_id ;
                            if (v_temp = 1) then
                                    v_cnt_valid_type := v_cnt_valid_type + 1;
                                    v_found := true;

                                    for cur in (select ai.item_id, ai.ver_nr, ai.cntxt_item_id, ai.cntxt_ver_nr, item_long_nm item_long_nm, de.pref_quest_txt QUEST_TEXT, item_nm
                                    from admin_item ai, de where
                                    ai.item_id =v_item_id and ai.currnt_ver_ind = 1 and ai.item_id = de.item_id  and ai.ver_nr = de.ver_nr)  loop

                                            row := t_row();

                                            v_id := nci_11179.getItemId;
                                            ihook.setColumnValue (row, 'NCI_PUB_ID', v_id);
                                            ihook.setColumnValue (row, 'NCI_VER_NR', 1);
                                            ihook.setColumnValue (row, 'P_ITEM_ID', ihook.getColumnValue(row_ori,'C_ITEM_ID'));
                                            ihook.setColumnValue (row, 'P_ITEM_VER_NR', ihook.getColumnValue(row_ori,'C_ITEM_VER_NR'));
                                            ihook.setColumnValue (row, 'C_ITEM_ID', cur.item_id);
                                            ihook.setColumnValue (row, 'C_ITEM_VER_NR', cur.ver_nr);
                                            ihook.setColumnValue (row, 'CNTXT_CS_ITEM_ID', cur.cntxt_item_id);
                                            ihook.setColumnValue (row, 'CNTXT_CS_VER_NR', cur.cntxt_ver_nr);
                                            ihook.setColumnValue (row, 'ITEM_LONG_NM', cur.QUEST_TEXT );
                                             ihook.setColumnValue (row, 'ITEM_NM', cur.ITEM_LONG_NM );

                                            ihook.setColumnValue (row, 'REL_TYP_ID', 63);
                                            ihook.setColumnValue (row, 'DISP_ORD', v_disp_ord);
                                            v_disp_ord := v_disp_ord + 1;
                                            v_found := false;
                                            rows.extend;
                                            rows(rows.last) := row;


                                            if nvl(rep,0) > 0 then
                                                spAddQuestionRepNew (rep, v_id, rowsrep);
                                            end if;
                                            j := 0;

                                            for cur1 in (select * from  VW_NCI_DE_PV where de_item_id = cur.item_id and de_ver_nr = cur.ver_nr order by PERM_VAL_NM) loop
                                                      row := t_row();
                                                    ihook.setColumnValue (row, 'Q_PUB_ID', v_id);
                                                    ihook.setColumnValue (row, 'Q_VER_NR', 1);
                                                    ihook.setColumnValue (row, 'VM_NM', cur1.item_nm);
                                                    ihook.setColumnValue (row, 'VM_LNM', cur1.item_long_nm);
                                                    ihook.setColumnValue (row, 'VM_DEF', cur1.item_desc);
                                                    ihook.setColumnValue (row, 'VALUE', cur1.perm_val_nm);
                                                    ihook.setColumnValue (row, 'MEAN_TXT', cur1.item_nm);
                                                    ihook.setColumnValue (row, 'DESC_TXT', substr(cur1.item_desc,1,2000));
                                                    ihook.setColumnValue (row, 'VAL_MEAN_ITEM_ID', cur1.NCI_VAL_MEAN_ITEM_ID);
                                                    ihook.setColumnValue (row, 'VAL_MEAN_VER_NR', cur1.NCI_VAL_MEAN_VER_NR);
                                                    ihook.setColumnValue (row, 'CNTCT_SECU_ID', v_usr_id);
                                                    ihook.setColumnValue (row, 'GUEST_USR_NM', 'NONE');
                                                    ihook.setColumnValue (row, 'ITEM_ID', cur.item_id);
                                                           ihook.setColumnValue (row, 'VER_NR', cur.ver_nr);
                                          v_vvid := nci_11179.getItemId;
                                                    ihook.setColumnValue (row, 'NCI_PUB_ID', v_vvid);
                                                    ihook.setColumnValue (row, 'NCI_VER_NR', 1);
                                                    ihook.setColumnValue (row, 'DISP_ORD', j);
                                                     rowsvv.extend;
                                                    rowsvv(rowsvv.last) := row;
                                                    j := j+ 1;
                                            end loop;
                                             -- Add to user cart as well as per curator.
                                            select count(*) into v_temp from nci_usr_cart where item_id  =cur.item_id and ver_nr = cur.ver_nr and cntct_secu_id = v_usr_id;
                                              if (v_temp = 0) then
                                                    rowscart.extend;
                                                    rowscart (rowscart.last) := row;
                                              end if;
                                     end loop;

                                    if (v_found = true) then  --- Duplcicate
                                        v_dup_str := substr(v_dup_str || ' ' || nci_11179.getWord(v_str, i, cnt),1,50);
                                    end if;
                            else -- not the right type
                                v_invalid_typ := substr(v_invalid_typ || ' ' || nci_11179.getWord(v_str, i, cnt),1,50);
                            end if;

            else  -- invalid format
                v_invalid_typ := substr(v_invalid_typ || ' ' || nci_11179.getWord(v_str, i, cnt),1,50);
            end if;
    end loop;

    --DESC_TXT
       -- raise_application_error(-20000, v_add);
            if (rows.count > 0) then
                            action := t_actionrowset(rows, 'Questions (Base Object)', 2,0,'insert');
                            actions.extend;
                            actions(actions.last) := action;
            end if;

        if (rowsvv.count > 0) then
        action := t_actionrowset(rowsvv, 'Question Valid Values (Hook)', 2,2,'insert');
        actions.extend;
        actions(actions.last) := action;
        end if;

           if (rowsrep.count > 0) then
            action             := t_actionrowset(rowsrep, 'Question Repetition', 2, 4,'insert');
                actions.extend;
                actions(actions.last) := action;
             end if;


                /*  If item not already in cart */
                if (rowscart.count  > 0) then
                    action := t_actionrowset(rowscart, 'User Cart', 2,0,'insert');
                    actions.extend;
                    actions(actions.last) := action;
                end if;

            if (actions.count > 0) then
                hookoutput.actions := actions;
            end if;
            v_cnt_already :=  v_cnt_valid_type - nvl(rows.count,0) ;
                 hookoutput.message := 'Total Items: ' || cnt ||  ';    Invalid Format/Type: ' || v_invalid_typ || ';      Items added: ' || nvl(rows.count,0) ;

   end if;  -- if second invocation
V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
 nci_util.debugHook('GENERAL',v_data_out);
END;

PROCEDURE spAddQuestVV
  (
    v_data_in IN CLOB,
    v_data_out OUT CLOB,
    v_usr_id in varchar2)
    AS
  hookInput t_hookInput;
  hookOutput t_hookOutput := t_hookOutput();
   actions t_actions := t_actions();
  action t_actionRowset;
  row t_row;
  rows  t_rows;
    row_ori t_row;
    row_sel t_row;
  action_rows       t_rows := t_rows();
  action_row		    t_row;
  rowset            t_rowset;
 question    t_question;
answer     t_answer;
answers     t_answers;
showrowset	t_showablerowset;
  v_disp_ord integer;
  v_frm_id number;
  v_frm_ver_nr number(4,2);
  v_add integer;
  i integer := 0;
  j integer;
  v_temp integer;
  rep integer;
  v_item_id number;
  column  t_column;
  msg varchar2(4000);
BEGIN
  hookinput                    := Ihook.gethookinput (v_data_in);
  hookoutput.invocationnumber  := hookinput.invocationnumber;
  hookoutput.originalrowset    := hookinput.originalrowset;

 row_ori :=  hookInput.originalRowset.rowset(1);
 rows := t_rows();


 select p_item_id, p_item_ver_nr into v_frm_id, v_frm_ver_nr from nci_admin_item_rel where
  c_item_id = ihook.getColumnValue(row_ori, 'P_ITEM_ID') and c_item_ver_nr = ihook.getColumnValue(row_ori, 'P_ITEM_VER_NR');
 if (nci_form_mgmt.isUserAuth(v_frm_id, v_frm_ver_nr, v_usr_id) = false) then
 raise_application_error(-20000,'You are not authorized to add any valid value on this form.');
 end if;

 if (ihook.getColumnValue(row_ori, 'C_ITEM_ID') is null) then
 raise_application_error(-20000,'No CDE attached to this question.');
 end if;

 if hookInput.invocationNumber = 0 then
    ANSWERS                    := T_ANSWERS();
    ANSWER                     := T_ANSWER(1, 1, 'Select');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
    QUESTION               := T_QUESTION('Question Valid Values', ANSWERS);
    HOOKOUTPUT.QUESTION    := QUESTION;

    rows := t_rows();
    for cur in (select upper(PERM_VAL_NM) PERM_VAL_NM from vw_nci_de_pv where de_item_id = ihook.getColumnValue(row_ori, 'C_ITEM_ID') and de_ver_nr = ihook.getColumnValue(row_ori, 'C_ITEM_VER_NR') minus
                select upper(VALUE) from nci_quest_valid_value where Q_PUB_ID = ihook.getColumnValue(row_ori, 'NCI_PUB_ID') and Q_VER_NR =ihook.getColumnValue(row_ori, 'NCI_VER_NR')) loop
                for cur1 in (select * from vw_nci_de_pv where upper(PERM_VAL_NM) = cur.PERM_VAL_NM and de_item_id = ihook.getColumnValue(row_ori, 'C_ITEM_ID') and de_ver_nr = ihook.getColumnValue(row_ori, 'C_ITEM_VER_NR')) loop
                     row := t_row();
                    iHook.setcolumnvalue (row, 'DE_ITEM_ID', cur1.DE_ITEM_ID);
                    iHook.setcolumnvalue (row, 'DE_VER_NR', cur1.DE_VER_NR);
                    iHook.setcolumnvalue (row, 'PERM_VAL_NM', cur1.PERM_VAL_NM);
                    rows.extend;
                    rows (rows.last) := row;

                end loop;
    end loop;


	--    end loop;

	   	 showrowset := t_showablerowset (rows, 'NCI DE Permissible Values', 2, 'multi');
       	 hookoutput.showrowset := showrowset;


  ELSE -- hook invocation = 1
       rows := t_rows();

    select max(nvl(disp_ord,0))+1 into j from nci_quest_valid_value where q_pub_id =    ihook.getColumnValue(row_ori, 'NCI_PUB_ID')
    and q_ver_nr = ihook.getColumnValue(row_ori, 'NCI_VER_NR');
 --   raise_application_error(-20000, j);
  for i in 1..hookinput.selectedRowset.rowset.count loop

        row_sel := hookinput.selectedRowset.rowset(i);
        row := t_row();
            ihook.setColumnValue (row, 'Q_PUB_ID',ihook.getColumnValue(row_ori, 'NCI_PUB_ID') );
                ihook.setColumnValue (row, 'Q_VER_NR', ihook.getColumnValue(row_ori, 'NCI_VER_NR'));
                ihook.setColumnValue (row, 'VM_NM', ihook.getColumnValue(row_sel, 'ITEM_NM'));
                ihook.setColumnValue (row, 'VM_LNM', ihook.getColumnValue(row_sel, 'ITEM_LONG_NM'));
                ihook.setColumnValue (row, 'VM_DEF', ihook.getColumnValue(row_sel, 'ITEM_DESC'));
                ihook.setColumnValue (row, 'VALUE', ihook.getColumnValue(row_sel, 'PERM_VAL_NM'));
                ihook.setColumnValue (row, 'MEAN_TXT', ihook.getColumnValue(row_sel, 'ITEM_NM'));
                ihook.setColumnValue (row, 'DESC_TXT', ihook.getColumnValue(row_sel, 'ITEM_DESC'));
                ihook.setColumnValue (row, 'VAL_MEAN_ITEM_ID', ihook.getColumnValue(row_sel, 'NCI_VAL_MEAN_ITEM_ID'));
                ihook.setColumnValue (row, 'VAL_MEAN_VER_NR', ihook.getColumnValue(row_sel, 'NCI_VAL_MEAN_VER_NR'));
                v_item_id := nci_11179.getItemId;
                ihook.setColumnValue (row, 'NCI_PUB_ID', v_item_id);
                ihook.setColumnValue (row, 'NCI_VER_NR', 1);
                ihook.setColumnValue (row, 'DISP_ORD', j);
            j := j + 1;
                    rows.extend;
                    rows (rows.last) := row;

   end loop;

 --raise_application_error(-20000, rows.count);
        if (rows.count > 0) then
        action             := t_actionrowset(rows, 'Question Valid Values (Hook)', 2, 0,'insert');
            actions.extend;
            actions(actions.last) := action;
           hookoutput.actions    := actions;
 end if;

     END IF;


  V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
 nci_util.debugHook('GENERAL',v_data_out);

END;

procedure spDeleteQuestVV  ( v_data_in IN CLOB, v_data_out OUT CLOB, v_usr_id  IN varchar2)
AS
    hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();
    actions t_actions := t_actions();
    action t_actionRowset;
    row t_row;
    rowrel t_row;
    row_sel t_row;
    rows  t_rows;
    row_ori t_row;
  action_rows       t_rows := t_rows();
  action_row		    t_row;
  rowset            t_rowset;

  rowform t_row;
v_found boolean;
  v_module_id integer;
  v_disp_ord integer;
  v_frm_id number;
  v_frm_ver_nr number(4,2);

BEGIN
  hookinput                    := Ihook.gethookinput (v_data_in);
  hookoutput.invocationnumber  := hookinput.invocationnumber;
  hookoutput.originalrowset    := hookinput.originalrowset;
 rows := t_rows();

 row_ori :=  hookInput.originalRowset.rowset(1);

 select frm_item_id, frm_ver_nr into v_frm_id, v_frm_ver_nr from vw_nci_module_de where
nci_pub_id = ihook.getColumnValue(row_ori, 'Q_PUB_ID') and nci_ver_nr = ihook.getColumnValue(row_ori, 'Q_VER_NR');
 if (nci_form_mgmt.isUserAuth(v_frm_id, v_frm_ver_nr, v_usr_id) = false) then
 raise_application_error(-20000,'You are not authorized to edit any valid value on this form.');
 end if;
for i in 1..hookinput.originalrowset.rowset.count loop
 row_ori :=  hookInput.originalRowset.rowset(i);



            rows.extend;
            rows(rows.last) := row_ori;
    end loop;
            action             := t_actionrowset(rows, 'Question Valid Values (Hook)', 2, 0,'delete');
            actions.extend;
            actions(actions.last) := action;

  action             := t_actionrowset(rows, 'Question Valid Values (Hook)', 2, 1,'purge');
            actions.extend;
            actions(actions.last) := action;

            hookoutput.actions    := actions;


  V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
END;



procedure spReorderModule  ( v_data_in IN CLOB, v_data_out OUT CLOB, v_user_id  IN varchar2)
AS
    hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();
    actions t_actions := t_actions();
    action t_actionRowset;
    row t_row;
    row_sel t_row;
    rows  t_rows;
    row_ori t_row;
  action_rows       t_rows := t_rows();
  action_row		    t_row;
  j integer;
 question    t_question;
answer     t_answer;
answers     t_answers;
 forms t_forms;
    form1 t_form;
    v_cur_disp_ord number;
    v_new_disp_ord number;
    v_max_disp_ord number;
     rowform t_row;
     v_sql  varchar2(4000);
BEGIN
  hookinput                    := Ihook.gethookinput (v_data_in);
  hookoutput.invocationnumber  := hookinput.invocationnumber;
  hookoutput.originalrowset    := hookinput.originalrowset;
  rows := t_rows();

 row_ori :=  hookInput.originalRowset.rowset(1);
 v_cur_disp_ord := ihook.getColumnValue(row_ori, 'DISP_ORD');

   if hookInput.invocationNumber = 0 then  -- If first invocation, prompt for version number

        hookOutput.forms := getReorderForm;
        hookoutput.question := getReorderQuestion(v_cur_disp_ord);
	elsif hookInput.invocationNumber = 1 then  -- Position specified...
            forms              := hookInput.forms;
            form1              := forms(1);
            rowform := form1.rowset.rowset(1);
            v_new_disp_ord := ihook.getColumnValue(rowform,'ITEM_ID');

            select least(max(disp_ord), count(disp_ord)-1)  into v_max_disp_ord from nci_admin_item_rel where rel_typ_id = 61 and p_item_id = ihook.getColumnValue(row_ori, 'P_ITEM_ID')
            and p_item_ver_nr = ihook.getColumnValue(row_ori, 'P_ITEM_VER_NR') and nvl(fld_Delete,0) = 0;

            if (v_new_disp_ord < 0) then
                raise_application_error(-20000, 'Invalid Display Order.');
                return;
            end if;

            if (v_new_disp_ord > v_max_disp_ord) then
                v_new_disp_ord := v_max_disp_ord;
            end if;

 --  if current position is greater than new position

            rows := t_rows();

            if (v_cur_disp_ord > v_new_disp_ord) then
                j := v_new_disp_ord;
                for i in v_new_disp_ord..v_cur_disp_ord-1 loop
                    row := t_row();
                    v_sql := 'select * from NCI_ADMIN_ITEM_REL where nvl(fld_delete,0) = 0 and p_item_id = ' ||  ihook.getColumnValue(row_ori, 'P_ITEM_ID') || ' and p_item_ver_nr = ' ||  ihook.getColumnValue(row_ori, 'P_ITEM_VER_NR') || ' and disp_ord = ' || i ;
                    nci_11179.ReturnRow(v_sql, 'NCI_ADMIN_ITEM_REL', row);
                    if (ihook.getColumnValue(row, 'P_ITEM_ID') is not null) then
                        j := j+1;
                        ihook.setColumnValue(row, 'DISP_ORD', j);
                        rows.extend;                    rows(rows.last) := row;
                    end if;
                end loop;
            end if;
 -- if current position is less than new position

            if (v_cur_disp_ord < v_new_disp_ord) then
                j := v_cur_disp_ord + 1;
                for i in v_cur_disp_ord+1..v_new_disp_ord loop
                    row := t_row();
                    v_sql := 'select * from NCI_ADMIN_ITEM_REL where nvl(fld_delete,0) = 0 and p_item_id = ' ||  ihook.getColumnValue(row_ori, 'P_ITEM_ID') || ' and p_item_ver_nr = ' ||  ihook.getColumnValue(row_ori, 'P_ITEM_VER_NR') || ' and disp_ord = ' || i ;
                    nci_11179.ReturnRow(v_sql, 'NCI_ADMIN_ITEM_REL', row);
                    if (ihook.getColumnValue(row, 'P_ITEM_ID') is not null) then
                        ihook.setColumnValue(row, 'DISP_ORD', j-1);
                        j := j+1;
                        rows.extend;                    rows(rows.last) := row;
                    end if;
                end loop;
            end if;
     -- update current row
            row := t_row();
            v_sql := 'select * from NCI_ADMIN_ITEM_REL where nvl(fld_delete,0) = 0 and p_item_id = ' ||  ihook.getColumnValue(row_ori, 'P_ITEM_ID') || ' and p_item_ver_nr = ' ||  ihook.getColumnValue(row_ori, 'P_ITEM_VER_NR') || ' and disp_ord = ' || v_cur_disp_ord ;
            nci_11179.ReturnRow(v_sql, 'NCI_ADMIN_ITEM_REL', row);

            ihook.setColumnValue(row, 'DISP_ORD', v_new_disp_ord);
            rows.extend;            rows(rows.last) := row;

            action := t_actionRowset(rows, 'Generic AI Relationship', 2, 1000, 'update');
            actions.extend; actions(actions.last) := action;
            hookoutput.actions:= actions;
    end if;
     v_data_out := ihook.getHookOutput(hookOutput);
--    nci_util.debugHook('FORM',v_data_out);

END;



procedure spResetOrderModule  ( v_data_in IN CLOB, v_data_out OUT CLOB, v_user_id  IN varchar2)
AS
    hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();
    actions t_actions := t_actions();
    action t_actionRowset;
    row t_row;
    rows  t_rows;
    row_ori t_row;
    action_rows       t_rows := t_rows();
    action_row		    t_row;
    i integer;

     v_sql  varchar2(4000);
BEGIN
    hookinput                    := Ihook.gethookinput (v_data_in);
    hookoutput.invocationnumber  := hookinput.invocationnumber;
    hookoutput.originalrowset    := hookinput.originalrowset;
    row_ori :=  hookInput.originalRowset.rowset(1);

    rows := t_rows();

    i := 0;
    for cur in (select * from NCI_ADMIN_ITEM_REL where nvl(fld_delete,0) = 0 and p_item_id =   ihook.getColumnValue(row_ori, 'ITEM_ID') and p_item_ver_nr =
             ihook.getColumnValue(row_ori, 'VER_NR') and rel_typ_id = 61 order by disp_ord) loop
                if (i <> cur.disp_ord) then
                    row := t_row();
                    v_sql := 'select * from NCI_ADMIN_ITEM_REL where  p_item_id = ' ||  cur.p_item_id || ' and p_item_ver_nr = ' || cur.p_item_ver_nr || ' and disp_ord = ' || cur.disp_ord ;
                    nci_11179.ReturnRow(v_sql, 'NCI_ADMIN_ITEM_REL', row);
                    ihook.setColumnValue(row, 'DISP_ORD', i);
                    rows.extend;                    rows(rows.last) := row;
                end if;
                i := i+1;
    end loop;

    action := t_actionRowset(rows, 'Generic AI Relationship', 2, 1000, 'update');
    actions.extend; actions(actions.last) := action;
    hookoutput.actions:= actions;

    v_data_out := ihook.getHookOutput(hookOutput);
    --nci_util.debugHook('FORM',v_data_out);

END;


procedure spReorderQuest  ( v_data_in IN CLOB, v_data_out OUT CLOB, v_user_id  IN varchar2)
AS
    hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();
    actions t_actions := t_actions();
    action t_actionRowset;
    row t_row;
    row_sel t_row;
    rows  t_rows;
    row_ori t_row;
  action_rows       t_rows := t_rows();
  action_row		    t_row;
  j integer;
 forms t_forms;
    form1 t_form;
    v_cur_disp_ord number;
    v_new_disp_ord number;
    v_max_disp_ord number;
     rowform t_row;
     v_sql  varchar2(4000);
BEGIN
  hookinput                    := Ihook.gethookinput (v_data_in);
  hookoutput.invocationnumber  := hookinput.invocationnumber;
  hookoutput.originalrowset    := hookinput.originalrowset;
  rows := t_rows();

 row_ori :=  hookInput.originalRowset.rowset(1);
 v_cur_disp_ord := ihook.getColumnValue(row_ori, 'DISP_ORD');

   if hookInput.invocationNumber = 0 then  -- If first invocation, prompt for version number
              hookOutput.forms := getReorderForm;
        hookoutput.question := getReorderQuestion(v_cur_disp_ord);

	elsif hookInput.invocationNumber = 1 then  -- Position specified...
            forms              := hookInput.forms;
            form1              := forms(1);
            rowform := form1.rowset.rowset(1);
            v_new_disp_ord := ihook.getColumnValue(rowform,'ITEM_ID');

            select least(max(disp_ord), count(disp_ord)-1)  into v_max_disp_ord from nci_admin_item_rel_alt_key where rel_typ_id = 63 and p_item_id = ihook.getColumnValue(row_ori, 'P_ITEM_ID')
            and p_item_ver_nr = ihook.getColumnValue(row_ori, 'P_ITEM_VER_NR') and nvl(fld_Delete,0) = 0;

            if (v_new_disp_ord < 0) then
                raise_application_error(-20000, 'Invalid Display Order.');
                return;
            end if;

            if (v_new_disp_ord > v_max_disp_ord) then
                v_new_disp_ord := v_max_disp_ord;
            end if;

 --  if current position is greater than new position

            rows := t_rows();

            if (v_cur_disp_ord > v_new_disp_ord) then
                j := v_new_disp_ord;
                for i in v_new_disp_ord..v_cur_disp_ord-1 loop
                    row := t_row();
                    v_sql := 'select * from NCI_ADMIN_ITEM_REL_ALT_KEY where nvl(fld_delete,0) = 0 and p_item_id = ' ||  ihook.getColumnValue(row_ori, 'P_ITEM_ID') || ' and p_item_ver_nr = ' ||  ihook.getColumnValue(row_ori, 'P_ITEM_VER_NR') || ' and disp_ord = ' || i ;
                    nci_11179.ReturnRow(v_sql, 'NCI_ADMIN_ITEM_REL_ALT_KEY', row);
                    if (ihook.getColumnValue(row, 'P_ITEM_ID') is not null) then
                        j := j+1;
                        ihook.setColumnValue(row, 'DISP_ORD', j);
                        rows.extend;                    rows(rows.last) := row;
                    end if;
                end loop;
            end if;
 -- if current position is less than new position

            if (v_cur_disp_ord < v_new_disp_ord) then
                j := v_cur_disp_ord + 1;
                for i in v_cur_disp_ord+1..v_new_disp_ord loop
                    row := t_row();
                    v_sql := 'select * from NCI_ADMIN_ITEM_REL_ALT_KEY where nvl(fld_delete,0) = 0 and p_item_id = ' ||  ihook.getColumnValue(row_ori, 'P_ITEM_ID') || ' and p_item_ver_nr = ' ||  ihook.getColumnValue(row_ori, 'P_ITEM_VER_NR') || ' and disp_ord = ' || i ;
                    nci_11179.ReturnRow(v_sql, 'NCI_ADMIN_ITEM_REL_ALT_KEY', row);
                    if (ihook.getColumnValue(row, 'P_ITEM_ID') is not null) then
                        ihook.setColumnValue(row, 'DISP_ORD', j-1);
                        j := j+1;
                        rows.extend;                    rows(rows.last) := row;
                    end if;
                end loop;
            end if;
     -- update current row
            row := t_row();
            v_sql := 'select * from NCI_ADMIN_ITEM_REL_ALT_KEY where nvl(fld_delete,0) = 0 and p_item_id = ' ||  ihook.getColumnValue(row_ori, 'P_ITEM_ID') || ' and p_item_ver_nr = ' ||  ihook.getColumnValue(row_ori, 'P_ITEM_VER_NR') || ' and disp_ord = ' || v_cur_disp_ord ;
            nci_11179.ReturnRow(v_sql, 'NCI_ADMIN_ITEM_REL_ALT_KEY', row);

            ihook.setColumnValue(row, 'DISP_ORD', v_new_disp_ord);
            rows.extend;            rows(rows.last) := row;

            action := t_actionRowset(rows, 'Questions (Base Object)', 2, 1000, 'update');
            actions.extend; actions(actions.last) := action;
            hookoutput.actions:= actions;
    end if;
     v_data_out := ihook.getHookOutput(hookOutput);
--    nci_util.debugHook('FORM',v_data_out);

END;

procedure spResetOrderQuest  ( v_data_in IN CLOB, v_data_out OUT CLOB, v_user_id  IN varchar2)
AS
    hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();
    actions t_actions := t_actions();
    action t_actionRowset;
    row t_row;
    rows  t_rows;
    row_ori t_row;
    action_rows       t_rows := t_rows();
    action_row		    t_row;
    i integer;

     v_sql  varchar2(4000);
BEGIN
    hookinput                    := Ihook.gethookinput (v_data_in);
    hookoutput.invocationnumber  := hookinput.invocationnumber;
    hookoutput.originalrowset    := hookinput.originalrowset;
    row_ori :=  hookInput.originalRowset.rowset(1);

    rows := t_rows();

    i := 0;
    for cur in (select * from NCI_ADMIN_ITEM_REL_ALT_KEY where nvl(fld_delete,0) = 0 and p_item_id =   ihook.getColumnValue(row_ori, 'C_ITEM_ID') and p_item_ver_nr =
             ihook.getColumnValue(row_ori, 'C_ITEM_VER_NR') and rel_typ_id = 63 order by disp_ord) loop
                if (i <> cur.disp_ord) then
                    row := t_row();
                    v_sql := 'select * from NCI_ADMIN_ITEM_REL_ALT_KEY where  p_item_id = ' ||  cur.p_item_id || ' and p_item_ver_nr = ' || cur.p_item_ver_nr || ' and disp_ord = ' || cur.disp_ord ;
                    nci_11179.ReturnRow(v_sql, 'NCI_ADMIN_ITEM_REL_ALT_KEY', row);
                    ihook.setColumnValue(row, 'DISP_ORD', i);
                    rows.extend;                    rows(rows.last) := row;
                end if;
                i := i+1;
    end loop;

    action := t_actionRowset(rows, 'Questions (Base Object)', 2, 1000, 'update');
    actions.extend; actions(actions.last) := action;
    hookoutput.actions:= actions;

    v_data_out := ihook.getHookOutput(hookOutput);
    --nci_util.debugHook('FORM',v_data_out);

END;


procedure spReorderQuestVV  ( v_data_in IN CLOB, v_data_out OUT CLOB, v_user_id  IN varchar2)
AS
    hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();
    actions t_actions := t_actions();
    action t_actionRowset;
    row t_row;
    row_sel t_row;
    rows  t_rows;
    row_ori t_row;
  action_rows       t_rows := t_rows();
  action_row		    t_row;
  j integer;
 question    t_question;
answer     t_answer;
answers     t_answers;
 forms t_forms;
    form1 t_form;
    v_cur_disp_ord number;
    v_new_disp_ord number;
    v_max_disp_ord number;
     rowform t_row;
     v_sql  varchar2(4000);
BEGIN
  hookinput                    := Ihook.gethookinput (v_data_in);
  hookoutput.invocationnumber  := hookinput.invocationnumber;
  hookoutput.originalrowset    := hookinput.originalrowset;
  rows := t_rows();

 row_ori :=  hookInput.originalRowset.rowset(1);
 v_cur_disp_ord := ihook.getColumnValue(row_ori, 'DISP_ORD');

   if hookInput.invocationNumber = 0 then  -- If first invocation, prompt for version number
             hookOutput.forms := getReorderForm;
        hookoutput.question := getReorderQuestion(v_cur_disp_ord);

	elsif hookInput.invocationNumber = 1 then  -- Position specified...
            forms              := hookInput.forms;
            form1              := forms(1);
            rowform := form1.rowset.rowset(1);
            v_new_disp_ord := ihook.getColumnValue(rowform,'ITEM_ID');

            select least(max(disp_ord), count(disp_ord)-1)  into v_max_disp_ord from NCI_QUEST_VALID_VALUE where  q_pub_id = ihook.getColumnValue(row_ori, 'Q_PUB_ID')
            and q_ver_nr = ihook.getColumnValue(row_ori, 'Q_VER_NR') and nvl(fld_Delete,0) = 0;

            if (v_new_disp_ord < 0) then
                raise_application_error(-20000, 'Invalid Display Order.');
                return;
            end if;

            if (v_new_disp_ord > v_max_disp_ord) then
                v_new_disp_ord := v_max_disp_ord;
            end if;

 --  if current position is greater than new position

            rows := t_rows();

            if (v_cur_disp_ord > v_new_disp_ord) then
                j := v_new_disp_ord;
                for i in v_new_disp_ord..v_cur_disp_ord-1 loop
                    row := t_row();
                    v_sql := 'select * from NCI_QUEST_VALID_VALUE where nvl(fld_delete,0) = 0 and q_pub_id = ' ||  ihook.getColumnValue(row_ori, 'Q_PUB_ID') || ' and q_ver_nr = ' ||  ihook.getColumnValue(row_ori, 'Q_VER_NR') || ' and disp_ord = ' || i ;
                    nci_11179.ReturnRow(v_sql, 'NCI_QUEST_VALID_VALUE', row);
                    if (ihook.getColumnValue(row, 'NCI_PUB_ID') is not null) then
                        j := j+1;
                        ihook.setColumnValue(row, 'DISP_ORD', j);
                        rows.extend;                    rows(rows.last) := row;
                    end if;
                end loop;
            end if;
 -- if current position is less than new position

            if (v_cur_disp_ord < v_new_disp_ord) then
                j := v_cur_disp_ord + 1;
                for i in v_cur_disp_ord+1..v_new_disp_ord loop
                    row := t_row();
                    v_sql := 'select * from NCI_QUEST_VALID_VALUE where nvl(fld_delete,0) = 0 and q_pub_id = ' ||  ihook.getColumnValue(row_ori, 'Q_PUB_ID') || ' and q_ver_nr = ' ||  ihook.getColumnValue(row_ori, 'Q_VER_NR') || ' and disp_ord = ' || i ;
                    nci_11179.ReturnRow(v_sql, 'NCI_QUEST_VALID_VALUE', row);
                    if (ihook.getColumnValue(row, 'NCI_PUB_ID') is not null) then
                        ihook.setColumnValue(row, 'DISP_ORD', j-1);
                        j := j+1;
                        rows.extend;                    rows(rows.last) := row;
                    end if;
                end loop;
            end if;
     -- update current row
            row := t_row();
                    v_sql := 'select * from NCI_QUEST_VALID_VALUE where nvl(fld_delete,0) = 0 and q_pub_id = ' ||  ihook.getColumnValue(row_ori, 'Q_PUB_ID') || ' and q_ver_nr = ' ||  ihook.getColumnValue(row_ori, 'Q_VER_NR') || ' and disp_ord = ' || v_cur_disp_ord ;
                    nci_11179.ReturnRow(v_sql, 'NCI_QUEST_VALID_VALUE', row);

            ihook.setColumnValue(row, 'DISP_ORD', v_new_disp_ord);
            rows.extend;            rows(rows.last) := row;

            action := t_actionRowset(rows, 'Question Valid Values (Hook)', 2, 1000, 'update');
            actions.extend; actions(actions.last) := action;
            hookoutput.actions:= actions;
    end if;
     v_data_out := ihook.getHookOutput(hookOutput);
--    nci_util.debugHook('FORM',v_data_out);

END;



procedure spResetOrderQuestVV  ( v_data_in IN CLOB, v_data_out OUT CLOB, v_user_id  IN varchar2)
AS
    hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();
    actions t_actions := t_actions();
    action t_actionRowset;
    row t_row;
    rows  t_rows;
    row_ori t_row;
    action_rows       t_rows := t_rows();
    action_row		    t_row;
    i integer;

     v_sql  varchar2(4000);
BEGIN
    hookinput                    := Ihook.gethookinput (v_data_in);
    hookoutput.invocationnumber  := hookinput.invocationnumber;
    hookoutput.originalrowset    := hookinput.originalrowset;
    row_ori :=  hookInput.originalRowset.rowset(1);

    rows := t_rows();

    i := 0;
    for cur in (select * from NCI_QUEST_VALID_VALUE where nvl(fld_delete,0) = 0 and q_pub_id =   ihook.getColumnValue(row_ori, 'NCI_PUB_ID') and q_ver_nr =
             ihook.getColumnValue(row_ori, 'NCI_VER_NR')  order by disp_ord) loop
                if (i <> cur.disp_ord) then
                    row := t_row();
                    v_sql := 'select * from NCI_QUEST_VALID_VALUE where  NCI_pub_id = '||  cur.NCI_PUB_ID || 'and nci_ver_nr = ' ||   cur.nci_ver_nr ;
                    nci_11179.ReturnRow(v_sql, 'NCI_QUEST_VALID_VALUE', row);
                    ihook.setColumnValue(row, 'DISP_ORD', i);
                    rows.extend;                    rows(rows.last) := row;
                end if;
                i := i+1;
    end loop;

    action := t_actionRowset(rows, 'Question Valid Values (Hook)', 2, 1000, 'update');
    actions.extend; actions(actions.last) := action;
    hookoutput.actions:= actions;

    v_data_out := ihook.getHookOutput(hookOutput);
    nci_util.debugHook('FORM',v_data_out);

END;



PROCEDURE spAddForm  ( v_data_in IN CLOB,    v_data_out OUT CLOB)
AS
    hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();
    actions t_actions := t_actions();
    action t_actionRowset;
    row t_row;
    rowrel t_row;
    rows  t_rows;
    row_ori t_row;
    action_rows       t_rows := t_rows();
    action_row		    t_row;
    rowset            t_rowset;
    question    t_question;
    answer     t_answer;
    answers     t_answers;
    showrowset	t_showablerowset;
    forms t_forms;
    form1 t_form;
    rowform t_row;
    v_found boolean;
    v_form_id integer;
    i integer := 0;
BEGIN
    hookinput                    := Ihook.gethookinput (v_data_in);
    hookoutput.invocationnumber  := hookinput.invocationnumber;
    hookoutput.originalrowset    := hookinput.originalrowset;

    -- First invocation - show the Add Form
    if hookInput.invocationNumber = 0 then
        ANSWERS                    := T_ANSWERS();
        ANSWER                     := T_ANSWER(1, 1, 'Create Form');
        ANSWERS.EXTEND;
        ANSWERS(ANSWERS.LAST) := ANSWER;
        QUESTION               := T_QUESTION('Create New Form', ANSWERS);
        HOOKOUTPUT.QUESTION    := QUESTION;

        forms                  := t_forms();
        form1                  := t_form('Forms (Hook)', 2,1);  -- Forms (Hook) is a custom object for this purpose.
        action_row := t_row();

        -- Set the default workflow status and Form Type; attach to Add Form.

        ihook.setColumnValue(action_row, 'ADMIN_STUS_ID', 66);
         ihook.setColumnValue(action_row, 'REGSTR_STUS_ID', 9);
        ihook.setColumnValue(action_row, 'FORM_TYP_ID', 70);
        action_rows.extend; action_rows(action_rows.last) := action_row;
        rowset := t_rowset(action_rows, 'Form (Hook)', 1,'NCI_FORM');

        form1.rowset :=rowset;
        forms.extend;
        forms(forms.last) := form1;
        hookOutput.forms := forms;
  ELSE -- Second invocation
        forms              := hookInput.forms;
        form1              := forms(1);
        rowform := form1.rowset.rowset(1);

        v_form_id :=  nci_11179.getItemId;
        row := t_row();
        row := rowform;

        ihook.setColumnValue(row, 'ITEM_ID', v_form_id);
        ihook.setColumnValue(row, 'CURRNT_VER_IND', 1);
        ihook.setColumnValue(row, 'VER_NR', 1);
        ihook.setColumnValue(row, 'ADMIN_ITEM_TYP_ID', 54);
        ihook.setColumnValue(row, 'ITEM_LONG_NM', v_form_id || c_ver_suffix);

        rows:= t_rows();
        rows.extend;
        rows(rows.last) := row;

        -- Insert super-type
        action             := t_actionrowset(rows, 'Administered Item (No Sequence)', 2, 0,'insert');
        actions.extend;
        actions(actions.last) := action;
        -- Insert sub-type
        action             := t_actionrowset(rows, 'Form AI', 2, 1,'insert');
        actions.extend;
        actions(actions.last) := action;

        -- Insert form-protocol relationship if protocol specified
        if (ihook.getColumnValue(rowform,'P_ITEM_ID') > 0) then
            rows:= t_rows();
            rowrel := t_row();
            ihook.setColumnValue(rowrel, 'P_ITEM_ID', ihook.getColumnValue(rowform,'P_ITEM_ID'));
            ihook.setColumnValue(rowrel, 'P_ITEM_VER_NR', ihook.getColumnValue(rowform,'P_ITEM_VER_NR'));
            ihook.setColumnValue(rowrel, 'CNTXT_ITEM_ID', ihook.getColumnValue(rowform,'CNTXT_ITEM_ID'));
            ihook.setColumnValue(rowrel, 'CNTXT_VER_NR', ihook.getColumnValue(rowform,'CNTXT_VER_NR'));
            ihook.setColumnValue(rowrel, 'C_ITEM_ID', v_form_id);
            ihook.setColumnValue(rowrel, 'C_ITEM_VER_NR', 1);
            ihook.setColumnValue(rowrel, 'REL_TYP_ID', 60);

            rows.extend;
            rows(rows.last) := rowrel;
            action             := t_actionrowset(rows, 'Generic AI Relationship', 2, 2,'insert');
            actions.extend;
            actions(actions.last) := action;
        end if;
        hookoutput.actions    := actions;
        hookoutput.message := 'Form Created Successfully with ID ' || v_form_id;
    END IF;
  V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
END;


PROCEDURE spAddFormFromExisting  ( v_data_in IN CLOB,    v_data_out OUT CLOB)
AS
    hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();
    actions t_actions := t_actions();
    action t_actionRowset;
    row t_row;
    rowrel t_row;
    rows  t_rows;
    row_ori t_row;
    action_rows       t_rows := t_rows();
    action_row		    t_row;
    rowset            t_rowset;
    question    t_question;
    answer     t_answer;
    answers     t_answers;
    showrowset	t_showablerowset;
    forms t_forms;
    form1 t_form;
    rowform t_row;
    v_from_item_id number;
    v_from_Ver_nr number(4,2);
    v_found boolean;
    v_form_id integer;
    i integer := 0;
BEGIN
    hookinput                    := Ihook.gethookinput (v_data_in);
    hookoutput.invocationnumber  := hookinput.invocationnumber;
    hookoutput.originalrowset    := hookinput.originalrowset;
     row_ori :=  hookInput.originalRowset.rowset(1);
     v_from_item_id := ihook.getColumnValue(row_ori,'ITEM_ID');
        v_from_ver_nr := ihook.getColumnValue(row_ori,'VER_NR');

    -- First invocation - show the Add Form
    if hookInput.invocationNumber = 0 then
        ANSWERS                    := T_ANSWERS();
        ANSWER                     := T_ANSWER(1, 1, 'Create Form');
        ANSWERS.EXTEND;
        ANSWERS(ANSWERS.LAST) := ANSWER;
        QUESTION               := T_QUESTION('Create New Form', ANSWERS);
        HOOKOUTPUT.QUESTION    := QUESTION;

        forms                  := t_forms();
        form1                  := t_form('Forms (Hook From Existing)', 2,1);  -- Forms (Hook) is a custom object for this purpose.
        action_row := row_ori;
        nci_11179.spReturnSubtypeRow (v_from_item_id, v_from_ver_nr, 54, action_row);
         ihook.setColumnValue(action_row, 'ADMIN_STUS_ID', 66);
         ihook.setColumnValue(action_row, 'REGSTR_STUS_ID', 9);

        ihook.setColumnValue(action_row, 'FORM_TYP_ID', 70);
        action_rows.extend; action_rows(action_rows.last) := action_row;
        rowset := t_rowset(action_rows, 'Form (Hook)', 1,'NCI_FORM');

        form1.rowset :=rowset;
        forms.extend;
        forms(forms.last) := form1;
        hookOutput.forms := forms;
  ELSE -- Second invocation
        forms              := hookInput.forms;
        form1              := forms(1);
        rowform := form1.rowset.rowset(1);

        v_form_id :=  nci_11179.getItemId;
        row := t_row();
        row := rowform;

        ihook.setColumnValue(row, 'ITEM_ID', v_form_id);
        ihook.setColumnValue(row, 'CURRNT_VER_IND', 1);
        ihook.setColumnValue(row, 'VER_NR', 1);
        ihook.setColumnValue(row, 'ADMIN_ITEM_TYP_ID', 54);
        ihook.setColumnValue(row, 'ITEM_LONG_NM', v_form_id || c_ver_suffix);
        ihook.setColumnValue(row, 'ADMIN_STUS_ID', 66);
         ihook.setColumnValue(row, 'REGSTR_STUS_ID', 9);

        rows:= t_rows();
        rows.extend;
        rows(rows.last) := row;

        -- Insert super-type
        action             := t_actionrowset(rows, 'Administered Item (No Sequence)', 2, 0,'insert');
        actions.extend;
        actions(actions.last) := action;
        -- Insert sub-type
        action             := t_actionrowset(rows, 'Form AI', 2, 1,'insert');
        actions.extend;
        actions(actions.last) := action;

        -- Insert form-protocol relationship if protocol specified
        if (ihook.getColumnValue(rowform,'P_ITEM_ID') > 0) then
            rows:= t_rows();
            rowrel := t_row();
            ihook.setColumnValue(rowrel, 'P_ITEM_ID', ihook.getColumnValue(rowform,'P_ITEM_ID'));
            ihook.setColumnValue(rowrel, 'P_ITEM_VER_NR', ihook.getColumnValue(rowform,'P_ITEM_VER_NR'));
            ihook.setColumnValue(rowrel, 'CNTXT_ITEM_ID', ihook.getColumnValue(rowform,'CNTXT_ITEM_ID'));
            ihook.setColumnValue(rowrel, 'CNTXT_VER_NR', ihook.getColumnValue(rowform,'CNTXT_VER_NR'));
            ihook.setColumnValue(rowrel, 'C_ITEM_ID', v_form_id);
            ihook.setColumnValue(rowrel, 'C_ITEM_VER_NR', 1);
            ihook.setColumnValue(rowrel, 'REL_TYP_ID', 60);

            rows.extend;
            rows(rows.last) := rowrel;
            action             := t_actionrowset(rows, 'Generic AI Relationship', 2, 2,'insert');
            actions.extend;
            actions(actions.last) := action;
        end if;
         nci_11179.spCreateCommonChildrenNCI(actions, v_from_item_id,v_from_ver_nr, v_form_id, 1);
        --Copy all modules
        for cur2 in (select c_item_id, c_item_ver_nr, disp_ord from nci_admin_item_rel where p_item_id = v_from_item_id and p_item_ver_nr = v_from_ver_nr
     and nvl(fld_delete,0) = 0) loop
     nci_11179.spCopyModuleNCI (actions, cur2.c_item_id,cur2.c_item_ver_nr,    v_from_item_id, v_from_ver_nr,v_form_id, 1, cur2.disp_ord,'V');
    end loop;

-- Protocol
    action_rows := t_rows();

   for pro_cur in (select P_ITEM_ID, P_ITEM_VER_NR, C_ITEM_ID, C_ITEM_VER_NR, REL_TYP_ID from NCI_ADMIN_ITEM_REL where
        c_item_id = v_from_item_id and c_ITEM_ver_nr = v_from_ver_nr and rel_typ_id = 60 and nvl(fld_delete,0) = 0) loop
          --    raise_application_error(-20000,'Herer');

            row := t_row();
            ihook.setColumnValue(row, 'P_ITEM_ID', pro_cur.P_ITEM_ID);
          ihook.setColumnValue(row, 'P_ITEM_VER_NR', pro_cur.P_ITEM_VER_NR);
          ihook.setColumnValue(row, 'C_ITEM_ID', v_form_id);
          ihook.setColumnValue(row, 'REL_TYP_ID', pro_cur.rel_typ_id);
            ihook.setColumnValue(row, 'C_ITEM_VER_NR',1);

            action_rows.extend; action_rows(action_rows.last) := row;
        end loop;
      if (action_rows.count > 0) then
        action := t_actionRowset(action_rows, 'Protocol-Form Relationship (Form View)',2, 22, 'insert');
        actions.extend; actions(actions.last) := action;
        end if;


        hookoutput.actions    := actions;
        hookoutput.message := 'Form Created Successfully with ID ' || v_form_id;
    END IF;
  V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
END;

PROCEDURE spAddModule  (    v_data_in IN CLOB,    v_data_out OUT CLOB,    v_user_id in varchar2)
AS
  hookInput t_hookInput;
  hookOutput t_hookOutput := t_hookOutput();
   actions t_actions := t_actions();
  action t_actionRowset;
  row t_row;
  rowrel t_row;
  rows  t_rows;
    row_ori t_row;
  action_rows       t_rows := t_rows();
  action_row		    t_row;
  rowset            t_rowset;
 question    t_question;
answer     t_answer;
answers     t_answers;
showrowset	t_showablerowset;
  forms t_forms;
  form1 t_form;
  rowform t_row;
v_found boolean;
  v_module_id integer;
  v_disp_ord integer;
  v_add integer;
  i integer := 0;
  column  t_column;
  msg varchar2(4000);
BEGIN
  hookinput                    := Ihook.gethookinput (v_data_in);
  hookoutput.invocationnumber  := hookinput.invocationnumber;
  hookoutput.originalrowset    := hookinput.originalrowset;

 row_ori :=  hookInput.originalRowset.rowset(1);
 rows := t_rows();
 if (nci_form_mgmt.isUserAuth(ihook.getColumnValue(row_ori, 'ITEM_ID'), ihook.getColumnValue(row_ori,'VER_NR'), v_user_id) = false) then
 raise_application_error(-20000,'You are not authorized to add a module to this form.');
 end if;

 if hookInput.invocationNumber = 0 then
    ANSWERS                    := T_ANSWERS();
    ANSWER                     := T_ANSWER(1, 1, 'Create Module');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
    QUESTION               := T_QUESTION('Add New Module', ANSWERS);
    HOOKOUTPUT.QUESTION    := QUESTION;

    rows := t_rows();
    row := t_row();
        ihook.setColumnValue(row, 'P_ITEM_ID', ihook.getColumnValue(row_ori, 'ITEM_ID'));
        ihook.setColumnValue(row, 'P_ITEM_VER_NR', ihook.getColumnValue(row_ori, 'VER_NR'));
        ihook.setColumnValue(row, 'FORM_NM', ihook.getColumnValue(row_ori, 'ITEM_NM'));
        -- get default context from Form
        for cur in (select cntxt_item_id, cntxt_ver_nr from admin_item where item_id = ihook.getColumnValue(row_ori, 'ITEM_ID') and ver_nr = ihook.getColumnValue(row_ori, 'VER_NR')) loop
           ihook.setColumnValue(row, 'CNTXT_ITEM_ID', cur.CNTXT_ITEM_ID);
            ihook.setColumnValue(row, 'CNTXT_VER_NR', cur.CNTXT_VER_NR);
        end loop;
        ihook.setColumnValue(row, 'ADMIN_STUS_ID', 66);
        ihook.setColumnValue(row, 'REGSTR_STUS_ID', 9);
         ihook.setColumnValue(row, 'ITEM_LONG_NM', v_dflt_txt);

        rows.extend; rows(rows.last) := row;
        rowset := t_rowset(rows, 'Module (Hook)', 1,'NCI_ADMIN_ITEM_REL');

    forms                  := t_forms();
    form1                  := t_form('Modules (Hook)', 2,1);
    form1.rowset :=rowset;
    forms.extend;
    forms(forms.last) := form1;
    hookOutput.forms := forms;
 ELSE
    IF HOOKINPUT.ANSWERID = 1 THEN
        forms              := hookInput.forms;
        form1              := forms(1);

        rowform := form1.rowset.rowset(1);

        v_module_id :=  nci_11179.getItemId;
        row := rowform;


   -- raise_application_error(-20000, ihook.getColumnValue(rowform,'INSTR'));

             ihook.setColumnValue(row, 'ITEM_ID', v_module_id);
            ihook.setColumnValue(row, 'CURRNT_VER_IND', 1);
            ihook.setColumnValue(row, 'VER_NR',ihook.getColumnValue(row_ori,'VER_NR') );
            ihook.setColumnValue(row, 'ADMIN_ITEM_TYP_ID', 52);
            if ( ihook.getColumnValue(rowform,'ITEM_LONG_NM')= v_dflt_txt) then
                   ihook.setColumnValue(row, 'ITEM_LONG_NM', v_module_id ||  c_ver_suffix);
            else
                        ihook.setColumnValue(row, 'ITEM_LONG_NM', ihook.getColumnValue(rowform,'ITEM_LONG_NM'));

            end if;

            rows:= t_rows();
            rows.extend;
            rows(rows.last) := row;

            action             := t_actionrowset(rows, 'Administered Item (No Sequence)', 2, 0,'insert');
            actions.extend;
            actions(actions.last) := action;

            action             := t_actionrowset(rows, 'Module', 2, 0,'insert');
            actions.extend;
            actions(actions.last) := action;

            rows:= t_rows();
          select nvl(max(disp_ord)+ 1,0) into v_disp_ord from nci_admin_item_rel where p_item_id = ihook.getColumnValue(row_ori,'ITEM_ID') and p_item_ver_nr = ihook.getColumnValue(row_ori,'VER_NR');
      --   raise_application_error(-20000, v_disp_ord);

            rowrel := t_row();
            ihook.setColumnValue(rowrel, 'P_ITEM_ID', ihook.getColumnValue(row_ori,'ITEM_ID'));
            ihook.setColumnValue(rowrel, 'P_ITEM_VER_NR', ihook.getColumnValue(row_ori,'VER_NR'));
            ihook.setColumnValue(rowrel, 'C_ITEM_ID', v_module_id);
            ihook.setColumnValue(rowrel, 'C_ITEM_VER_NR', ihook.getColumnValue(row_ori,'VER_NR'));
            ihook.setColumnValue(rowrel, 'CNTXT_ITEM_ID',ihook.getColumnValue(rowform,'CNTXT_ITEM_ID'));
            ihook.setColumnValue(rowrel, 'CNTXT_VER_NR', ihook.getColumnValue(rowform,'CNTXT_VER_NR'));
            ihook.setColumnValue(rowrel, 'DISP_ORD', v_disp_ord);
            ihook.setColumnValue(rowrel, 'REL_TYP_ID', 61);
            ihook.setColumnValue(rowrel, 'REP_NO', ihook.getColumnValue(rowform,'REP_NO'));
            ihook.setColumnValue(rowrel, 'INSTR', ihook.getColumnValue(rowform,'INSTR'));

            rows.extend;
            rows(rows.last) := rowrel;
     -- raise_application_error(-20000,  ihook.getColumnValue(row_ori,'ITEM_ID'));
            action             := t_actionrowset(rows, 'Generic AI Relationship', 2, 2,'insert');
            actions.extend;
            actions(actions.last) := action;
    hookoutput.actions    := actions;
    hookoutput.message := 'Module Created Successfully with ID ' || v_module_id;

    END IF;
  END IF;

  V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
END;


PROCEDURE spAddSAModule  (    v_data_in IN CLOB,    v_data_out OUT CLOB,    v_user_id in varchar2)
AS
  hookInput t_hookInput;
  hookOutput t_hookOutput := t_hookOutput();
   actions t_actions := t_actions();
  action t_actionRowset;
  row t_row;
  rowrel t_row;
  rows  t_rows;
    row_ori t_row;
  action_rows       t_rows := t_rows();
  action_row		    t_row;
  rowset            t_rowset;
 question    t_question;
answer     t_answer;
answers     t_answers;
showrowset	t_showablerowset;
  forms t_forms;
  form1 t_form;
  rowform t_row;
v_found boolean;
  v_module_id integer;

  v_add integer;
  i integer := 0;
  column  t_column;
  msg varchar2(4000);
BEGIN
  hookinput                    := Ihook.gethookinput (v_data_in);
  hookoutput.invocationnumber  := hookinput.invocationnumber;
  hookoutput.originalrowset    := hookinput.originalrowset;

 if hookInput.invocationNumber = 0 then
    ANSWERS                    := T_ANSWERS();
    ANSWER                     := T_ANSWER(1, 1, 'Create Module');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
    QUESTION               := T_QUESTION('Add New Module', ANSWERS);
    HOOKOUTPUT.QUESTION    := QUESTION;

    rows := t_rows();
    row := t_row();
        ihook.setColumnValue(row, 'P_ITEM_ID',-1);
        ihook.setColumnValue(row, 'P_ITEM_VER_NR', 1);
        ihook.setColumnValue(row, 'FORM_NM', 'Not Applicable');
        ihook.setColumnValue(row, 'ITEM_LONG_NM', v_dflt_txt);
        ihook.setColumnValue(row, 'ADMIN_STUS_ID', 65);
        ihook.setColumnValue(row, 'REGSTR_STUS_ID', 9);
        rows.extend; rows(rows.last) := row;
        rowset := t_rowset(rows, 'Module (Hook)', 1,'NCI_ADMIN_ITEM_REL');

    forms                  := t_forms();
    form1                  := t_form('Modules (Hook)', 2,1);
    form1.rowset :=rowset;
    forms.extend;
    forms(forms.last) := form1;
    hookOutput.forms := forms;
 ELSE
    IF HOOKINPUT.ANSWERID = 1 THEN
        forms              := hookInput.forms;
        form1              := forms(1);

        rowform := form1.rowset.rowset(1);

        v_module_id :=  nci_11179.getItemId;
        row := rowform;


   -- raise_application_error(-20000, ihook.getColumnValue(rowform,'INSTR'));

           ihook.setColumnValue(row, 'ITEM_ID', v_module_id);
            ihook.setColumnValue(row, 'CURRNT_VER_IND', 1);
            ihook.setColumnValue(row, 'VER_NR',1 );
            ihook.setColumnValue(row, 'ADMIN_ITEM_TYP_ID', 52);
            if ( ihook.getColumnValue(rowform,'ITEM_LONG_NM')= v_dflt_txt) then
                   ihook.setColumnValue(row, 'ITEM_LONG_NM', v_module_id ||  c_ver_suffix);
            else
                        ihook.setColumnValue(row, 'ITEM_LONG_NM', ihook.getColumnValue(rowform,'ITEM_LONG_NM'));

            end if;

            rows:= t_rows();
            rows.extend;
            rows(rows.last) := row;

            action             := t_actionrowset(rows, 'Administered Item (No Sequence)', 2, 0,'insert');
            actions.extend;
            actions(actions.last) := action;

            rows:= t_rows();

            rowrel := t_row();
            ihook.setColumnValue(rowrel, 'P_ITEM_ID', v_module_id);
            ihook.setColumnValue(rowrel, 'P_ITEM_VER_NR', 1);
            ihook.setColumnValue(rowrel, 'C_ITEM_ID', v_module_id);
            ihook.setColumnValue(rowrel, 'C_ITEM_VER_NR', 1);
            ihook.setColumnValue(rowrel, 'CNTXT_ITEM_ID', ihook.getColumnValue(rowform, 'CNTXT_ITEM_ID'));
            ihook.setColumnValue(rowrel, 'CNTXT_VER_NR',  ihook.getColumnValue(rowform, 'CNTXT_VER_NR'));
            ihook.setColumnValue(rowrel, 'DISP_ORD', 0);
            ihook.setColumnValue(rowrel, 'REL_TYP_ID', 67);
            ihook.setColumnValue(rowrel, 'REP_NO', 0);
            ihook.setColumnValue(rowrel, 'INSTR', ihook.getColumnValue(rowform,'INSTR'));

            rows.extend;
            rows(rows.last) := rowrel;
     -- raise_application_error(-20000,  ihook.getColumnValue(row_ori,'ITEM_ID'));
            action             := t_actionrowset(rows, 'Generic AI Relationship', 2, 2,'insert');
            actions.extend;
            actions(actions.last) := action;
    hookoutput.actions    := actions;
    hookoutput.message := 'Module Created Successfully with ID ' || v_module_id;

    END IF;
  END IF;

  V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
    nci_util.debugHook('GENERAL',v_data_out);
END;

PROCEDURE spEditModule  (    v_data_in IN CLOB,    v_data_out OUT CLOB,    v_user_id in varchar2)
AS
  hookInput t_hookInput;
  hookOutput t_hookOutput := t_hookOutput();
   actions t_actions := t_actions();
  action t_actionRowset;
  row t_row;
  rowrel t_row;
  rows  t_rows;
    row_ori t_row;
  action_rows       t_rows := t_rows();
  action_row		    t_row;
  rowset            t_rowset;
 question    t_question;
answer     t_answer;
answers     t_answers;
showrowset	t_showablerowset;
  forms t_forms;
  form1 t_form;
  rowform t_row;
v_found boolean;
  v_module_id integer;
  v_disp_ord integer;
  v_add integer;
  i integer := 0;
  column  t_column;
  msg varchar2(4000);
BEGIN
  hookinput                    := Ihook.gethookinput (v_data_in);
  hookoutput.invocationnumber  := hookinput.invocationnumber;
  hookoutput.originalrowset    := hookinput.originalrowset;

 row_ori :=  hookInput.originalRowset.rowset(1);
 rows := t_rows();
 if (nci_form_mgmt.isUserAuth(ihook.getColumnValue(row_ori, 'P_ITEM_ID'), ihook.getColumnValue(row_ori,'P_ITEM_VER_NR'), v_user_id) = false) then
 raise_application_error(-20000,'You are not authorized to edit module to this form.');
 end if;

 if hookInput.invocationNumber = 0 then
    ANSWERS                    := T_ANSWERS();
    ANSWER                     := T_ANSWER(1, 1, 'Update');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
    QUESTION               := T_QUESTION('Edit Module', ANSWERS);
    HOOKOUTPUT.QUESTION    := QUESTION;
    rows := t_rows();
    row := row_ori;

    nci_11179.spReturnAIRow( ihook.getColumnValue(row_ori, 'C_ITEM_ID'),ihook.getColumnValue(row_ori, 'C_ITEM_VER_NR'), row);
  --   Form name
    for cur in (select item_nm from admin_item where item_id = ihook.getColumnValue(row_ori, 'P_ITEM_ID') and ver_nr = ihook.getColumnValue(row_ori, 'P_ITEM_VER_NR')) loop
  --  and  ihook.getColumnValue(row_ori, 'P_ITEM_ID') <>  ihook.getColumnValue(row_ori, 'C_ITEM_ID')) loop
     ihook.setColumnValue(row, 'FORM_NM', cur.item_nm);
     end loop;
       rows.extend; rows(rows.last) := row;
        rowset := t_rowset(rows, 'Modules (Hook)', 1,'ADMIN_ITEM');

--

    forms                  := t_forms();
    form1                  := t_form('Modules (Hook)', 2,1);
    form1.rowset :=rowset;
    forms.extend;
    forms(forms.last) := form1;
    hookOutput.forms := forms;
 ELSE
    IF HOOKINPUT.ANSWERID = 1 THEN
        forms              := hookInput.forms;
        form1              := forms(1);

        rowform := form1.rowset.rowset(1);

       row := t_row();
       -- Get original row
       nci_11179.spReturnAIRow( ihook.getColumnValue(row_ori, 'C_ITEM_ID'),ihook.getColumnValue(row_ori, 'C_ITEM_VER_NR'), row);
                        ihook.setColumnValue(row, 'ITEM_LONG_NM', ihook.getColumnValue(rowform,'ITEM_LONG_NM'));
                        ihook.setColumnValue(row, 'ITEM_NM', ihook.getColumnValue(rowform,'ITEM_NM'));
                        ihook.setColumnValue(row, 'ADMIN_STUS_ID', ihook.getColumnValue(rowform,'ADMIN_STUS_ID'));
                        ihook.setColumnValue(row, 'REGSTR_STUS_ID', ihook.getColumnValue(rowform,'REGSTR_STUS_ID'));
            ihook.setColumnValue(row, 'CNTXT_ITEM_ID', ihook.getColumnValue(rowform,'CNTXT_ITEM_ID'));
            ihook.setColumnValue(row, 'CNTXT_VER_NR', ihook.getColumnValue(rowform,'CNTXT_VER_NR'));

            rows:= t_rows();
            rows.extend;
            rows(rows.last) := row;

            action             := t_actionrowset(rows, 'Administered Item (No Sequence)', 2, 0,'update');
            actions.extend;
            actions(actions.last) := action;

            rows:= t_rows();

          row := row_ori;
            ihook.setColumnValue(row, 'INSTR', ihook.getColumnValue(rowform,'INSTR'));

            rows.extend;
            rows(rows.last) := row;
     -- raise_application_error(-20000,  ihook.getColumnValue(row_ori,'ITEM_ID'));
            action             := t_actionrowset(rows, 'Generic AI Relationship', 2, 2,'update');
            actions.extend;
            actions(actions.last) := action;
    hookoutput.actions    := actions;
    hookoutput.message := 'Module updated Successfully.';



    END IF;
  END IF;

  V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
END;


procedure spAddQuestionRep (rep in integer, row_ori in t_row, rows in out t_rows)
AS
  i integer;
  v_temp integer;
  row t_row;
  v_ori_rep integer;

begin
        v_ori_rep := nvl(ihook.getColumnValue(row_ori, 'REP_NO'),0);
        for cur in (select nci_pub_id, nci_ver_nr, edit_ind, req_ind from nci_admin_item_rel_alt_key where p_item_id =ihook.getColumnValue(row_ori,'C_ITEM_ID') and
        P_item_ver_nr =  ihook.getColumnValue(row_ori,'C_ITEM_VER_NR') and nvl(fld_delete,0) = 0) loop
        for i in v_ori_rep+1..rep loop
        select count(*) into v_temp from nci_quest_vv_rep where quest_pub_id =cur.nci_pub_id and quest_ver_nr = cur.nci_ver_nr and rep_seq = i;

            if v_temp = 0 then
            row := t_row();
            ihook.setColumnValue(row, 'QUEST_PUB_ID', cur.nci_pub_id);
            ihook.setColumnValue(row, 'QUEST_VER_NR', cur.nci_ver_nr);
            ihook.setColumnValue(row, 'REP_SEQ', i);
            ihook.setColumnValue(row, 'EDIT_IND', nvl(cur.edit_ind,1));
            ihook.setColumnValue(row, 'REQ_IND', nvl(cur.req_ind,0));
         ihook.setColumnValue(row, 'QUEST_VV_REP_ID',-1);
        --    raise_application_error(-20000,i);
            rows.extend;
            rows(rows.last) := row;
          end if;
       end loop;
       end loop;
end;


procedure spAddQuestionRepNew (rep in integer, v_quest_id in integer, rows in out t_rows)
AS
  i integer;
  v_temp integer;
  row t_row;

begin
        for i in 1..rep loop
            row := t_row();
            ihook.setColumnValue(row, 'QUEST_PUB_ID',v_quest_id );
            ihook.setColumnValue(row, 'QUEST_VER_NR', 1);
            ihook.setColumnValue(row, 'REP_SEQ', i);
           ihook.setColumnValue(row, 'EDIT_IND',1);
            ihook.setColumnValue(row, 'QUEST_VV_REP_ID',-1);
        --    raise_application_error(-20000,i);
            rows.extend;
            rows(rows.last) := row;

       end loop;
end;

PROCEDURE spSetModRep
  (
    v_data_in IN CLOB,
    v_data_out OUT CLOB,
    v_user_id in varchar2)
    AS
forms t_forms;
  form1 t_form;
  hookInput t_hookInput;
  hookOutput t_hookOutput := t_hookOutput();
   actions t_actions := t_actions();
  action t_actionRowset;
  row t_row;
  rows  t_rows;
    row_ori t_row;
    rowform t_row;
  action_rows       t_rows := t_rows();
  action_row		    t_row;
  rowset            t_rowset;
 question    t_question;
answer     t_answer;
answers     t_answers;
showrowset	t_showablerowset;
  v_disp_ord integer;
  v_add integer;
  i integer := 0;
  v_temp integer;
  v_ori_rep integer;
  rep integer;
  column  t_column;
  msg varchar2(4000);
BEGIN
  hookinput                    := Ihook.gethookinput (v_data_in);
  hookoutput.invocationnumber  := hookinput.invocationnumber;
  hookoutput.originalrowset    := hookinput.originalrowset;

 row_ori :=  hookInput.originalRowset.rowset(1);
 rows := t_rows();
 if (nci_form_mgmt.isUserAuth(ihook.getColumnValue(row_ori, 'P_ITEM_ID'), ihook.getColumnValue(row_ori,'P_ITEM_VER_NR'), v_user_id) = false) then
 raise_application_error(-20000,'You are not authorized to edit module to this form.');
 end if;

v_ori_rep := nvl(ihook.getColumnValue(row_ori, 'REP_NO'),0);

 if hookInput.invocationNumber = 0 then
    ANSWERS                    := T_ANSWERS();
    ANSWER                     := T_ANSWER(1, 1, 'Set Repetition');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
    QUESTION               := T_QUESTION('Set Module Repetition, Current Repetitions: ' || v_ori_rep, ANSWERS);
    HOOKOUTPUT.QUESTION    := QUESTION;
	  /*  for i in 1..20 loop

		   row := t_row();
	   	   iHook.setcolumnvalue (ROW, 'Repetition', i);
		   rows.extend;
		   rows (rows.last) := row;

	    end loop;

	   	 showrowset := t_showablerowset (rows, 'Repetition', 4, 'single');
       	 hookoutput.showrowset := showrowset;
*/

    forms                  := t_forms();
    form1                  := t_form('Question Repetition Set (Hook)', 2,1);
    forms.extend;    forms(forms.last) := form1;
    hookoutput.forms :=     forms;

  ELSE -- hook invocation = 1
     forms              := hookInput.forms;
        form1              := forms(1);
        rowform := form1.rowset.rowset(1);

        rows := t_rows();
        rep := nvl(ihook.getColumnValue(rowform, 'VER_NR'),0);
        if (rep < v_ori_rep) then
            hookoutput.message := 'Specify a number larger than the current number of repetition  - ' || v_ori_rep;
            V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
            return;
      end if;
    --    raise_application_error(-20000,rep);
        spAddQuestionRep (rep, row_ori, rows);
        if (rows.count > 0) then
        action             := t_actionrowset(rows, 'Question Repetition', 2, 0,'insert');
            actions.extend;
            actions(actions.last) := action;
         end if;
            rows := t_rows();
            row := t_row();
             ihook.setColumnValue(row_ori, 'REP_NO', rep);

     rows.extend;
            rows(rows.last) := row_ori;
            action             := t_actionrowset(rows, 'Form-Module Relationship', 2, 1,'update');
            actions.extend;
            actions(actions.last) := action;

    hookoutput.actions    := actions;
    END IF;


  V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
--  nci_util.debugHook('GENERAL',v_data_out);
--  insert into junk_debug values (sysdate, v_data_out);
 -- commit;

END;


PROCEDURE spDelModRep
  (
    v_data_in IN CLOB,
    v_data_out OUT CLOB,
    v_usr_id in varchar2)
    AS
  hookInput t_hookInput;
  hookOutput t_hookOutput := t_hookOutput();
   actions t_actions := t_actions();
  action t_actionRowset;
  row t_row;
  rows  t_rows;
    row_ori t_row;
    row_sel t_row;
  action_rows       t_rows := t_rows();
  action_row		    t_row;
  rowset            t_rowset;
 question    t_question;
answer     t_answer;
answers     t_answers;
showrowset	t_showablerowset;
  v_disp_ord integer;
  v_add integer;
  i integer := 0;
  v_temp integer;
  v_rep integer;
  v_rep_sel integer;
  column  t_column;
  msg varchar2(4000);
BEGIN
  hookinput                    := Ihook.gethookinput (v_data_in);
  hookoutput.invocationnumber  := hookinput.invocationnumber;
  hookoutput.originalrowset    := hookinput.originalrowset;

 row_ori :=  hookInput.originalRowset.rowset(1);
 rows := t_rows();
 if (nci_form_mgmt.isUserAuth(ihook.getColumnValue(row_ori, 'P_ITEM_ID'), ihook.getColumnValue(row_ori,'P_ITEM_VER_NR'), v_usr_id) = false) then
 raise_application_error(-20000,'You are not authorized to edit module to this form.');
 end if;

  v_rep :=  nvl(ihook.getColumnValue(row_ori, 'REP_NO'),0);
 if (v_rep = 0) then
 raise_application_error(-20000,'This module does not have any repetitions.');
 end if;
 if hookInput.invocationNumber = 0 then
    ANSWERS                    := T_ANSWERS();
    ANSWER                     := T_ANSWER(1, 1, 'Select Repetition');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
    QUESTION               := T_QUESTION('Delete Repetition', ANSWERS);
    HOOKOUTPUT.QUESTION    := QUESTION;

	    for i in 1..v_rep loop

		   row := t_row();
	   	   iHook.setcolumnvalue (ROW, 'Repetition', i);
		   rows.extend;
		   rows (rows.last) := row;

	    end loop;

	   	 showrowset := t_showablerowset (rows, 'Repetition', 4, 'single');
       	 hookoutput.showrowset := showrowset;


  ELSE
        row_sel := hookinput.selectedRowset.rowset(1);
        rows := t_rows();
        v_rep_sel := ihook.getColumnValue(row_sel, 'Repetition');
        rows := t_rows();
        for cur in (select r.quest_vv_rep_id from nci_admin_item_rel_alt_key ak, nci_quest_vv_rep r
        where ak.p_item_id = ihook.getColumnValue(row_ori,'C_ITEM_ID') and
        ak.p_item_ver_nr = ihook.getColumnValue(row_ori,'C_ITEM_VER_NR') and
        r.quest_pub_id = ak.nci_pub_id and r.quest_ver_nr = ak.nci_ver_nr and r.rep_seq = v_rep_sel) loop
        row := t_row();
        ihook.setColumnValue(row,'QUEST_VV_REP_ID', cur.QUEST_VV_REP_ID);
        rows.extend;            rows(rows.last) := row;
        end loop;

        if (rows.count > 0) then
        action             := t_actionrowset(rows, 'Question Repetition', 2, 0,'delete');
            actions.extend;
            actions(actions.last) := action;
        action             := t_actionrowset(rows, 'Question Repetition', 2, 1,'purge');
            actions.extend;
            actions(actions.last) := action;
         end if;
         rows := t_rows();
         for i in v_rep_sel+1..v_rep loop
            for cur in (select r.* from nci_admin_item_rel_alt_key ak, nci_quest_vv_rep r
            where ak.p_item_id = ihook.getColumnValue(row_ori,'C_ITEM_ID') and
            ak.p_item_ver_nr = ihook.getColumnValue(row_ori,'C_ITEM_VER_NR') and
            r.quest_pub_id = ak.nci_pub_id and r.quest_ver_nr = ak.nci_ver_nr and r.rep_seq = i) loop
                row := t_row();
                ihook.setColumnValue(row,'QUEST_VV_REP_ID', cur.QUEST_VV_REP_ID);
                           ihook.setColumnValue(row, 'QUEST_PUB_ID', cur.quest_pub_id);
            ihook.setColumnValue(row, 'QUEST_VER_NR', cur.quest_ver_nr);
            ihook.setColumnValue(row, 'REP_SEQ', i-1);
            ihook.setColumnValue(row, 'EDIT_IND', cur.edit_ind);

                rows.extend;            rows(rows.last) := row;
            end loop;
        end loop;
        if (rows.count > 0) then
        action             := t_actionrowset(rows, 'Question Repetition', 2, 3,'update');
            actions.extend;
            actions(actions.last) := action;
         end if;
         rows := t_rows();

           ihook.setColumnValue(row_ori, 'REP_NO', v_rep-1);

     rows.extend;
            rows(rows.last) := row_ori;
            action             := t_actionrowset(rows, 'Form-Module Relationship', 2, 4,'update');
            actions.extend;
            actions(actions.last) := action;

    hookoutput.actions    := actions;
    END IF;


  V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);

END;


PROCEDURE spSetDefltVal
  (
    v_data_in IN CLOB,
    v_data_out OUT CLOB,
    v_user_id in varchar2)
    AS
  hookInput t_hookInput;
  hookOutput t_hookOutput := t_hookOutput();
   actions t_actions := t_actions();
  action t_actionRowset;
  row t_row;
  rowrel t_row;
  rows  t_rows;
  rows0 t_rows;
    row_ori t_row;
  action_rows       t_rows := t_rows();
  action_row		    t_row;
  rowset            t_rowset;
 question    t_question;
 row_sel t_row;
 rep integer;
answer     t_answer;
answers     t_answers;
showrowset	t_showablerowset;
  forms t_forms;
  form1 t_form;
  rowform t_row;
v_found boolean;
  v_mod_id number;
  v_frm_id number;
  v_frm_ver_nr number(4,2);
  v_mod_ver_nr number(4,2);
  v_disp_ord integer;
  v_add integer;
  v_rep integer;
  i integer := 0;
  v_temp number;
  column  t_column;
  msg varchar2(4000);
BEGIN
  hookinput                    := Ihook.gethookinput (v_data_in);
  hookoutput.invocationnumber  := hookinput.invocationnumber;
  hookoutput.originalrowset    := hookinput.originalrowset;

 row_ori :=  hookInput.originalRowset.rowset(1);
 rows := t_rows();
 -- Get form and module ID


 select r.P_ITEM_ID, r.P_ITEM_VER_NR into v_frm_id, v_frm_Ver_nr from NCI_ADMIN_ITEM_REL_ALT_KEY k, NCI_ADMIN_ITEM_REL r where k.nci_pub_id = ihook.getColumNValue(row_ori, 'Q_PUB_ID')
 and k.nci_ver_nr = ihook.getColumNValue(row_ori, 'Q_VER_NR') and k.P_ITEM_ID = r.C_ITEM_ID and k.P_ITEM_VER_NR = r.C_ITEM_VER_NR and r.rel_typ_id = 61;

 if (nci_form_mgmt.isUserAuth(v_frm_id, v_frm_ver_nr, v_user_id) = false) then
 raise_application_error(-20000,'You are not authorized to edit any question in this form.');
 end if;


 if hookInput.invocationNumber = 0 then

   v_found := false;
   rows := t_rows();
   row := t_row();


   ihook.setColumnValue(row, 'Level', 'Question Default');
   ihook.setColumnValue(row, 'Sequence', 0);

            rows.extend;
            rows(rows.last) := row;
   for cur in (Select rep_seq  from nci_quest_vv_rep where QUEST_PUB_ID=ihook.getColumNValue(row_ori, 'Q_PUB_ID')  and quest_ver_nr = ihook.getColumNValue(row_ori, 'Q_VER_NR')) loop
   row := t_row();

    ihook.setColumnValue(row, 'Level', 'Repetition: '|| cur.rep_seq);
   ihook.setColumnValue(row, 'Sequence', cur.rep_seq);

            rows.extend;
            rows(rows.last) := row;
  -- raise_application_error (-20000, 'In here');

      v_found := true;
   end loop;

  -- if (v_found) then
    ANSWERS                    := T_ANSWERS();
    ANSWER                     := T_ANSWER(1, 1, 'Set default');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
    QUESTION               := T_QUESTION('Set', ANSWERS);
    HOOKOUTPUT.QUESTION    := QUESTION;
          	 showrowset := t_showablerowset (rows, 'Repetition', 4, 'multi');
       	 hookoutput.showrowset := showrowset;

--else

/*rows := t_rows();
row := t_row();
           ihook.setColumnValue(row, 'NCI_PUB_ID', ihook.getColumnValue(row_ori,'Q_PUB_ID'));
           ihook.setColumnValue(row, 'NCI_VER_NR', ihook.getColumnValue(row_ori,'Q_VER_NR'));
           ihook.setColumnValue(row, 'DEFLT_VAL_ID', ihook.getColumnValue(row_ori,'NCI_PUB_ID'));
    rows.extend;
            rows(rows.last) := row;

     -- raise_application_error(-20000,  ihook.getColumnValue(row_ori,'ITEM_ID'));
            action             := t_actionrowset(rows, 'Question (Edit)', 2, 2,'update');
            actions.extend;
            actions(actions.last) := action;
    hookoutput.actions    := actions;
  */
 --  hookoutput.message := 'No repetition for this module';
 --end if;
 ELSE


        rows := t_rows();

      for i in 1..hookinput.selectedRowset.rowset.count loop

       row_sel := hookinput.selectedRowset.rowset(i);

        rep := ihook.getColumnValue(row_sel, 'Sequence');

        if (rep = 0) then -- main question default


          row := t_row();
          rows0 := t_rows();
           ihook.setColumnValue(row, 'NCI_PUB_ID', ihook.getColumnValue(row_ori,'Q_PUB_ID'));
           ihook.setColumnValue(row, 'NCI_VER_NR', ihook.getColumnValue(row_ori,'Q_VER_NR'));
           ihook.setColumnValue(row, 'DEFLT_VAL_ID', ihook.getColumnValue(row_ori,'NCI_PUB_ID'));
     ihook.setColumnValue(row, 'QUEST_REF_ID', ihook.getColumnValue(row_ori,'NCI_PUB_ID'));


    rows0.extend;
            rows0(rows0.last) := row;
     -- raise_application_error(-20000,  ihook.getColumnValue(row_ori,'ITEM_ID'));
            action             := t_actionrowset(rows0, 'Questions (Base Object)', 2, 2,'update');
            actions.extend;
            actions(actions.last) := action;
        end if;
        if (rep>0) then
        select 	QUEST_VV_REP_ID into v_temp from nci_quest_vv_rep where quest_pub_id = ihook.getColumnValue(row_ori,'Q_PUB_ID')
        and quest_ver_nr = ihook.getColumnValue(row_ori,'Q_VER_NR') and rep_seq = rep;
          row := t_row();
            ihook.setColumnValue(row, 'QUEST_VV_REP_ID', v_temp);
            ihook.setColumnValue(row, 'DEFLT_VAL_ID', ihook.getColumnValue(row_ori,'NCI_PUB_ID'));
            rows.extend;
            rows(rows.last) := row;

            action             := t_actionrowset(rows, 'Question Repetition', 2, 0,'update');
            actions.extend;
            actions(actions.last) := action;

          end if;
  end loop;
    hookoutput.actions    := actions;

  END IF;

  V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
 -- insert into junk_debug values (sysdate, v_data_out);
 -- commit;
END;


PROCEDURE spDelDefltVal
  (
    v_data_in IN CLOB,
    v_data_out OUT CLOB,
    v_user_id in varchar2)
    AS
  hookInput t_hookInput;
  hookOutput t_hookOutput := t_hookOutput();
   actions t_actions := t_actions();
  action t_actionRowset;
  row t_row;
  rows  t_rows;
    row_ori t_row;
   rowset            t_rowset;

 i integer;
v_found boolean;
  v_mod_id number;
  v_disp_ord integer;
  v_rep integer;
BEGIN
  hookinput                    := Ihook.gethookinput (v_data_in);
  hookoutput.invocationnumber  := hookinput.invocationnumber;
  hookoutput.originalrowset    := hookinput.originalrowset;

/*
 select r.P_ITEM_ID, r.P_ITEM_VER_NR into v_frm_id, v_frm_Ver_nr from NCI_ADMIN_ITEM_REL_ALT_KEY k, NCI_ADMIN_ITEM_REL r where k.nci_pub_id = ihook.getColumNValue(row_ori, 'Q_PUB_ID')
 and k.nci_ver_nr = ihook.getColumNValue(row_ori, 'Q_VER_NR') and k.P_ITEM_ID = r.C_ITEM_ID and k.P_ITEM_VER_NR = r.C_ITEM_VER_NR and r.rel_typ_id = 61;

 if (nci_form_mgmt.isUserAuth(v_frm_id, v_frm_ver_nr, v_user_id) = false) then
 raise_application_error(-20000,'You are not authorized to edit any question in this form.');
 end if;
 */
        rows := t_rows();

        for i in 1..hookinput.originalRowset.rowset.count loop
            row_ori :=  hookInput.originalRowset.rowset(i);
           ihook.setColumnValue(row_ori, 'DEFLT_VAL_ID', '');

            rows.extend;
            rows(rows.last) := row_ori;
        end loop;

         if (upper(hookinput.originalrowset.tablename) like '%REP%') then
            action             := t_actionrowset(rows, 'Question Repetition', 2, 0,'update');
         else
            action             := t_actionrowset(rows, 'Questions (Base Object)', 2, 0,'update');
         end if;
         actions.extend;
         actions(actions.last) := action;

        hookoutput.actions    := actions;
        V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
 END;

PROCEDURE spChngQuestText
  (

    v_data_in IN CLOB,
    v_data_out OUT CLOB,
    v_user_id in varchar2)
    AS
  hookInput t_hookInput;
  hookOutput t_hookOutput := t_hookOutput();
   actions t_actions := t_actions();
  action t_actionRowset;
  row t_row;
  rowrel t_row;
  row_sel t_row;
  rows  t_rows;
    row_ori t_row;
  action_rows       t_rows := t_rows();
  action_row		    t_row;
  rowset            t_rowset;
 question    t_question;
answer     t_answer;
answers     t_answers;
showrowset	t_showablerowset;
  rowform t_row;
v_found boolean;
  v_module_id integer;
  v_disp_ord integer;
  v_frm_id number;
  v_frm_ver_nr number(4,2);
  v_ref varchar2(255);
  v_add integer;
  i integer := 0;
  column  t_column;
  msg varchar2(4000);
BEGIN
  hookinput                    := Ihook.gethookinput (v_data_in);
  hookoutput.invocationnumber  := hookinput.invocationnumber;
  hookoutput.originalrowset    := hookinput.originalrowset;

 row_ori :=  hookInput.originalRowset.rowset(1);
 rows := t_rows();

 select frm_item_id, frm_ver_nr into v_frm_id, v_frm_Ver_nr from VW_NCI_MODULE_DE where nci_pub_id = ihook.getColumNValue(row_ori, 'NCI_PUB_ID') and nci_ver_nr = ihook.getColumNValue(row_ori, 'NCI_VER_NR');
 if (nci_form_mgmt.isUserAuth(v_frm_id, v_frm_ver_nr, v_user_id) = false) then
 raise_application_error(-20000,'You are not authorized to edit any question in this form.');
 end if;

 if hookInput.invocationNumber = 0 then
    ANSWERS                    := T_ANSWERS();
    ANSWER                     := T_ANSWER(1, 1, 'Select Question Text');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
    QUESTION               := T_QUESTION('Question Text', ANSWERS);
    HOOKOUTPUT.QUESTION    := QUESTION;

	    for cur in (select ref_id from ref r, obj_key ok where r.fld_delete= 0 and item_id = ihook.getColumNValue(row_ori, 'C_ITEM_ID')  and
        ver_nr = ihook.getColumNValue(row_ori, 'C_ITEM_VER_NR' ) and r.ref_typ_id = ok.obj_key_id and ok.obj_typ_id = 1 and upper(ok.obj_key_desc) like '%QUESTION TEXT%') loop
		   row := t_row();
	   	   iHook.setcolumnvalue (ROW, 'REF_ID', cur.ref_id);
		   rows.extend;
		   rows (rows.last) := row;

 --raise_application_error(-20000,ihook.getColumNValue(row_ori, 'C_ITEM_ID'));
   v_found := true;
	    end loop;

	  if (v_found) then
       	 showrowset := t_showablerowset (rows, 'References (for hook insert)', 2, 'single');
       	 hookoutput.showrowset := showrowset;
     end if;
 ELSE
            row_sel := hookinput.selectedRowset.rowset(1);

            select ref_desc into v_ref from ref where ref_id = ihook.getColumnValue(row_sel, 'REF_ID');

            ihook.setColumnValue(row_ori, 'ITEM_LONG_NM', v_ref);
            rows:= t_rows();
            rows.extend;
            rows(rows.last) := row_ori;

            action             := t_actionrowset(rows, 'Questions (Edit)', 2, 0,'update');
            actions.extend;
            actions(actions.last) := action;


    hookoutput.actions    := actions;
    END IF;

  V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
END;


PROCEDURE spChngQuestShortText
  (

    v_data_in IN CLOB,
    v_data_out OUT CLOB,
    v_user_id in varchar2)
    AS
  hookInput t_hookInput;
  hookOutput t_hookOutput := t_hookOutput();
   actions t_actions := t_actions();
  action t_actionRowset;
  row t_row;
  rowrel t_row;
  row_sel t_row;
  rows  t_rows;
    row_ori t_row;
  action_rows       t_rows := t_rows();
  action_row		    t_row;
  rowset            t_rowset;
 question    t_question;
answer     t_answer;
answers     t_answers;
showrowset	t_showablerowset;
  rowform t_row;
v_found boolean;
  v_module_id integer;
  v_disp_ord integer;
  v_frm_id number;
  v_frm_ver_nr number(4,2);
  v_ref varchar2(255);
  v_add integer;
  i integer := 0;
  column  t_column;
  msg varchar2(4000);
BEGIN
  hookinput                    := Ihook.gethookinput (v_data_in);
  hookoutput.invocationnumber  := hookinput.invocationnumber;
  hookoutput.originalrowset    := hookinput.originalrowset;

 row_ori :=  hookInput.originalRowset.rowset(1);
 rows := t_rows();

 select frm_item_id, frm_ver_nr into v_frm_id, v_frm_Ver_nr from VW_NCI_MODULE_DE where nci_pub_id = ihook.getColumNValue(row_ori, 'NCI_PUB_ID') and nci_ver_nr = ihook.getColumNValue(row_ori, 'NCI_VER_NR');
 if (nci_form_mgmt.isUserAuth(v_frm_id, v_frm_ver_nr, v_user_id) = false) then
 raise_application_error(-20000,'You are not authorized to edit any question in this form.');
 end if;

 if ( ihook.getColumNValue(row_ori, 'C_ITEM_ID') is null) then
 raise_application_error(-20000,'No CDE attached to this question.');
 end if;
 if hookInput.invocationNumber = 0 then
    ANSWERS                    := T_ANSWERS();
    ANSWER                     := T_ANSWER(1, 1, 'Select Question Short Name');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
      ANSWER                     := T_ANSWER(2, 2, 'Set to Default CDE Short Name');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
     QUESTION               := T_QUESTION('Question Short Name', ANSWERS);
    HOOKOUTPUT.QUESTION    := QUESTION;

	    for cur in (select nm_id from alt_nms a where a.fld_delete= 0 and item_id = ihook.getColumNValue(row_ori, 'C_ITEM_ID')  and
        ver_nr = ihook.getColumNValue(row_ori, 'C_ITEM_VER_NR' ) and upper(cntxt_nm_dn) <> upper(nm_desc) and nm_typ_id not in (select obj_key_id from obj_key where upper(obj_key_desc) = 'HISTORICAL_CDE_ID')
        order by cntxt_nm_dn, nm_typ_id) loop
		   row := t_row();
	   	   iHook.setcolumnvalue (ROW, 'NM_ID', cur.nm_id);
		   rows.extend;
		   rows (rows.last) := row;

 --raise_application_error(-20000,ihook.getColumNValue(row_ori, 'C_ITEM_ID'));
   v_found := true;
	    end loop;

	  if (v_found) then
       	 showrowset := t_showablerowset (rows, 'Alternate Names', 2, 'single');
       	 hookoutput.showrowset := showrowset;
     end if;
 ELSE
 if (hookinput.answerid = 1 and hookinput.selectedRowset is not null) then

            row_sel := hookinput.selectedRowset.rowset(1);

            select nm_desc into v_ref from alt_nms where nm_id = ihook.getColumnValue(row_sel, 'NM_ID');
 elsif (hookinput.answerid = 2) then
        select item_long_nm into v_ref from admin_item where item_id = ihook.getColumnValue(row_ori, 'C_ITEM_ID') and ver_nr =ihook.getColumnValue(row_ori, 'C_ITEM_VER_NR')  ;
 end if;

 if (v_ref is not null) then
            ihook.setColumnValue(row_ori, 'ITEM_NM', substr(v_ref,1,30));
            rows:= t_rows();
            rows.extend;
            rows(rows.last) := row_ori;

            action             := t_actionrowset(rows, 'Questions (Edit)', 2, 0,'update');
            actions.extend;
            actions(actions.last) := action;
               hookoutput.actions    := actions;

end if;

    END IF;

  V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
END;

PROCEDURE spAddQuestion
  (
    v_data_in IN CLOB,
    v_data_out OUT CLOB,
    v_user_id in varchar2)
AS
  hookInput t_hookInput;
  hookOutput t_hookOutput := t_hookOutput();
   actions t_actions := t_actions();
  action t_actionRowset;
  row t_row;
  rows  t_rows;
  rowsvv t_rows;
  rowsrep  t_rows;
    row_ori t_row;
    row_sel t_row;
    v_id integer;
  action_rows       t_rows := t_rows();
  action_row		    t_row;
  rowset            t_rowset;
 question    t_question;
answer     t_answer;
answers     t_answers;
showrowset	t_showablerowset;
forms     t_forms;
formGroup    t_form;
v_itemid     integer;
v_found boolean;
  v_temp integer;
  v_stg_ai_id number;
  v_add integer := 0;
  i integer := 0;
  j integer;
  v_disp_ord integer;
  column  t_column;
  msg varchar2(4000);
    type t_item_id is table of admin_item.item_id%type;
    type t_ver_nr is table of admin_item.ver_nr%type;

    v_tab_item_id  t_item_id := t_item_id();
    v_tab_ver_nr  t_ver_nr := t_ver_nr();
rep integer;
BEGIN
  hookinput                    := Ihook.gethookinput (v_data_in);
  hookoutput.invocationnumber  := hookinput.invocationnumber;
  hookoutput.originalrowset    := hookinput.originalrowset;

  row_ori :=  hookInput.originalRowset.rowset(1);

    rows := t_rows();


 if (nci_form_mgmt.isUserAuth(ihook.getColumnValue(row_ori, 'P_ITEM_ID'), ihook.getColumnValue(row_ori,'P_ITEM_VER_NR'), v_user_id) = false) then
 raise_application_error(-20000,'You are not authorized to add a question to this module.');
 end if;

    if hookInput.invocationNumber = 0 then

	    rows :=         t_rows();
		v_found := false;

	    for cur in (select c.item_id, c.ver_nr from NCI_USR_CART c, admin_item ai where c.fld_delete= 0 and cntct_secu_id = v_user_id and ai.item_id = c.item_id and ai.ver_nr = c.ver_nr and
        ai.admin_item_typ_id = 4 ) loop
		   row := t_row();
	   	   iHook.setcolumnvalue (ROW, 'ITEM_ID', cur.ITEM_ID);
		   iHook.setcolumnvalue (ROW, 'VER_NR', cur.VER_NR);
		   iHook.setcolumnvalue (ROW, 'CNTCT_SECU_ID', v_user_id);
		   rows.extend;
		   rows (rows.last) := row;
		   v_found := true;
	    end loop;

	  if (v_found) then
       	 showrowset := t_showablerowset (rows, 'User Cart', 2, 'multi');
       	 hookoutput.showrowset := showrowset;

       	 answers := t_answers();
  	   	 answer := t_answer(1, 1, 'Select CDE to Add');
  	   	 answers.extend; answers(answers.last) := answer;

	   	 question := t_question('Add Question to Module', answers);
       	 hookOutput.question := question;
      else
        hookoutput.message := 'Please add Data Elements to your cart.';
	   end if;

	elsif hookInput.invocationNumber = 1 then

          select nvl(max(disp_ord)+1,0) into v_disp_ord from NCI_ADMIN_ITEM_REL_ALT_KEY where P_ITEM_ID =ihook.getColumnValue(row_ori,'C_ITEM_ID')  and
          P_ITEM_VER_NR = ihook.getColumnValue(row_ori,'C_ITEM_VER_NR') and rel_typ_id = 63;
                        rep := ihook.getColumnValue(row_ori, 'REP_NO');

            for i in 1..hookInput.selectedRowset.rowset.count loop
                    row_sel := hookInput.selectedRowset.rowset(i);
                v_tab_item_id.extend();
                v_tab_ver_nr.extend();
                v_tab_item_id(v_tab_item_id.count) := ihook.getColumnValue(row_sel,'ITEM_ID');
                v_tab_ver_nr(v_tab_ver_nr.count) := ihook.getColumnValue(row_sel,'VER_NR');
                -- Add component Item id
                    for cur in (select c_item_id, c_item_ver_nr from nci_admin_item_rel where rel_typ_id = 65 and p_item_id = ihook.getColumnValue(row_sel,'ITEM_ID')
                    and p_item_ver_nr = ihook.getColumnValue(row_sel,'VER_NR') order by disp_ord) loop
                        v_tab_item_id.extend();
                        v_tab_ver_nr.extend();
                        v_tab_item_id(v_tab_item_id.count) := cur.c_item_id;
                        v_tab_ver_nr(v_tab_ver_nr.count) := cur.c_item_ver_nr;
                    end loop;
            end loop;
          rows := t_rows();
          rowsvv := t_rows();
                        rowsrep := t_rows();
        --      for i in 1..hookInput.selectedRowset.rowset.count loop
          --          row_sel := hookInput.selectedRowset.rowset(i);
    --      raise_application_error(-20000, 'herere ' || v_tab_item_id.count);
              for i in 1..v_tab_item_id.count loop

                    for cur in (select ai.item_id, ai.ver_nr, ai.cntxt_item_id, ai.cntxt_ver_nr, item_long_nm item_long_nm, nvl(r.ref_desc, item_long_nm) QUEST_TEXT, item_nm
                    from admin_item ai, ref r where
                    ai.item_id = v_tab_item_id(i) and ai.ver_nr = v_tab_ver_nr(i) and ai.item_id = r.item_id (+) and ai.ver_nr = r.ver_nr (+)
                    and r.ref_typ_id (+) = 80) loop
              --      and (ai.item_id, ai.ver_nr) not in (select c_item_id, c_item_ver_nr from nci_admin_item_rel_alt_key where p_item_id = ihook.getColumnValue(row_ori,'C_ITEM_ID') and
               --             p_item_ver_nr = ihook.getColumnValue(row_ori, 'C_ITEM_VER_NR') and rel_typ_id = 63 )) loop
                        row := t_row();
             --   raise_application_error(-20000, 'herere ' || cur.item_id);

                        v_id := nci_11179.getItemId;
                        ihook.setColumnValue (row, 'NCI_PUB_ID', v_id);
                        ihook.setColumnValue (row, 'NCI_VER_NR', 1);
                        ihook.setColumnValue (row, 'P_ITEM_ID', ihook.getColumnValue(row_ori,'C_ITEM_ID'));
                        ihook.setColumnValue (row, 'P_ITEM_VER_NR', ihook.getColumnValue(row_ori,'C_ITEM_VER_NR'));
                        ihook.setColumnValue (row, 'C_ITEM_ID', cur.item_id);
                        ihook.setColumnValue (row, 'C_ITEM_VER_NR', cur.ver_nr);
                        ihook.setColumnValue (row, 'CNTXT_CS_ITEM_ID', cur.cntxt_item_id);
                        ihook.setColumnValue (row, 'CNTXT_CS_VER_NR', cur.cntxt_ver_nr);
                        ihook.setColumnValue (row, 'ITEM_LONG_NM', cur.QUEST_TEXT );
                         ihook.setColumnValue (row, 'ITEM_NM', cur.ITEM_LONG_NM );
                        ihook.setColumnValue (row, 'EDIT_IND', 1 );
                        ihook.setColumnValue (row, 'REQ_IND', 0 );
                        ihook.setColumnValue (row, 'REL_TYP_ID', 63);
                        ihook.setColumnValue (row, 'DISP_ORD', v_disp_ord);
                        v_disp_ord := v_disp_ord + 1;

                        v_add := v_add + 1;
                        rows.extend;
                        rows(rows.last) := row;


                        if nvl(rep,0) > 0 then
                            spAddQuestionRepNew (rep, v_id, rowsrep);
                        end if;
                        j := 0;
                for cur1 in (select * from  VW_NCI_DE_PV where de_item_id = cur.item_id and de_ver_nr = cur.ver_nr order by PERM_VAL_NM) loop
                  row := t_row();
                ihook.setColumnValue (row, 'Q_PUB_ID', v_id);
                ihook.setColumnValue (row, 'Q_VER_NR', 1);
                ihook.setColumnValue (row, 'VM_NM', cur1.item_nm);
                ihook.setColumnValue (row, 'VM_LNM', cur1.item_long_nm);
                ihook.setColumnValue (row, 'VM_DEF', cur1.item_desc);
                ihook.setColumnValue (row, 'VALUE', cur1.perm_val_nm);
                ihook.setColumnValue (row, 'MEAN_TXT', cur1.item_nm);
                ihook.setColumnValue (row, 'DESC_TXT', substr(cur1.item_desc,1,2000));
                ihook.setColumnValue (row, 'VAL_MEAN_ITEM_ID', cur1.NCI_VAL_MEAN_ITEM_ID);
                ihook.setColumnValue (row, 'VAL_MEAN_VER_NR', cur1.NCI_VAL_MEAN_VER_NR);
                v_itemid := nci_11179.getItemId;
                ihook.setColumnValue (row, 'NCI_PUB_ID', v_itemid);
                ihook.setColumnValue (row, 'NCI_VER_NR', 1);
                ihook.setColumnValue (row, 'DISP_ORD', j);
                 rowsvv.extend;
                rowsvv(rowsvv.last) := row;
                j := j+ 1;
                end loop;
                 end loop;
   end loop;

--DESC_TXT
   -- raise_application_error(-20000, v_add);
        if (rows.count > 0) then
                        action := t_actionrowset(rows, 'Questions (Base Object)', 2,0,'insert');
                        actions.extend;
                        actions(actions.last) := action;
        end if;

    if (rowsvv.count > 0) then
    action := t_actionrowset(rowsvv, 'Question Valid Values (Hook)', 2,2,'insert');
    actions.extend;
    actions(actions.last) := action;
    end if;

       if (rowsrep.count > 0) then
        action             := t_actionrowset(rowsrep, 'Question Repetition', 2, 4,'insert');
            actions.extend;
            actions(actions.last) := action;
         end if;

  if ( rows.count > 0 ) then  hookoutput.actions := actions;
  end if;
    hookoutput.message := v_add || ' questions added.';

--raise_application_error(-20000,hookoutput.message);
    end if;
  V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
 -- insert into junk_debug values (sysdate, v_data_out);
 -- commit;
END;

PROCEDURE spCopyModule
  (
    v_data_in IN CLOB,
    v_data_out OUT CLOB,
    v_user_id in varchar2)
AS
  hookInput t_hookInput;
  hookOutput t_hookOutput := t_hookOutput();
   actions t_actions := t_actions();
  action t_actionRowset;
  row t_row;
  rows  t_rows;
    row_ori t_row;
    row_sel t_row;
    v_id integer;
  action_rows       t_rows := t_rows();
  action_row		    t_row;
  rowset            t_rowset;
 question    t_question;
answer     t_answer;
answers     t_answers;
showrowset	t_showablerowset;
forms     t_forms;
formGroup    t_form;
v_itemid     integer;
v_found boolean;
  v_temp integer;
  v_stg_ai_id number;
  i integer := 0;
  column  t_column;
  msg varchar2(4000);
  v_item_typ  integer;
  v_mod_specified boolean;
BEGIN
  hookinput                    := Ihook.gethookinput (v_data_in);
  hookoutput.invocationnumber  := hookinput.invocationnumber;
  hookoutput.originalrowset    := hookinput.originalrowset;
  row_ori :=  hookInput.originalRowset.rowset(1);

    rows := t_rows();
if (nci_form_mgmt.isUserAuth(ihook.getColumnValue(row_ori, 'ITEM_ID'), ihook.getColumnValue(row_ori,'VER_NR'), v_user_id) = false) then
 raise_application_error(-20000,'You are not authorized to add a module to this form.');
 end if;

    if hookInput.invocationNumber = 0 then

	    rows :=         t_rows();
		v_found := false;

	    for cur in (select c.item_id, c.ver_nr from NCI_USR_CART c, admin_item ai where c.fld_delete= 0 and cntct_secu_id = v_user_id and ai.item_id = c.item_id and ai.ver_nr = c.ver_nr and
        ai.admin_item_typ_id in (52, 54 ) order by admin_item_typ_id) loop
		   row := t_row();
	   	   iHook.setcolumnvalue (ROW, 'ITEM_ID', cur.ITEM_ID);
		   iHook.setcolumnvalue (ROW, 'VER_NR', cur.VER_NR);
		   iHook.setcolumnvalue (ROW, 'CNTCT_SECU_ID', v_user_id);
		   rows.extend;
		   rows (rows.last) := row;
		   v_found := true;
	    end loop;

	  if (v_found) then
       	 showrowset := t_showablerowset (rows, 'User Cart', 2, 'single');
       	 hookoutput.showrowset := showrowset;

       	 answers := t_answers();
  	   	 answer := t_answer(1, 1, 'Select Module');
  	   	 answers.extend; answers(answers.last) := answer;

	   	 question := t_question('Select Module to Copy', answers);
       	 hookOutput.question := question;
     else
               hookoutput.message := 'Please add forms or modules to your cart.';

	   end if;

	end if;

    if hookInput.invocationNumber = 1  then
          v_mod_specified := false;
          row_sel := hookInput.selectedRowset.rowset(1);
          select admin_item_typ_id into v_item_typ from admin_item where  item_id = ihook.getColumnValue(row_sel,'ITEM_ID')
          and ver_nr = ihook.getColumnValue(row_sel,'VER_NR');
          if (v_item_typ = 54) then--- Form
            rows :=         t_rows();
		v_found := false;
	    for cur in (select c.item_id, c.ver_nr from VW_NCI_FORM_MODULE c where c.fld_delete= 0  and c.p_item_id = ihook.getColumnValue(row_sel,'ITEM_ID') and c.p_item_ver_nr =  ihook.getColumnValue(row_sel,'VER_NR') ) loop
		   row := t_row();
	   	   iHook.setcolumnvalue (ROW, 'ITEM_ID', cur.ITEM_ID);
		   iHook.setcolumnvalue (ROW, 'VER_NR', cur.VER_NR);
		   rows.extend;
		   rows (rows.last) := row;
		   v_found := true;
--raise_application_error(-20000, ihook.getColumnValue(row_sel,'ITEM_ID'));
	    end loop;

	  if (v_found) then
       	 showrowset := t_showablerowset (rows, 'Modules', 2, 'single');
       	 hookoutput.showrowset := showrowset;

       	 answers := t_answers();
  	   	 answer := t_answer(1, 1, 'Select Module');
  	   	 answers.extend; answers(answers.last) := answer;

	   	 question := t_question('Select Module to Copy', answers);
       	 hookOutput.question := question;
	   end if;
    else
        v_mod_specified := true;
    end if;
    end if;
    if (hookInput.invocationNumber = 2 or v_mod_specified = true) then -- copy module

	row_sel := hookInput.selectedRowset.rowset(1);
    nci_11179.spCopyModuleNCI (actions, ihook.getColumnValue(row_sel,'ITEM_ID'),ihook.getColumnValue(row_sel,'VER_NR'),
    ihook.getColumnValue(row_sel,'P_ITEM_ID'), ihook.getColumnValue(row_sel,'P_ITEM_VER_NR'), ihook.getColumnValue(row_ori,'ITEM_ID'), ihook.getColumnValue(row_ori,'VER_NR'), -1,'C');


    hookoutput.actions := actions;
    hookoutput.message := 'Module copied successfully.';
    --hookoutput.message := v_add || ' concepts added.';
    end if;
  V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
  nci_util.debugHook('GENERAL',v_data_out);

END;


PROCEDURE spAddQuestionNoDE
  (
    v_data_in IN CLOB,
    v_data_out OUT CLOB,
    v_user_id in varchar2)
AS
  hookInput t_hookInput;
  hookOutput t_hookOutput := t_hookOutput();
   actions t_actions := t_actions();
  action t_actionRowset;
  row t_row;
  rows  t_rows;
  rowsvv t_rows;
    row_ori t_row;
    row_sel t_row;
    v_id integer;
  action_rows       t_rows := t_rows();
  action_row		    t_row;
  rowset            t_rowset;
 question    t_question;
answer     t_answer;
answers     t_answers;
showrowset	t_showablerowset;
forms     t_forms;
formGroup    t_form;
v_itemid     integer;
v_found boolean;
  v_temp integer;
  v_stg_ai_id number;
  v_add integer := 0;
  i integer := 0;
  v_disp_ord integer;
  column  t_column;
  msg varchar2(4000);
BEGIN
  hookinput                    := Ihook.gethookinput (v_data_in);
  hookoutput.invocationnumber  := hookinput.invocationnumber;
  hookoutput.originalrowset    := hookinput.originalrowset;
  row_ori :=  hookInput.originalRowset.rowset(1);

    rows := t_rows();


 if (nci_form_mgmt.isUserAuth(ihook.getColumnValue(row_ori, 'P_ITEM_ID'), ihook.getColumnValue(row_ori,'P_ITEM_VER_NR'), v_user_id) = false) then
 raise_application_error(-20000,'You are not authorized to add a question to this module.');
 end if;

    if hookInput.invocationNumber = 0 then

	    rows :=         t_rows();
		v_found := false;

	    for cur in (select c.item_id, c.ver_nr from NCI_USR_CART c, admin_item ai where c.fld_delete= 0 and cntct_secu_id = v_user_id and ai.item_id = c.item_id and ai.ver_nr = c.ver_nr and
        ai.admin_item_typ_id = 4 ) loop
		   row := t_row();
	   	   iHook.setcolumnvalue (ROW, 'ITEM_ID', cur.ITEM_ID);
		   iHook.setcolumnvalue (ROW, 'VER_NR', cur.VER_NR);
		   rows.extend;
		   rows (rows.last) := row;
		   v_found := true;
	    end loop;

	  if (v_found) then
       	 showrowset := t_showablerowset (rows, 'User Cart', 2, 'multi');
       	 hookoutput.showrowset := showrowset;

       	 answers := t_answers();
  	   	 answer := t_answer(1, 1, 'Select CDE to Add');
  	   	 answers.extend; answers(answers.last) := answer;

	   	 question := t_question('Add Question to Module', answers);
       	 hookOutput.question := question;
	   end if;

	elsif hookInput.invocationNumber = 1 then
		  if hookInput.answerId = 1 then -- Add Question

          select nvl(max(disp_ord)+1,0) into v_disp_ord from NCI_ADMIN_ITEM_REL_ALT_KEY where P_ITEM_ID =ihook.getColumnValue(row_ori,'C_ITEM_ID')  and
          P_ITEM_VER_NR = ihook.getColumnValue(row_ori,'C_ITEM_VER_NR') and rel_typ_id = 63;

          rows := t_rows();
          rowsvv := t_rows();
              for i in 1..hookInput.selectedRowset.rowset.count loop
                    row_sel := hookInput.selectedRowset.rowset(i);
                    for cur in (select ai.item_id, ai.ver_nr, ai.cntxt_item_id, ai.cntxt_ver_nr, item_long_nm item_long_nm, nvl(r.ref_desc, item_long_nm) QUEST_TEXT from admin_item ai, ref r where
                    ai.item_id = ihook.getColumnValue(row_sel,'ITEM_ID') and ai.ver_nr = ihook.getColumnValue(row_sel,'VER_NR') and ai.item_id = r.item_id (+) and ai.ver_nr = r.ver_nr (+)
                    and r.ref_typ_id (+) = 80
                    and (ai.item_id, ai.ver_nr) not in (select c_item_id, c_item_ver_nr from nci_admin_item_rel_alt_key where p_item_id = ihook.getColumnValue(row_ori,'C_ITEM_ID') and
                            p_item_ver_nr = ihook.getColumnValue(row_ori, 'C_ITEM_VER_NR') and rel_typ_id = 63 )) loop
                        row := t_row();

                        v_id := nci_11179.getItemId;
                        ihook.setColumnValue (row, 'NCI_PUB_ID', v_id);
                        ihook.setColumnValue (row, 'NCI_VER_NR', 1);
                        ihook.setColumnValue (row, 'P_ITEM_ID', ihook.getColumnValue(row_ori,'C_ITEM_ID'));
                        ihook.setColumnValue (row, 'P_ITEM_VER_NR', ihook.getColumnValue(row_ori,'C_ITEM_VER_NR'));
                        ihook.setColumnValue (row, 'C_ITEM_ID', cur.item_id);
                        ihook.setColumnValue (row, 'C_ITEM_VER_NR', cur.ver_nr);
                        ihook.setColumnValue (row, 'CNTXT_CS_ITEM_ID', cur.cntxt_item_id);
                        ihook.setColumnValue (row, 'CNTXT_CS_VER_NR', cur.cntxt_ver_nr);
                        ihook.setColumnValue (row, 'ITEM_LONG_NM', cur.QUEST_TEXT );
                        ihook.setColumnValue (row, 'EDIT_IND', 1 );
                        ihook.setColumnValue (row, 'REQ_IND', 0 );

                        ihook.setColumnValue (row, 'REL_TYP_ID', 63);
                        ihook.setColumnValue (row, 'DISP_ORD', v_disp_ord);
                        v_disp_ord := v_disp_ord + 1;

                        v_add := v_add + 1;
                        rows.extend;
                        rows(rows.last) := row;


                for cur1 in (select PERM_VAL_NM, PERM_VAL_DESC_TXT, item_nm, item_long_nm from  VW_NCI_DE_PV where de_item_id = cur.item_id and de_ver_nr = cur.ver_nr) loop
                  row := t_row();
                ihook.setColumnValue (row, 'Q_PUB_ID', v_id);
                ihook.setColumnValue (row, 'Q_VER_NR', 1);
                ihook.setColumnValue (row, 'VM_NM', cur1.item_nm);
                ihook.setColumnValue (row, 'VM_LNM', cur1.item_long_nm);
                ihook.setColumnValue (row, 'VM_DEF', cur1.item_nm);
                ihook.setColumnValue (row, 'VALUE', cur1.perm_val_nm);
                ihook.setColumnValue (row, 'MEAN_TXT', cur1.item_long_nm);
                v_itemid := nci_11179.getItemId;
                ihook.setColumnValue (row, 'NCI_PUB_ID', v_itemid);
                ihook.setColumnValue (row, 'NCI_VER_NR', 1);

                 rowsvv.extend;
                rowsvv(rowsvv.last) := row;
                v_found := true;
              --  raise_application_error(-20000, 'Inside');
                end loop;
                 end loop;
   end loop;

--DESC_TXT
   -- raise_application_error(-20000, v_add);
        if (v_add > 0) then
                        action := t_actionrowset(rows, 'Questions (Base Object)', 2,0,'insert');
                        actions.extend;
                        actions(actions.last) := action;
        end if;

    if (v_found) then
    action := t_actionrowset(rowsvv, 'Question Valid Values (Hook)', 2,2,'insert');
    actions.extend;
    actions(actions.last) := action;
    end if;

    hookoutput.actions := actions;
    hookoutput.message := v_add || ' questions added.';
    end if;
end if;


  V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
  --insert into junk_debug values (sysdate, v_data_out);
  --commit;
END;



PROCEDURE spChngQuestTextVV (    v_data_in IN CLOB,    v_data_out OUT CLOB,    v_user_id in varchar2)
AS
    hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();
    actions t_actions := t_actions();
    action t_actionRowset;
    row t_row;
    rowrel t_row;
    row_sel t_row;
    rows  t_rows;
    row_ori t_row;
  action_rows       t_rows := t_rows();
  action_row		    t_row;
  rowset            t_rowset;
 question    t_question;
answer     t_answer;
answers     t_answers;
showrowset	t_showablerowset;
  rowform t_row;
v_found boolean;
  v_module_id integer;
  v_disp_ord integer;
  v_frm_id number;
  v_frm_ver_nr number(4,2);
  v_ref varchar2(255);
  v_add integer;
  i integer := 0;
  column  t_column;
  msg varchar2(4000);
BEGIN
  hookinput                    := Ihook.gethookinput (v_data_in);
  hookoutput.invocationnumber  := hookinput.invocationnumber;
  hookoutput.originalrowset    := hookinput.originalrowset;

 row_ori :=  hookInput.originalRowset.rowset(1);
 rows := t_rows();

 /*select frm_item_id, frm_ver_nr into v_frm_id, v_frm_Ver_nr from VW_NCI_MODULE_DE where nci_pub_id = ihook.getColumNValue(row_ori, 'NCI_PUB_ID') and nci_ver_nr = ihook.getColumNValue(row_ori, 'NCI_VER_NR');
 if (nci_form_mgmt.isUserAuth(v_frm_id, v_frm_ver_nr, v_user_id) = false) then
 raise_application_error(-20000,'You are not authorized to edit any question in this form.');
 end if;
 */
 select frm_item_id, frm_ver_nr into v_frm_id, v_frm_ver_nr from vw_nci_module_de where
nci_pub_id = ihook.getColumnValue(row_ori, 'Q_PUB_ID') and nci_ver_nr = ihook.getColumnValue(row_ori, 'Q_VER_NR');
 if (nci_form_mgmt.isUserAuth(v_frm_id, v_frm_ver_nr, v_user_id) = false) then
 raise_application_error(-20000,'You are not authorized to edit any valid value on this form.');
 end if;

 if hookInput.invocationNumber = 0 then


	    for cur in (select nm_id from alt_nms r where r.fld_delete= 0 and
        (item_id, ver_nr) in (select NCI_VAL_MEAN_ITEM_ID, NCI_VAL_MEAN_VER_NR from VW_NCI_DE_PV pv,
        NCI_ADMIN_ITEM_REL_ALT_KEY q where pv.DE_ITEM_ID = q.C_ITEM_id and pv.DE_VER_NR = q.c_ITEM_VER_NR and q.NCI_PUB_ID = ihook.getColumnValue(row_ori,'Q_PUB_ID')
        and q.NCI_VER_NR= ihook.getColumnValue(row_ori, 'Q_VER_NR') and pv.PERM_VAL_NM = ihook.getColumnValue(row_ori, 'VALUE'))) loop
		   row := t_row();
	   	   iHook.setcolumnvalue (ROW, 'NM_ID', cur.NM_id);
		   rows.extend;
		   rows (rows.last) := row;

 --raise_application_error(-20000,ihook.getColumNValue(row_ori, 'C_ITEM_ID'));
   v_found := true;
	    end loop;

	  if (v_found) then
      ANSWERS                    := T_ANSWERS();
    ANSWER                     := T_ANSWER(1, 1, 'Select Alternate Name');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
   --  ANSWERS                    := T_ANSWERS();
    ANSWER                     := T_ANSWER(2, 2, 'Set to Default VM Name');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
    QUESTION               := T_QUESTION('Change Value Meaning Text', ANSWERS);
    HOOKOUTPUT.QUESTION    := QUESTION;
       	 showrowset := t_showablerowset (rows, 'Alternate Names', 2, 'single');
       	 hookoutput.showrowset := showrowset;
        else
        hookoutput.message := 'No alternate names found.';
     end if;
 ELSE

            if (hookinput.answerId = 1) then
            row_sel := hookinput.selectedRowset.rowset(1);
            select nm_desc into v_ref from alt_nms where nm_id = ihook.getColumnValue(row_sel, 'NM_ID');
            else   -- 2 means set default

         select item_nm into v_ref from admin_item where item_id = ihook.getColumnValue(row_ori, 'VAL_MEAN_ITEM_ID') and ver_nr = ihook.getColumnValue(row_ori, 'VAL_MEAN_VER_NR');
/*
           select pv.item_nm into v_ref from VW_NCI_DE_PV pv,
        NCI_ADMIN_ITEM_REL_ALT_KEY q where pv.DE_ITEM_ID = q.C_ITEM_id and pv.DE_VER_NR = q.c_ITEM_VER_NR and q.NCI_PUB_ID = ihook.getColumnValue(row_ori,'Q_PUB_ID')
        and q.NCI_VER_NR= ihook.getColumnValue(row_ori, 'Q_VER_NR') and pv.PERM_VAL_NM = ihook.getColumnValue(row_ori, 'VALUE');*/
           -- select nm_desc into v_ref from alt_nms where nm_id = ihook.getColumnValue(row_sel, 'NM_ID');

            end if;
            ihook.setColumnValue(row_ori, 'MEAN_TXT', v_ref);

            rows:= t_rows();
            rows.extend;
            rows(rows.last) := row_ori;

            action             := t_actionrowset(rows, 'Question Valid Values (Hook)', 2, 0,'update');
            actions.extend;
            actions(actions.last) := action;
     hookoutput.actions    := actions;
    END IF;

  V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
END;


PROCEDURE spChngQuestDefVV (    v_data_in IN CLOB,    v_data_out OUT CLOB,    v_user_id in varchar2)
AS
    hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();
    actions t_actions := t_actions();
    action t_actionRowset;
    row t_row;
    rowrel t_row;
    row_sel t_row;
    rows  t_rows;
    row_ori t_row;
  action_rows       t_rows := t_rows();
  action_row		    t_row;
  rowset            t_rowset;
 question    t_question;
answer     t_answer;
answers     t_answers;
showrowset	t_showablerowset;
  rowform t_row;
v_found boolean;
  v_module_id integer;
  v_disp_ord integer;
  v_frm_id number;
  v_frm_ver_nr number(4,2);
  v_ref varchar2(255);
  v_add integer;
  i integer := 0;
  column  t_column;
  msg varchar2(4000);
BEGIN
  hookinput                    := Ihook.gethookinput (v_data_in);
  hookoutput.invocationnumber  := hookinput.invocationnumber;
  hookoutput.originalrowset    := hookinput.originalrowset;

 row_ori :=  hookInput.originalRowset.rowset(1);
 rows := t_rows();

 /*select frm_item_id, frm_ver_nr into v_frm_id, v_frm_Ver_nr from VW_NCI_MODULE_DE where nci_pub_id = ihook.getColumNValue(row_ori, 'NCI_PUB_ID') and nci_ver_nr = ihook.getColumNValue(row_ori, 'NCI_VER_NR');
 if (nci_form_mgmt.isUserAuth(v_frm_id, v_frm_ver_nr, v_user_id) = false) then
 raise_application_error(-20000,'You are not authorized to edit any question in this form.');
 end if;
 */
  select frm_item_id, frm_ver_nr into v_frm_id, v_frm_ver_nr from vw_nci_module_de where
nci_pub_id = ihook.getColumnValue(row_ori, 'Q_PUB_ID') and nci_ver_nr = ihook.getColumnValue(row_ori, 'Q_VER_NR');
 if (nci_form_mgmt.isUserAuth(v_frm_id, v_frm_ver_nr, v_user_id) = false) then
 raise_application_error(-20000,'You are not authorized to edit any valid value on this form.');
 end if;
 if hookInput.invocationNumber = 0 then


	    for cur in (select def_id from alt_def r where r.fld_delete= 0 and
        (item_id, ver_nr) in (select NCI_VAL_MEAN_ITEM_ID, NCI_VAL_MEAN_VER_NR from VW_NCI_DE_PV pv,
        NCI_ADMIN_ITEM_REL_ALT_KEY q where pv.DE_ITEM_ID = q.C_ITEM_id and pv.DE_VER_NR = q.c_ITEM_VER_NR and q.NCI_PUB_ID = ihook.getColumnValue(row_ori,'Q_PUB_ID')
        and q.NCI_VER_NR= ihook.getColumnValue(row_ori, 'Q_VER_NR') and pv.PERM_VAL_NM = ihook.getColumnValue(row_ori, 'VALUE'))) loop
		   row := t_row();
	   	   iHook.setcolumnvalue (ROW, 'DEF_ID', cur.DEF_id);
		   rows.extend;
		   rows (rows.last) := row;

 --raise_application_error(-20000,ihook.getColumNValue(row_ori, 'C_ITEM_ID'));
   v_found := true;
	    end loop;

	  if (v_found) then
      ANSWERS                    := T_ANSWERS();
    ANSWER                     := T_ANSWER(1, 1, 'Select Alternate Description');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
     ANSWER                     := T_ANSWER(2, 2, 'Set to Default VM Description');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
    QUESTION               := T_QUESTION('Change VM Alternate Description', ANSWERS);
    HOOKOUTPUT.QUESTION    := QUESTION;
       	 showrowset := t_showablerowset (rows, 'Alternate Definitions', 2, 'single');
       	 hookoutput.showrowset := showrowset;
        else
        hookoutput.message := 'No alternate definitions found.';
     end if;
 ELSE

        if (hookinput.answerId = 1) then
             row_sel := hookinput.selectedRowset.rowset(1);
        select def_desc into v_ref from alt_def where def_id = ihook.getColumnValue(row_sel, 'DEF_ID');

        else -- if 2 then
         select item_desc into v_ref from admin_item where item_id = ihook.getColumnValue(row_ori, 'VAL_MEAN_ITEM_ID') and ver_nr = ihook.getColumnValue(row_ori, 'VAL_MEAN_VER_NR');

        end if;
            ihook.setColumnValue(row_ori, 'DESC_TXT', v_ref);
            rows:= t_rows();
            rows.extend;
            rows(rows.last) := row_ori;

            action             := t_actionrowset(rows, 'Question Valid Values (Hook)', 2, 0,'update');
            actions.extend;
            actions(actions.last) := action;


    hookoutput.actions    := actions;
    END IF;

  V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
END;


PROCEDURE spQuestRemoveDE ( v_data_in IN CLOB, v_data_out OUT CLOB, v_usr_id  IN varchar2) as
    hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();
    actions t_actions := t_actions();
    action t_actionRowset;
    row_ori  t_row;
    row  t_row;
    rows t_rows;
    v_item_id  number;
    v_ver_nr  number(4,2);
begin
    -- Standard header
    hookInput                    := Ihook.gethookinput (v_data_in);
    hookOutput.invocationnumber  := hookInput.invocationnumber;
    hookOutput.originalrowset    := hookInput.originalrowset;

    -- Get the selected row
    row_ori :=  hookInput.originalRowset.rowset(1);

    -- if no DE already, give an error message
    if (ihook.getColumnValue(row_ori, 'C_ITEM_ID') is null) then
        raise_application_error(-20000,'No CDE attached..');
        return;
    end if;

      select p_item_id, p_item_ver_nr into v_item_id, v_ver_nr from nci_admin_item_rel where rel_typ_id = 61 and
       c_item_id = ihook.getColumnValue(row_ori, 'P_ITEM_ID') and c_item_ver_nr = ihook.getColumnValue(row_ori, 'P_ITEM_VER_NR');

    -- Check if user is authorized to edit
    if (nci_11179_2.isUserAuth(v_item_id, v_ver_nr, v_usr_id) = false) then
        raise_application_error(-20000, 'You are not authorized to insert/update or delete in this context. ');
        return;
    end if;

   ihook.setColumnValue(row_ori,'C_ITEM_ID','');
   ihook.setColumnValue(row_ori,'C_ITEM_VER_NR','');

    rows := t_rows();    rows.extend;    rows(rows.last) := row_ori;
    action := t_actionrowset(rows, 'Questions (Base Object)', 2,2,'update');
        actions.extend;
        actions(actions.last) := action;


        hookoutput.message := 'CDE removed.' ;
        hookoutput.actions := actions;
            V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);

--insert into junk_debug (id, test) values (sysdate, v_data_out);
--commit;

end;

end;
/


DROP PACKAGE BODY ONEDATA_WA.NCI_IMPORT;

CREATE OR REPLACE PACKAGE BODY ONEDATA_WA.nci_import AS

procedure spValCDEImport (v_data_in in clob, v_data_out out clob, v_usr_id in varchar2)
as
    hookInput           t_hookInput;
    hookOutput           t_hookOutput := t_hookOutput();
    showRowset     t_showableRowset;

    rows      t_rows;
    row          t_row;
    row_ori t_row;
    row_cur t_row;
    v_item_id number;
    v_ver_nr number(4,2);
 action t_actionRowset;
 v_val_ind  boolean;
   actions t_actions := t_actions();
begin


    hookInput := ihook.getHookInput(v_data_in);
    hookOutput.invocationNumber := hookInput.invocationNumber;
    hookOutput.originalRowset := hookInput.originalRowset;
  rows := t_rows();

for i in 1..hookinput.originalRowset.rowset.count loop

    row_ori := hookInput.originalRowset.rowset(i);
    if (ihook.getColumnValue(row_ori, 'CTL_VAL_STUS') <> 'PROCESSED') then
        ihook.setColumnValue(row_ori, 'CTL_VAL_MSG', '');
        v_val_ind := true;
        nci_dec_mgmt.createValAIWithConcept(row_ori, 1,5,'V', 'DROP-DOWN', actions) ;
        nci_dec_mgmt.createValAIWithConcept(row_ori, 2,6,'V', 'DROP-DOWN', actions) ;
        nci_vd.createValAIWithConcept(row_ori, 3,7,'V', 'DROP-DOWN', actions) ;

        nci_dec_mgmt.spDECValCreateImport(row_ori, 'V', actions, v_val_ind);
        nci_vd.spVDValCreateImport(row_ori, 'V', actions, v_val_ind);
        nci_chng_mgmt.spDEValCreateImport(row_ori, 'V', actions, v_val_ind);

   --    raise_application_error(-20000, ihook.getColumnValue(row_ori, 'DE_CONC_VER_NR_FND'));
        if (v_val_ind = false) then 
            ihook.setColumnValue(row_ori, 'CTL_VAL_STUS', 'ERRORS');
        else
                ihook.setColumnValue(row_ori, 'CTL_VAL_STUS', 'VALIDATED');
                ihook.setColumnValue(row_ori, 'CTL_VAL_MSG', 'No Errors');                      

        end if;
    rows.extend; rows(rows.last) := row_ori;
   end if; -- only if not processed     
end loop;
    action := t_actionrowset(rows, 'CDE Import', 2,10,'update');
        actions.extend;
        actions(actions.last) := action;
        hookoutput.actions := actions;
    V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
 --nci_util.debugHook('GENERAL',v_data_out);

end;


procedure spPostCDEImport (v_data_in in clob, v_data_out out clob, v_usr_id in varchar2)
as
    hookInput           t_hookInput;
    hookOutput           t_hookOutput := t_hookOutput();
    showRowset     t_showableRowset;

    rows      t_rows;
    row          t_row;
    row_ori t_row;
    row_cur t_row;
    v_val_ind boolean;
    v_item_id number;
    v_ver_nr number(4,2);
 action t_actionRowset;
   actions t_actions := t_actions();
begin


    hookInput := ihook.getHookInput(v_data_in);
    hookOutput.invocationNumber := hookInput.invocationNumber;
    hookOutput.originalRowset := hookInput.originalRowset;

    row_ori := hookInput.originalRowset.rowset(1);
    v_val_ind := true;
    if (ihook.getColumnValue(row_ori, 'DE_CONC_ITEM_ID') is null) then
      nci_dec_mgmt.createValAIWithConcept(row_ori, 1,5,'V', 'STRING', actions) ;
    nci_dec_mgmt.createValAIWithConcept(row_ori, 2,6,'V', 'STRING', actions) ;
    end if;

    if (ihook.getColumnValue(row_ori, 'VAL_DOM_ITEM_ID') is null) then

    nci_vd.createValAIWithConcept(row_ori, 3,7,'V', 'STRING', actions) ;
    end if;

    -- Added to combine decompose and validation in one step
    nci_dec_mgmt.spDECValCreateImport(row_ori, 'V', actions, v_val_ind);
    nci_vd.spVDValCreateImport(row_ori, 'V', actions, v_val_ind);
    nci_chng_mgmt.spDEValCreateImport(row_ori, 'V', actions, v_val_ind);

   --    raise_application_error(-20000, ihook.getColumnValue(row_ori, 'DE_CONC_VER_NR_FND'));
    if (v_val_ind = false) then 
            ihook.setColumnValue(row_ori, 'CTL_VAL_STUS', 'ERRORS');
    else
                ihook.setColumnValue(row_ori, 'CTL_VAL_STUS', 'VALIDATED');
                ihook.setColumnValue(row_ori, 'CTL_VAL_MSG', 'No Errors');                      

    end if;
   -- end of validation

    rows := t_rows();
    rows.extend; rows(rows.last) := row_ori;

    action := t_actionrowset(rows, 'CDE Import', 2,10,'update');
    actions.extend;
    actions(actions.last) := action;
    hookoutput.actions := actions;
    V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
-- nci_util.debugHook('GENERAL',v_data_out);


end;

procedure spCreatePVVMImport (v_data_in in clob, v_data_out out clob, v_usr_id in varchar2)
as
    hookInput           t_hookInput;
    hookOutput           t_hookOutput := t_hookOutput();
    showRowset     t_showableRowset;

    rows      t_rows;
    row          t_row;
    row_ori t_row;
    row_cur t_row;
    v_item_id number;
    v_ver_nr number(4,2);
    v_val_ind  boolean;
 action t_actionRowset;
   actions t_actions := t_actions();
begin


    hookInput := ihook.getHookInput(v_data_in);
    hookOutput.invocationNumber := hookInput.invocationNumber;
    hookOutput.originalRowset := hookInput.originalRowset;

for i in 1..hookinput.originalRowset.rowset.count loop
    row_ori := hookInput.originalRowset.rowset(i);
    v_val_ind := true;
    ihook.setColumnValue(row_ori,'CTL_VAL_MSG', '');

    if (ihook.getColumnValue(row_ori, 'CTL_VAL_STUS') = 'VALIDATED') then
       nci_pv_vm.spPVVMImport ( row_ori,actions );
       rows := t_rows();
    rows.extend; rows(rows.last) := row_ori;
    action := t_actionrowset(rows, 'PV VM Import', 2,10,'update');
    end if;
end loop;

        actions.extend;
        actions(actions.last) := action;
        hookoutput.actions := actions;
    V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
 nci_util.debugHook('GENERAL',v_data_out);
end;

--  PV/VM


procedure spValPVVMImport (v_data_in in clob, v_data_out out clob, v_usr_id in varchar2)
as
    hookInput           t_hookInput;
    hookOutput           t_hookOutput := t_hookOutput();
    showRowset     t_showableRowset;

    rows      t_rows;
    row          t_row;
    row_ori t_row;
    row_cur t_row;
    v_item_id number;
    v_ver_nr number(4,2);
 action t_actionRowset;
 v_val_ind  boolean;
   actions t_actions := t_actions();
begin


    hookInput := ihook.getHookInput(v_data_in);
    hookOutput.invocationNumber := hookInput.invocationNumber;
    hookOutput.originalRowset := hookInput.originalRowset;
  rows := t_rows();

for i in 1..hookinput.originalRowset.rowset.count loop

    row_ori := hookInput.originalRowset.rowset(i);
    if (ihook.getColumnValue(row_ori, 'CTL_VAL_STUS') <> 'PROCESSED') then
        ihook.setColumnValue(row_ori, 'CTL_VAL_MSG', '');
        spPVVMValidate(row_ori);
        rows.extend; rows(rows.last) := row_ori;
   end if; -- only if not processed     
end loop;
    action := t_actionrowset(rows, 'PV VM Import', 2,10,'update');
        actions.extend;
        actions(actions.last) := action;
        hookoutput.actions := actions;
    V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
 --nci_util.debugHook('GENERAL',v_data_out);

end;


procedure spPostPVVMImport (v_data_in in clob, v_data_out out clob, v_usr_id in varchar2)
as
    hookInput           t_hookInput;
    hookOutput           t_hookOutput := t_hookOutput();

    rows      t_rows;
    row          t_row;
    row_ori t_row;

  action t_actionRowset;
   actions t_actions := t_actions();
begin

-- ITEM_2_ID : Value Domain public Id; ITEM_2_VER_NR: Value Domain Version; ITEM_2_LONG_NM: Used to see if Concept or String - VM String Type

    hookInput := ihook.getHookInput(v_data_in);
    hookOutput.invocationNumber := hookInput.invocationNumber;
    hookOutput.originalRowset := hookInput.originalRowset;

    row_ori := hookInput.originalRowset.rowset(1);
    spPVVMValidate(row_ori);
    rows := t_rows();
    rows.extend; rows(rows.last) := row_ori;

    action := t_actionrowset(rows, 'PV VM Import', 2,10,'update');
    actions.extend;
    actions(actions.last) := action;
    hookoutput.actions := actions;
    V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
-- nci_util.debugHook('GENERAL',v_data_out);


end;


procedure spPVVMValidate (row_ori in out t_row)
as
  actions t_actions := t_actions();

    rows      t_rows;
    row          t_row;
    v_val_ind boolean;
    v_item_id number;
    v_ver_nr number(4,2);
    v_temp integer;
 begin

-- ITEM_2_ID : Value Domain public Id; ITEM_2_VER_NR: Value Domain Version; ITEM_2_LONG_NM: Used to see if Concept or String - VM String Type
    v_val_ind := true;

-- If string type is CONCEPTS, then decompose and check to make sure atleast one concept is valid
    if (upper(ihook.getColumnValue(row_ori, 'ITEM_2_LONG_NM')) = 'CONCEPTS') then
       nci_dec_mgmt.createValAIWithConcept(row_ori, 1,53,'V', 'STRING', actions) ;
       if (ihook.getColumnValue(row_ori, 'CNCPT_1_ITEM_ID_1') is null) then
             ihook.setColumnValue(row_ori, 'CTL_VAL_MSG', 'No valid concepts specified for Value Meaning.');                      
        v_val_ind := false;
       end if;
    end if;

    -- If string type is ID, make sure ID is valid.
    if (upper(ihook.getColumnValue(row_ori, 'ITEM_2_LONG_NM')) = 'ID') then
     select count(*) into v_temp from admin_item where item_id = ihook.getColumnValue(row_ori, 'CNCPT_CONCAT_STR_1');
     if (v_temp = 0) then
             ihook.setColumnValue(row_ori, 'CTL_VAL_MSG', 'Specified VM ID is not found.');                      
        v_val_ind := false;
       end if;
    end if;

    -- check if value already exists for the VD
    for cur in (select * from perm_val where val_dom_item_id= ihook.getColumnValue(row_ori, 'ITEM_2_ID')
    and val_dom_ver_nr = ihook.getColumnValue(row_ori, 'ITEM_2_VER_NR') and upper(perm_val_nm) = upper(ihook.getColumnValue(row_ori, 'PERM_VAL_NM'))) loop
       ihook.setColumnValue(row_ori, 'CTL_VAL_MSG',       ihook.getColumnValue(row_ori, 'CTL_VAL_MSG') || ';' ||  'Value already exists in the specified Value Domain');                      
        v_val_ind := false;
    end loop;

   -- nci_pv_vm.spValCreateImport(row_ori, 'V', actions, v_val_ind);
           if (v_val_ind = false) then 
            ihook.setColumnValue(row_ori, 'CTL_VAL_STUS', 'ERRORS');
    else
                ihook.setColumnValue(row_ori, 'CTL_VAL_STUS', 'VALIDATED');
                ihook.setColumnValue(row_ori, 'CTL_VAL_MSG', 'No Errors');                      

    end if;
   -- end of validation

   for cur in (select * from value_dom where item_id = ihook.getColumnValue(row_ori, 'ITEM_2_ID') and ver_nr = ihook.getColumnValue(row_ori, 'ITEM_2_VER_NR')) loop
        ihook.setColumnValue(row_ori, 'CONC_DOM_ITEM_ID', cur.CONC_DOM_ITEM_ID);
        ihook.setColumnValue(row_ori, 'CONC_DOM_VER_NR', cur.CONC_DOM_VER_NR);
   end loop;

   for cur in (select * from admin_item where item_id = ihook.getColumnValue(row_ori, 'ITEM_2_ID') and ver_nr = ihook.getColumnValue(row_ori, 'ITEM_2_VER_NR')) loop
        ihook.setColumnValue(row_ori, 'CNTXT_ITEM_ID', cur.CNTXT_ITEM_ID);
        ihook.setColumnValue(row_ori, 'CNTXT_VER_NR', cur.CNTXT_VER_NR);
   end loop;



end;


procedure spCreateCDEImport (v_data_in in clob, v_data_out out clob, v_usr_id in varchar2)
as
    hookInput           t_hookInput;
    hookOutput           t_hookOutput := t_hookOutput();
    showRowset     t_showableRowset;

    rows      t_rows;
    row          t_row;
    row_ori t_row;
    row_cur t_row;
    v_item_id number;
    v_ver_nr number(4,2);
    v_val_ind  boolean;
 action t_actionRowset;
   actions t_actions := t_actions();
begin


    hookInput := ihook.getHookInput(v_data_in);
    hookOutput.invocationNumber := hookInput.invocationNumber;
    hookOutput.originalRowset := hookInput.originalRowset;

for i in 1..hookinput.originalRowset.rowset.count loop
    row_ori := hookInput.originalRowset.rowset(i);
    v_val_ind := true;
    ihook.setColumnValue(row_ori,'CTL_VAL_MSG', '');

    if (ihook.getColumnValue(row_ori, 'CTL_VAL_STUS') = 'VALIDATED') then
        if (ihook.getColumnValue(row_ori, 'DE_CONC_ITEM_ID') is null and ihook.getColumnValue(row_ori, 'DE_CONC_ITEM_ID_FND') is null) then -- only go thru creating new if not specified and not existing
            nci_dec_mgmt.spDECValCreateImport(row_ori, 'C', actions, v_val_ind);
        end if;
        if (ihook.getColumnValue(row_ori, 'VAL_DOM_ITEM_ID') is null) then -- only go thru creating new if not specified
            nci_vd.spVDValCreateImport(row_ori, 'C', actions, v_val_ind);
        end if;

       nci_chng_mgmt.spDEValCreateImport(row_ori, 'C', actions, v_val_ind);
        if (v_val_ind = true) then
        iHook.setColumnValue (row_ori, 'CTL_VAL_STUS', 'PROCESSED');
        end if;
    rows := t_rows();
    rows.extend; rows(rows.last) := row_ori;
    action := t_actionrowset(rows, 'CDE Import', 2,10,'update');
    end if;
end loop;

        actions.extend;
        actions(actions.last) := action;
        hookoutput.actions := actions;
    V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
 nci_util.debugHook('GENERAL',v_data_out);
end;

end;

/


DROP PACKAGE BODY ONEDATA_WA.NCI_POST_HOOK;

CREATE OR REPLACE PACKAGE BODY ONEDATA_WA.NCI_POST_HOOK AS

procedure spModRestore ( v_data_in in clob, v_data_out out clob, v_user_id varchar2, v_mode in varchar2)
as
 hookInput        t_hookInput;
    hookOutput       t_hookOutput := t_hookOutput ();
    row_ori          t_row;
  v_temp integer;
  actions t_actions := t_actions();
    action t_actionRowset;
    rows  t_rows;
  BEGIN
    hookinput := Ihook.gethookinput (v_data_in);
    hookoutput.invocationnumber := hookinput.invocationnumber;
    hookoutput.originalrowset := hookinput.originalrowset;

  if (v_mode ='M') then

    row_ori := hookInput.originalRowset.rowset (1);
    select nvl(max(disp_ord),-1) into v_temp from nci_admin_item_rel where rel_typ_id = 61 and p_item_id = ihook.getColumnValue(row_ori, 'P_ITEM_ID')
    and p_item_ver_nr = ihook.getColumnValue(row_ori, 'P_ITEM_VER_NR') and nvl(fld_delete,0) = 0;
 --    raise_application_error(-20000, v_temp);

 update nci_admin_item_rel set disp_ord = v_temp+1 where p_item_id = ihook.getColumnValue(row_ori, 'P_ITEM_ID')
    and p_item_ver_nr = ihook.getColumnValue(row_ori, 'P_ITEM_VER_NR') and rel_typ_id = 61 and C_item_id = ihook.getColumnValue(row_ori, 'C_ITEM_ID')
    and C_item_ver_nr = ihook.getColumnValue(row_ori, 'C_ITEM_VER_NR');
    commit;
 --ihook.setColumnValue(row_ori, 'DISP_ORD', v_temp+1);
  --  rows := t_rows();
   -- rows.extend;
     --       rows(rows.last) := row_ori;

 --action := t_actionRowset(rows, 'Generic AI Relationship', 2, 1, 'restore');
  --  actions.extend; actions(actions.last) := action;
  --hookoutput.actions:= actions;

end if;
 V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
end;


procedure spQuestRestore ( v_data_in in clob, v_data_out out clob, v_user_id varchar2, v_mode in varchar2)
as
 hookInput        t_hookInput;
    hookOutput       t_hookOutput := t_hookOutput ();
    row_ori          t_row;
  v_temp integer;
  actions t_actions := t_actions();
    action t_actionRowset;
    rows  t_rows;
  BEGIN
    hookinput := Ihook.gethookinput (v_data_in);
    hookoutput.invocationnumber := hookinput.invocationnumber;
    hookoutput.originalrowset := hookinput.originalrowset;

  if (v_mode ='Q') then

    row_ori := hookInput.originalRowset.rowset (1);
    select nvl(max(disp_ord),-1) into v_temp from nci_admin_item_rel_alt_key where rel_typ_id = 63 and p_item_id = ihook.getColumnValue(row_ori, 'P_ITEM_ID')
    and p_item_ver_nr = ihook.getColumnValue(row_ori, 'P_ITEM_VER_NR') and nvl(fld_delete,0) = 0;
 --    raise_application_error(-20000, v_temp);


 update nci_admin_item_rel_alt_key set disp_ord = v_temp+1 where NCI_PUB_ID = ihook.getColumnValue(row_ori, 'NCI_PUB_ID')
    and NCI_VER_NR = ihook.getColumnValue(row_ori, 'NCI_VER_NR');
    commit;
 --ihook.setColumnValue(row_ori, 'DISP_ORD', v_temp+1);
  --  rows := t_rows();
   -- rows.extend;
     --       rows(rows.last) := row_ori;

 --action := t_actionRowset(rows, 'Generic AI Relationship', 2, 1, 'restore');
  --  actions.extend; actions(actions.last) := action;
  --hookoutput.actions:= actions;

end if;
 V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
end;

procedure spQuestVVRestore ( v_data_in in clob, v_data_out out clob, v_user_id varchar2, v_mode in varchar2)
as
 hookInput        t_hookInput;
    hookOutput       t_hookOutput := t_hookOutput ();
    row_ori          t_row;
  v_temp integer;
  actions t_actions := t_actions();
    action t_actionRowset;
    rows  t_rows;
  BEGIN
   hookinput := Ihook.gethookinput (v_data_in);
    hookoutput.invocationnumber := hookinput.invocationnumber;
    hookoutput.originalrowset := hookinput.originalrowset;

  if (v_mode ='V') then

    row_ori := hookInput.originalRowset.rowset (1);
    select nvl(max(disp_ord),-1) into v_temp from nci_quest_valid_value where  q_pub_id = ihook.getColumnValue(row_ori, 'Q_PUB_ID')
    and q_ver_nr = ihook.getColumnValue(row_ori, 'Q_VER_NR') and nvl(fld_delete,0) = 0;
 --    raise_application_error(-20000, v_temp);


 update NCI_QUEST_VALID_VALUE set disp_ord = v_temp+1 where NCI_PUB_ID = ihook.getColumnValue(row_ori, 'NCI_PUB_ID')
    and NCI_VER_NR = ihook.getColumnValue(row_ori, 'NCI_VER_NR');
    commit;

end if;
 V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
end;

procedure spRefDocInsUpd ( v_data_in in clob, v_data_out out clob, v_user_id varchar2)
as
hookInput        t_hookInput;
    hookOutput       t_hookOutput := t_hookOutput ();
    row_ori          t_row;

  BEGIN
    hookinput := Ihook.gethookinput (v_data_in);
    hookoutput.invocationnumber := hookinput.invocationnumber;
    hookoutput.originalrowset := hookinput.originalrowset;

    row_ori := hookInput.originalRowset.rowset (1);
   -- raise_application_error(-20000, ihook.getColumnValue(row_ori,'REF_TYP_ID'));
  if (ihook.getColumnValue(row_ori,'REF_TYP_ID') = 80 or ihook.getColumnOldValue(row_ori,'REF_TYP_ID') = 80) then
    raise_application_error(-20000,'You cannot insert or update Preferred Question Text from Reference Documents. Please use Section 4 - Relational/Representation Attributes.');
 end if;

 V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
end;


procedure spPVUpd ( v_data_in in clob, v_data_out out clob, v_user_id varchar2)
as
hookInput        t_hookInput;
    hookOutput       t_hookOutput := t_hookOutput ();
    row_ori          t_row;
    v_item_id number;
    v_ver_nr number(4,2);
  BEGIN
    hookinput := Ihook.gethookinput (v_data_in);
    hookoutput.invocationnumber := hookinput.invocationnumber;
    hookoutput.originalrowset := hookinput.originalrowset;

    row_ori := hookInput.originalRowset.rowset (1);
   v_item_id := ihook.getColumnValue(row_ori, 'VAL_DOM_ITEM_ID');
        v_ver_nr := ihook.getColumnValue(row_ori, 'VAL_DOM_VER_NR');

     if (nci_11179_2.isUserAuth(v_item_id, v_ver_nr, v_user_id) = false) then
     raise_application_error(-20000, 'You are not authorized to insert/update or delete in this context. ');
        return;
    end if;

for cur in (select * from vw_admin_stus where ihook.getColumnValue(row_ori, 'PERM_VAL_END_DT') is not null and ihook.getColumnValue(row_ori, 'PERM_VAL_END_DT') < nvl(ihook.getColumnValue(row_ori, 'PERM_VAL_BEG_DT'), sysdate) ) loop
      raise_application_error(-20000, 'Expiration date has to be the same or greater than Effective date.');
    return;
end loop;

 V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
end;



procedure spCSIUpd ( v_data_in in clob, v_data_out out clob, v_user_id varchar2)
as
hookInput        t_hookInput;
    hookOutput       t_hookOutput := t_hookOutput ();
    row_ori          t_row;
    v_item_id number;
    v_ver_nr number(4,2);
  BEGIN
    hookinput := Ihook.gethookinput (v_data_in);
    hookoutput.invocationnumber := hookinput.invocationnumber;
    hookoutput.originalrowset := hookinput.originalrowset;

    row_ori := hookInput.originalRowset.rowset (1);
  if (nci_11179_2.isCSParentCSIValid(row_ori) = false) then
      raise_application_error(-20000, 'Parent CSI should belong to the same Classification Scheme as specified.');
  end if;

 V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
end;


-- Can only add Components if Derivation Rule is set
procedure spDervCompIns ( v_data_in in clob, v_data_out out clob, v_user_id varchar2)
as
hookInput        t_hookInput;
    hookOutput       t_hookOutput := t_hookOutput ();
    row_ori          t_row;

  BEGIN
    hookinput := Ihook.gethookinput (v_data_in);
    hookoutput.invocationnumber := hookinput.invocationnumber;
    hookoutput.originalrowset := hookinput.originalrowset;

    row_ori := hookInput.originalRowset.rowset (1);
    for cur in (select * from de where item_id = ihook.getColumnValue(row_ori, 'P_ITEM_ID') and ver_nr = ihook.getColumnValue(row_ori, 'P_ITEM_VER_NR')
    and DERV_RUL is null) loop
    raise_application_error(-20000,'Please set the Derivation Rule first.');
 end loop;

 V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
end;


-- AI Insert
procedure spAIIns ( v_data_in in clob, v_data_out out clob)
as
hookInput        t_hookInput;
    hookOutput       t_hookOutput := t_hookOutput ();
    row_ori          t_row;

  BEGIN
    hookinput := Ihook.gethookinput (v_data_in);
    hookoutput.invocationnumber := hookinput.invocationnumber;
    hookoutput.originalrowset := hookinput.originalrowset;

    row_ori := hookInput.originalRowset.rowset (1);

    for cur in (select * from vw_admin_stus where stus_id = nvl(ihook.getColumnValue(row_ori, 'ADMIN_STUS_ID'),-1) and upper(stus_nm) like '%RETIRED%'
    and ihook.getColumnValue(row_ori, 'UNTL_DT') is null) loop
    raise_application_error(-20000,'Cannot retire an Administered Item without expiration date.');
    return;
    end loop;

for cur in (select * from vw_admin_stus where stus_id = nvl(ihook.getColumnValue(row_ori, 'ADMIN_STUS_ID'),-1) and upper(stus_nm) like '%RETIRED%'
and ihook.getColumnValue(row_ori, 'UNTL_DT') is not null and ihook.getColumnValue(row_ori, 'UNTL_DT') < nvl(ihook.getColumnValue(row_ori, 'EFF_DT'), sysdate) ) loop
 raise_application_error(-20000, 'Expiration date has to be the same or greater than Effective date.');
    return;
end loop;

for cur in (select ai.item_id item_id from admin_item ai
            where
            trim(ai.ITEM_LONG_NM)=trim(ihook.getColumnValue(row_ori,'ITEM_LONG_NM'))
        --    and  ai.ver_nr =  ihook.getColumnValue(rowai, 'VER_NR')
            and ai.cntxt_item_id = ihook.getColumnValue(row_ori, 'CNTXT_ITEM_ID')
            and  ai.cntxt_ver_nr = ihook.getColumnValue(row_ori, 'CNTXT_VER_NR')
            and ai.item_id <>  nvl(ihook.getColumnValue(row_ori, 'ITEM_ID'),0)
            and ai.admin_item_typ_id = ihook.getColumnValue(row_ori, 'ADMIN_ITEM_TYP_ID') )
            loop
               raise_application_error(-20000, 'Duplicate found based on context/short name: ' || cur.item_id || chr(13));
                return;
            end loop;


 V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
end;



PROCEDURE            spAISTUpd (
    v_data_in    IN     CLOB,
    v_data_out      OUT CLOB,
    v_usr_id in varchar2)
AS
    hookInput        t_hookInput;
    hookOutput       t_hookOutput := t_hookOutput ();
    actions          t_actions := t_actions ();
    action           t_actionRowset;
    row              t_row;
    rows             t_rows;
    row_ori          t_row;
    action_rows      t_rows := t_rows ();
    action_row       t_row;
    rowset           t_rowset;
    v_add            INTEGER := 0;
    v_action_typ     VARCHAR2 (30);
    v_temp           VARCHAR2 (255);
    v_item_id        NUMBER;
    v_ver_nr         NUMBER (4, 2);
    v_nm_id          NUMBER;
    v_cntxt_id       NUMBER;
    v_cntxt_ver_nr   NUMBER (4, 2);
    i                INTEGER := 0;
    column           t_column;
    v_item_nm        VARCHAR2 (255);
    v_item_def       VARCHAR2 (4000);
    v_item_desc       VARCHAR2 (4000);
    v_admin_item_typ    number;
    msg              VARCHAR2 (4000);
BEGIN
    hookinput := Ihook.gethookinput (v_data_in);
    hookoutput.invocationnumber := hookinput.invocationnumber;
    hookoutput.originalrowset := hookinput.originalrowset;
    rows := t_rows ();

    row_ori := hookInput.originalRowset.rowset (1);
    v_item_id := ihook.getColumnValue (row_ori, 'ITEM_ID');
    v_ver_nr := ihook.getColumnValue (row_ori, 'VER_NR');

  if (nci_11179_2.isUserAuth(v_item_id, v_ver_nr, v_usr_id) = false) then
        raise_application_error(-20000, 'You are not authorized to insert/update or delete in this context. ');
        return;
    end if;


    -- Tracker 554
  --  raise_application_error(-20000, hookinput.originalRowset.tablename);

  if (hookinput.originalRowset.tablename = 'ADMIN_ITEM') then
    if (ihook.getColumnValue (row_ori, 'ITEM_DESC') <>  ihook.getColumnOldValue (row_ori, 'ITEM_DESC')
    --   and ihook.getColumnValue (row_ori, 'ADMIN_ITEM_TYP_ID') in (2,5,6,7,49,53)) then
       and ihook.getColumnValue (row_ori, 'ADMIN_ITEM_TYP_ID') in (2,5,6,7,53)) then
        raise_application_error(-20000, 'Definition for this Administered Item cannot be updated. ');
        return;
    end if;

    for cur in (select * from vw_admin_stus where stus_id = nvl(ihook.getColumnValue(row_ori, 'ADMIN_STUS_ID'),-1) and upper(stus_nm) like '%RETIRED%'
    and ihook.getColumnValue(row_ori, 'UNTL_DT') is null) loop
    raise_application_error(-20000,'Cannot retire an Administered Item without expiration date.');
    return;
    end loop;

 if (ihook.getColumnValue(row_ori, 'UNTL_DT') is not null and ihook.getColumnValue(row_ori, 'UNTL_DT') < nvl(ihook.getColumnValue(row_ori, 'EFF_DT'), sysdate) ) then
 raise_application_error(-20000, 'Expiration date has to be the same or greater than Effective date.');

    return;
end if;

for cur in (select ai.item_id item_id from admin_item ai
            where
            trim(ai.ITEM_LONG_NM)=trim(ihook.getColumnValue(row_ori,'ITEM_LONG_NM'))
        --    and  ai.ver_nr =  ihook.getColumnValue(rowai, 'VER_NR')
            and ai.cntxt_item_id = ihook.getColumnValue(row_ori, 'CNTXT_ITEM_ID')
            and  ai.cntxt_ver_nr = ihook.getColumnValue(row_ori, 'CNTXT_VER_NR')
            and ai.item_id <>  nvl(ihook.getColumnValue(row_ori, 'ITEM_ID'),0)
            and ai.admin_item_typ_id = ihook.getColumnValue(row_ori, 'ADMIN_ITEM_TYP_ID') )
            loop
               raise_application_error(-20000, 'Duplicate found based on context/short name: ' || cur.item_id || chr(13));
                return;
            end loop;


end if;

 if (hookinput.originalRowset.tablename = 'ADMIN_ITEM') then  -- Value domain/released without PV
    if (ihook.getColumnValue (row_ori, 'ADMIN_ITEM_TYP_ID')= 3 and ihook.getColumnValue(row_ori, 'ADMIN_STUS_ID') = 75) then
    for cur in (select item_id, ver_nr from value_dom where item_id = v_item_id and ver_nr = v_ver_nr and VAL_DOM_TYP_ID = 17) loop
      select count(*) into v_temp from perm_val where val_dom_item_id = v_item_id and val_dom_Ver_nr = v_ver_nr and nvl(fld_delete,0) = 0;
            if v_temp = 0 then
                raise_application_error(-20000, 'An Enumerated VD WFS cannot be Released if there are no permissible values.');
                return;
            end if;
    end loop;
    end if;
  end if;
    IF (hookinput.originalRowset.tablename = 'DE')
    THEN
        FOR cur
            IN (SELECT ai.item_id
                  FROM admin_item ai, de de
                 WHERE     ai.item_id = de.item_id
                       AND ai.ver_nr = de.ver_nr
                       AND de.de_conc_item_id =
                           ihook.getColumnValue (row_ori, 'DE_CONC_ITEM_ID')
                       AND de.de_conc_ver_nr =
                           ihook.getColumnValue (row_ori, 'DE_CONC_VER_NR')
                       AND de.val_dom_item_id =
                           ihook.getColumnValue (row_ori, 'VAL_DOM_ITEM_ID')
                       AND de.val_dom_ver_nr =
                           ihook.getColumnValue (row_ori, 'VAL_DOM_VER_NR')
                       AND de.item_id <> v_item_id
                       AND (ai.cntxt_item_id, ai.cntxt_ver_nr) IN
                               (SELECT ai1.cntxt_item_id, ai1.cntxt_ver_nr
                                  FROM admin_item ai1
                                 WHERE     item_id = v_item_id
                                       AND ver_nr = v_ver_nr))
        LOOP
            raise_application_error (-20000,
                                     'Duplicate DE found. ' || cur.item_id);
            RETURN;
        END LOOP;

        IF (   ihook.getColumnValue (row_ori, 'DE_CONC_ITEM_ID') <>
               ihook.getColumnOldValue (row_ori, 'DE_CONC_ITEM_ID')
            OR ihook.getColumnValue (row_ori, 'DE_CONC_VER_NR') <>
               ihook.getColumnOldValue (row_ori, 'DE_CONC_VER_NR')
            OR ihook.getColumnValue (row_ori, 'VAL_DOM_ITEM_ID') <>
               ihook.getColumnOldValue (row_ori, 'VAL_DOM_ITEM_ID')
            OR ihook.getColumnValue (row_ori, 'VAL_DOM_VER_NR') <>
               ihook.getColumnOldValue (row_ori, 'VAL_DOM_VER_NR'))
        THEN
            SELECT SUBSTR (dec.item_nm || ' ' || vd.item_nm, 1, 255),
                   SUBSTR (dec.item_desc || ':' || vd.item_desc, 1, 4000)
              INTO v_item_nm, v_item_def
              FROM admin_item dec, admin_item vd
             WHERE     dec.item_id =
                       ihook.getColumnValue (row_ori, 'DE_CONC_ITEM_ID')
                   AND dec.ver_nr =
                       ihook.getColumnValue (row_ori, 'DE_CONC_VER_NR')
                   AND vd.item_id =
                       ihook.getColumnValue (row_ori, 'VAL_DOM_ITEM_ID')
                   AND vd.ver_nr =
                       ihook.getColumnValue (row_ori, 'VAL_DOM_VER_NR');

            row := t_row ();
            ihook.setColumnValue (row, 'ITEM_ID', v_item_id);
            ihook.setColumnValue (row, 'VER_NR', v_ver_nr);
            ihook.setColumnValue (row, 'ITEM_NM', v_item_nm);
            ihook.setColumnValue (row, 'ITEM_DESC', v_item_def);
            rows.EXTEND;
            rows (rows.LAST) := row;
            action :=
                t_actionrowset (rows,
                                'Administered Item',
                                2,
                                0,
                                'update');
            actions.EXTEND;
            actions (actions.LAST) := action;
        END IF;

        spDEPrefQuestPost2 (row_ori, actions);

        -- Tracker 818 - if Derivation Rule is set, then

        if ((ihook.getColumnValue (row_ori, 'DERV_TYP_ID') is not null and ihook.getColumnValue (row_ori, 'DERV_RUL') is null) or
        (ihook.getColumnValue (row_ori, 'DERV_TYP_ID') is null and ihook.getColumnValue (row_ori, 'DERV_RUL') is not null)) then
            raise_application_error(-20000, 'DDE requires Derivation Type and Derivation Rule.');
            return;
        end if;
    END IF;

    IF (hookinput.originalRowset.tablename = 'DE_CONC')
    THEN
        FOR cur
            IN (SELECT ai.item_id
                  FROM admin_item ai, de_conc dec
                 WHERE     ai.item_id = dec.item_id
                       AND ai.ver_nr = dec.ver_nr
                       AND dec.obj_cls_item_id =
                           ihook.getColumnValue (row_ori, 'OBJ_CLS_ITEM_ID')
                       AND dec.obj_cls_ver_nr =
                           ihook.getColumnValue (row_ori, 'OBJ_CLS_VER_NR')
                       AND dec.prop_item_id =
                           ihook.getColumnValue (row_ori, 'PROP_ITEM_ID')
                       AND dec.prop_ver_nr =
                           ihook.getColumnValue (row_ori, 'PROP_VER_NR')
                       AND dec.item_id <> v_item_id
                       AND (ai.cntxt_item_id, ai.cntxt_ver_nr) IN
                               (SELECT ai1.cntxt_item_id, ai1.cntxt_ver_nr
                                  FROM admin_item ai1
                                 WHERE     item_id = v_item_id
                                       AND ver_nr = v_ver_nr))
        LOOP
            raise_application_error (-20000,
                                     'Duplicate DEC found. ' || cur.item_id);
            RETURN;
        END LOOP;

        IF (   ihook.getColumnValue (row_ori, 'OBJ_CLS_ITEM_ID') <>
               ihook.getColumnOldValue (row_ori, 'OBJ_CLS_ITEM_ID')
            OR ihook.getColumnValue (row_ori, 'OBJ_CLS_VER_NR') <>
               ihook.getColumnOldValue (row_ori, 'OBJ_CLS_VER_NR')
            OR ihook.getColumnValue (row_ori, 'PROP_ITEM_ID') <>
               ihook.getColumnOldValue (row_ori, 'PROP_ITEM_ID')
            OR ihook.getColumnValue (row_ori, 'PROP_VER_NR') <>
               ihook.getColumnOldValue (row_ori, 'PROP_VER_NR'))
        THEN
            SELECT SUBSTR (oc.item_nm || ' ' || prop.item_nm, 1, 255),
                   SUBSTR (oc.item_desc || ':' || prop.item_desc, 1, 4000)
              INTO v_item_nm, v_item_def
              FROM admin_item oc, admin_item prop
             WHERE     oc.item_id =
                       ihook.getColumnValue (row_ori, 'OBJ_CLS_ITEM_ID')
                   AND oc.ver_nr =
                       ihook.getColumnValue (row_ori, 'OBJ_CLS_VER_NR')
                   AND prop.item_id =
                       ihook.getColumnValue (row_ori, 'PROP_ITEM_ID')
                   AND prop.ver_nr =
                       ihook.getColumnValue (row_ori, 'PROP_VER_NR');

            row := t_row ();
            ihook.setColumnValue (row, 'ITEM_ID', v_item_id);
            ihook.setColumnValue (row, 'VER_NR', v_ver_nr);
            ihook.setColumnValue (row, 'ITEM_NM', v_item_nm);
            ihook.setColumnValue (row, 'ITEM_DESC', v_item_def);
            rows.EXTEND;
            rows (rows.LAST) := row;
            action :=
                t_actionrowset (rows,
                                'Administered Item',
                                2,
                                0,
                                'update');
            actions.EXTEND;
            actions (actions.LAST) := action;
        END IF;
    END IF;
 if (hookinput.originalRowset.tablename = 'VALUE_DOM') then


    if ( ihook.getColumnValue(row_ori, 'REP_CLS_ITEM_ID') is not null and
         ihook.getColumnValue(row_ori, 'REP_CLS_ITEM_ID') <>  ihook.getColumnOldValue(row_ori, 'REP_CLS_ITEM_ID')) then

            select item_nm into v_temp from admin_item where item_id = ihook.getColumnValue(row_ori, 'REP_CLS_ITEM_ID')
            and ver_nr = ihook.getColumnValue(row_ori, 'REP_CLS_VER_NR');
            --if ((trim(substr(v_item_nm, length(v_item_nm)-length(trim(v_temp)))) != v_temp) or
            --length(v_item_nm) < length(v_temp))then
            IF instr(v_item_nm,v_temp)=0 then
                select substr(v_item_nm || ' ' || rc.item_nm,1,255) ,
                substr(v_item_desc || ' ' || rc.item_desc,1,3999)
                into v_item_nm , v_item_desc
                from  admin_item rc
                where  rc.ver_nr =  ihook.getColumnValue(row_ori, 'REP_CLS_VER_NR')
                and rc.item_id =  ihook.getColumnValue(row_ori, 'REP_CLS_ITEM_ID') ;
            end if;
        row := t_row ();
        ihook.setColumnValue(row,'ITEM_ID',v_item_id );
        ihook.setColumnValue(row,'VER_NR',v_ver_nr );
        ihook.setColumnValue(row,'ITEM_NM',v_item_nm );
        ihook.setColumnValue(row,'ITEM_DESC', v_item_desc);
        rows.extend;
        rows(rows.last) := row;
        action := t_actionrowset(rows, 'Administered Item', 2,0,'update');
        actions.extend;
        actions(actions.last) := action;

        end if;
             --  raise_application_error (-20000,     ' VD error ' || v_item_id ||','||v_item_nm );

-- if enumerated is switched to non-enumerated, remove permissible values
    if  (ihook.getColumnValue(row_ori, 'VAL_DOM_TYP_ID') <>  ihook.getColumnOldValue(row_ori, 'VAL_DOM_TYP_ID') and
    ihook.getColumnValue(row_ori, 'VAL_DOM_TYP_ID') = 18) then
        rows := t_rows();
        for cur in (select * from perm_val where val_dom_item_id = v_item_id and val_dom_Ver_nr = v_ver_nr) loop
            row := t_row();
            ihook.setColumnValue(row, 'VAL_ID', cur.val_id);
            rows.extend;
            rows(rows.last) := row;
        end loop;
        if (rows.count >0) then
            action := t_actionrowset(rows, 'Permissible Values (Edit AI)', 2,1,'delete');
            actions.extend;
            actions(actions.last) := action;
            action := t_actionrowset(rows, 'Permissible Values (Edit AI)', 2,2,'purge');
            actions.extend;
            actions(actions.last) := action;
        end if;
    end if;

   -- if caDSR data type changed, change standard data type
    if  (ihook.getColumnValue(row_ori, 'DTTYPE_ID') <>  ihook.getColumnOldValue(row_ori, 'DTTYPE_ID')) then
      row := row_ori;
      rows := t_rows();
    --  raise_application_error(-20000, nci_11179_2.getStdDataType(ihook.getColumnValue(row_ori, 'DTTYPE_ID')));
      ihook.setColumnValue(row, 'NCI_STD_DTTYPE_ID', nci_11179_2.getStdDataType(ihook.getColumnValue(row_ori, 'DTTYPE_ID')));
            rows.extend;
            rows(rows.last) := row;
      action := t_actionrowset(rows, 'Value Domain', 2,0,'update');
        actions.extend;
        actions(actions.last) := action;

    end if;

   -- if olf Val dom type is non-enumerated and status is released. and new value dom type is enumerated, then
     if  (ihook.getColumnValue(row_ori, 'VAL_DOM_TYP_ID') <>  ihook.getColumnOldValue(row_ori, 'VAL_DOM_TYP_ID') and
       ihook.getColumnValue(row_ori, 'VAL_DOM_TYP_ID') = 17) then
       -- check if value domain is released. If it is, then raise error
        for a in (select * from admin_item where item_id = v_item_id and ver_nr = v_ver_nr and ADMIN_STUS_ID = 75) loop
            raise_application_error(-20000, 'A Released VD cannot be enumerated if there are no permissible values.');
        end loop;
       end if;
   END IF;

    IF actions.COUNT > 0
    THEN
        hookoutput.actions := actions;
    END IF;

    -- end if;
    V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
END;


 PROCEDURE spAISTIns
  (
    v_data_in IN CLOB,
    v_data_out OUT CLOB)
AS
  hookInput t_hookInput;
  hookOutput t_hookOutput := t_hookOutput();
   actions t_actions := t_actions();
  action t_actionRowset;
  row t_row;
  rows  t_rows;
    row_ori t_row;
  action_rows       t_rows := t_rows();
  action_row		    t_row;
  rowset            t_rowset;
  v_temp int;
  v_dtype_id integer;
  v_item_id  number;
  v_ver_nr  number(4,2);
BEGIN
  hookinput                    := Ihook.gethookinput (v_data_in);
  hookoutput.invocationnumber  := hookinput.invocationnumber;
  hookoutput.originalrowset    := hookinput.originalrowset;
    rows := t_rows();

    row_ori := hookInput.originalRowset.rowset(1);
    v_item_id := ihook.getColumnValue(row_ori, 'ITEM_ID');
    v_ver_nr := ihook.getColumnValue(row_ori, 'VER_NR');

    rows := t_rows();


 if (ihook.getColumnValue(row_ori, 'UNTL_DT') is not null and ihook.getColumnValue(row_ori, 'UNTL_DT') < nvl(ihook.getColumnValue(row_ori, 'EFF_DT'), sysdate) ) then
 raise_application_error(-20000, 'Expiration date has to be the same or greater than Effective date.');
    return;
end if;

   -- end if;
  V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
END;

END;
/


DROP PACKAGE BODY ONEDATA_WA.NCI_PV_VM;

CREATE OR REPLACE PACKAGE BODY ONEDATA_WA.nci_PV_VM AS

c_long_nm_len  integer := 30;
c_nm_len integer := 255;
c_ver_suffix varchar2(5) := 'v1.00';
v_dflt_txt    varchar2(100) := 'Enter text or auto-generated';

v_int_cncpt_id  number := 2433736;



procedure setDefaultParamPVVM ( row_ori in t_row, row in out t_row)
as
begin
    ihook.setColumnValue(row, 'STG_AI_ID', 1);
    ihook.setColumnValue(row, 'VAL_DOM_ITEM_ID', ihook.getColumnValue(row_ori, 'ITEM_ID')); --Using not used attribute ITEM_2_NM to show selected VD.
   ihook.setColumnValue(row, 'VAL_DOM_VER_NR', ihook.getColumnValue(row_ori, 'VER_NR')); --Using not used attribute ITEM_2_NM to show selected VD.
     ihook.setColumnValue(row, 'ITEM_2_ID', ihook.getColumnValue(row_ori, 'ITEM_ID')); --Using not used attribute ITEM_2_NM to show selected VD.
   ihook.setColumnValue(row, 'ITEM_2_VER_NR', ihook.getColumnValue(row_ori, 'VER_NR')); --Using not used attribute ITEM_2_NM to show selected VD.
  --- Set default Conc Dom
    for cur in (select * from value_dom where item_id =ihook.getColumnValue(row_ori,'ITEM_ID') and ver_nr = ihook.getColumnValue(row_ori,'VER_NR') )loop
           ihook.setColumnValue(row, 'CONC_DOM_ITEM_ID', cur.CONC_DOM_ITEM_ID);
         ihook.setColumnValue(row, 'CONC_DOM_VER_NR', cur.CONC_DOM_VER_NR);
     end loop;

     -- Set default context to NCIP
    ihook.setColumnValue(row, 'CNTXT_ITEM_ID',20000000024 );
    ihook.setColumnValue(row, 'CNTXT_VER_NR', 1);

end;



procedure setDefaultParamPVVM2 ( row_ori in t_row, row in out t_row)
as
begin
    ihook.setColumnValue(row, 'STG_AI_ID', 1);
    ihook.setColumnValue(row, 'VAL_DOM_ITEM_ID', ihook.getColumnValue(row_ori, 'ITEM_ID')); --Using not used attribute ITEM_2_NM to show selected VD.
   ihook.setColumnValue(row, 'VAL_DOM_VER_NR', ihook.getColumnValue(row_ori, 'VER_NR')); --Using not used attribute ITEM_2_NM to show selected VD.
  --   ihook.setColumnValue(row, 'ITEM_2_ID', ihook.getColumnValue(row_ori, 'ITEM_ID')); --Using not used attribute ITEM_2_NM to show selected VD.
  -- ihook.setColumnValue(row, 'ITEM_2_VER_NR', ihook.getColumnValue(row_ori, 'VER_NR')); --Using not used attribute ITEM_2_NM to show selected VD.
  --- Set default Conc Dom
    for cur in (select * from value_dom where item_id =ihook.getColumnValue(row_ori,'ITEM_ID') and ver_nr = ihook.getColumnValue(row_ori,'VER_NR') )loop
           ihook.setColumnValue(row, 'CONC_DOM_ITEM_ID', cur.CONC_DOM_ITEM_ID);
         ihook.setColumnValue(row, 'CONC_DOM_VER_NR', cur.CONC_DOM_VER_NR);
     end loop;

     -- Set default context to NCIP
    ihook.setColumnValue(row, 'CNTXT_ITEM_ID',20000000024 );
    ihook.setColumnValue(row, 'CNTXT_VER_NR', 1);

end;


procedure chkPVVMActionValid ( row_ori in t_row, v_usr_id in varchar2)
as
begin

  -- Raise error if not authorized
     if (nci_11179_2.isUserAuth(ihook.getColumnValue(row_ori,'ITEM_ID'),ihook.getColumnValue(row_ori,'VER_NR') , v_usr_id) = false) then
        raise_application_error(-20000, 'You are not authorized to insert/update or delete in this context. ');
        return;
    end if;

    if (ihook.getColumnValue(row_ori, 'ADMIN_ITEM_TYP_ID') <> 3) then
        raise_application_error(-20000, 'This action is only applicable for Value Domains.');
        return;
    end if;

    for cur in (select * from value_dom where item_id = ihook.getColumnValue(row_ori,'ITEM_ID') and ver_nr = ihook.getColumnValue(row_ori,'VER_NR')
    and VAL_DOM_TYP_ID <> 17) loop
        raise_application_error(-20000, 'PV/VM cannot be added - Selected Value Domain is non-enumerated. ');
        return;
   end loop;

end;

-- Create new PV/VM with multiple concepts in VM
PROCEDURE spPVVMCreateNew ( v_data_in IN CLOB, v_data_out OUT CLOB, v_usr_id  IN varchar2)
as
  hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();
    row_ori  t_row;
    row  t_row;
    rows t_rows;
    v_dflt_txt    varchar2(100) := 'Enter text or auto-generated.';
    rowsetai  t_rowset;
begin
    -- Standard header
    hookinput                    := Ihook.gethookinput (v_data_in);
    hookoutput.invocationnumber  := hookinput.invocationnumber;
    hookoutput.originalrowset    := hookinput.originalrowset;

    row_ori :=  hookInput.originalRowset.rowset(1);

    chkPVVMActionValid ( row_ori, v_usr_id );
    -- Default for new row. Dummy Identifier has to be set else error.
    row := t_row();
    setDefaultParamPVVM (row_ori, row);

    rows := t_rows();    rows.extend;    rows(rows.last) := row;
    rowsetai := t_rowset(rows, 'AI Creation With Concepts', 1, 'NCI_STG_AI_CNCPT_CREAT'); -- Default values for form

    spPVVMCommon(rowsetai, 'insert', hookinput, hookoutput);

    V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
     --nci_util.debugHook('GENERAL',v_data_out);
end;


-- Create new PV/VM with multiple concepts in VM
PROCEDURE spPVVMCreateNew2 ( v_data_in IN CLOB, v_data_out OUT CLOB, v_usr_id  IN varchar2)
as
  hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();
    row_ori  t_row;
    row  t_row;
    rows t_rows;
    v_dflt_txt    varchar2(100) := 'Enter text or auto-generated.';
    rowsetai  t_rowset;
    i integer;
begin
    -- Standard header
    hookinput                    := Ihook.gethookinput (v_data_in);
    hookoutput.invocationnumber  := hookinput.invocationnumber;
    hookoutput.originalrowset    := hookinput.originalrowset;

    row_ori :=  hookInput.originalRowset.rowset(1);

    chkPVVMActionValid ( row_ori, v_usr_id );
    -- Default for new row. Dummy Identifier has to be set else error.
   -- row := t_row();
    --setDefaultParamPVVM (row_ori, row);
rows := t_rows();
 for i in 1..10 loop
   row := t_row();
   ihook.setColumnValue(row, 'STG_AI_ID', i);
        rows.extend;    rows(rows.last) := row;
    end loop;

  --  rowset := t_rowset(rows, 'AI Creation With Concepts', 1, 'NCI_STG_AI_CNCPT_CREAT'); -- Default values for form
   -- rows := t_rows();    rows.extend;    rows(rows.last) := row;
   -- rowsetai := t_rowset(rows, 'AI Creation With Concepts', 1, 'NCI_STG_AI_CNCPT_CREAT'); -- Default values for form

    spPVVMCommon2(rows, 'insert', hookinput, hookoutput);

    V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
 nci_util.debugHook('GENERAL',v_data_out);
end;


-- Create new PV/VM with  concepts in VM
PROCEDURE spPVVMCreateNewBulk ( v_data_in IN CLOB, v_data_out OUT CLOB, v_usr_id  IN varchar2)
as
  hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();
    row_ori  t_row;
    row  t_row;
    rows t_rows;
    v_dflt_txt    varchar2(100) := 'Enter text or auto-generated.';
    rowsetai  t_rowset;
    forms t_forms;
  form1 t_form;
 rowform  t_row;
begin
    -- Standard header
    hookinput                    := Ihook.gethookinput (v_data_in);
    hookoutput.invocationnumber  := hookinput.invocationnumber;
    hookoutput.originalrowset    := hookinput.originalrowset;

    row_ori :=  hookInput.originalRowset.rowset(1);
    chkPVVMActionValid ( row_ori, v_usr_id );

    if (hookinput.invocationnumber = 0) then
    -- Default for new row. Dummy Identifier has to be set else error.
    row := t_row();
    setDefaultParamPVVM (row_ori, row);
    rows := t_rows();    rows.extend;    rows(rows.last) := row;
    rowsetai := t_rowset(rows, 'AI Creation With Concepts', 1, 'NCI_STG_AI_CNCPT_CREAT'); -- Default values for form
    hookoutput.question := getPVVMQuestionBulk;
        -- Send initial rowset to create the form.
    hookOutput.forms :=getPVVMCreateFormBulk(rowsetai);

    else -- second invocation
        forms              := hookInput.forms;
        form1              := forms(1);
        rowform := form1.rowset.rowset(1);
        createPVVMBulk(rowform,hookInput,hookOutput);

    end if;
    V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
     nci_util.debugHook('GENERAL',v_data_out);
end;


--Inplace edit of VM

PROCEDURE spVMEdit ( v_data_in IN CLOB, v_data_out OUT CLOB, v_usr_id  IN varchar2)
as
    hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();
    row_ori  t_row;
    row  t_row;
    rows t_rows;
    v_item_nm varchar2(255);
    v_item_def varchar2(4000);
    v_item_long_nm varchar2(255);
    v_item_id  number;
    v_ver_nr  number(4,2);
    v_item_type_id number;
   rowset  t_rowset;
    v_tbl_nm varchar2(100);
begin
    -- Standard header
    hookInput                    := Ihook.gethookinput (v_data_in);
    hookOutput.invocationnumber  := hookInput.invocationnumber;
    hookOutput.originalrowset    := hookInput.originalrowset;

    -- Get the selected row
    row_ori :=  hookInput.originalRowset.rowset(1);
    v_item_id := ihook.getColumnValue(row_ori, 'ITEM_ID');
    v_ver_nr := ihook.getColumnValue(row_ori, 'VER_NR');
    v_item_type_id := ihook.getColumnValue(row_ori, 'ADMIN_ITEM_TYP_ID');
    v_tbl_nm := hookinput.originalRowset.tablename;

  --  raise_application_error(-20000, v_tbl_nm);

    if (v_tbl_nm <> 'Administered Item') then  -- being called from PV
       v_item_id := ihook.getColumnValue(row_ori, 'NCI_VAL_MEAN_ITEM_ID');
        v_ver_nr := ihook.getColumnValue(row_ori, 'NCI_VAL_MEAN_VER_NR');
        nci_11179.spReturnAIRow(v_item_id, v_ver_nr, row_ori);

    end if;
        v_item_id := ihook.getColumnValue(row_ori, 'ITEM_ID');
        v_ver_nr := ihook.getColumnValue(row_ori, 'VER_NR');
        v_item_nm := ihook.getColumnValue(row_ori, 'ITEM_NM');
        v_item_def := ihook.getColumnValue(row_ori, 'ITEM_DESC');
        v_item_long_nm := ihook.getColumnValue(row_ori, 'ITEM_LONG_NM');

    -- Check if user is authorized to edit
    if (nci_11179_2.isUserAuth(v_item_id, v_ver_nr, v_usr_id) = false) then
        raise_application_error(-20000, 'You are not authorized to insert/update or delete in this context. ');
        return;
    end if;

    -- If called from Admin Item
    if (v_item_type_id <> 53 and upper(hookinput.originalRowset.tablename) like 'ADMIN%') then
        raise_application_error(-20000,'!!! This functionality is only applicable for VM !!!');
    end if;

    row := row_ori;


     -- Copy VM concepts
    nci_11179.spReturnConceptRow (v_item_id, v_ver_nr, 53, 1, row );

    -- Internal dummy is is set to 1.
    ihook.setColumnValue(row, 'STG_AI_ID', 1);
    ihook.setColumnValue(row, 'ITEM_1_ID', v_item_id);  --- Used in update later
    ihook.setColumnValue(row, 'ITEM_1_VER_NR', v_ver_nr);   --- Used in update later

  --  raise_application_error(-20000, ihook.getColumnValue(row, 'CNCPT_1_ITEM_ID_1'));
        ihook.setColumnValue(row, 'ITEM_1_NM',  v_item_nm);
        ihook.setColumnValue(row, 'ITEM_1_DEF',  v_item_def);
        ihook.setColumnValue(row, 'ITEM_1_LONG_NM',  v_item_long_nm);


    rows := t_rows();    rows.extend;    rows(rows.last) := row;
    rowset := t_rowset(rows, 'VM Edit (Hook)', 1, 'NCI_STG_AI_CNCPT_CREAT');

    nci_pv_vm.VMEditCore(rowset, hookinput, hookoutput);

    V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);

nci_util.debugHook('GENERAL', v_data_out);

end;



-- Change PV Association May result in creation of new VM

PROCEDURE spVMCreateEdit ( v_data_in IN CLOB, v_data_out OUT CLOB, v_usr_id  IN varchar2)
as
    hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();
    row_ori  t_row;
    row  t_row;
    rows t_rows;
    v_item_nm varchar2(255);
    v_item_def varchar2(4000);
    v_item_long_nm varchar2(255);
    v_item_id  number;
    v_ver_nr  number(4,2);
    v_item_type_id number;
    v_cd_item_id number;
    v_cd_ver_nr number(4,2);
   rowset  t_rowset;
    v_tbl_nm varchar2(100);
begin
    -- Standard header
    hookInput                    := Ihook.gethookinput (v_data_in);
    hookOutput.invocationnumber  := hookInput.invocationnumber;
    hookOutput.originalrowset    := hookInput.originalrowset;

    -- Get the selected row
    row_ori :=  hookInput.originalRowset.rowset(1);
    v_item_id := ihook.getColumnValue(row_ori, 'ITEM_ID');
    v_ver_nr := ihook.getColumnValue(row_ori, 'VER_NR');
    v_item_type_id := ihook.getColumnValue(row_ori, 'ADMIN_ITEM_TYP_ID');
        v_item_id := ihook.getColumnValue(row_ori, 'NCI_VAL_MEAN_ITEM_ID');
        v_ver_nr := ihook.getColumnValue(row_ori, 'NCI_VAL_MEAN_VER_NR');
        select item_nm, item_desc, item_long_nm into v_item_nm, v_item_def, v_item_long_nm from admin_item where item_id = v_item_id and ver_nr = v_ver_nr;
    -- Check if user is authorized to edit
    if (nci_11179_2.isUserAuth(v_item_id, v_ver_nr, v_usr_id) = false) then
        raise_application_error(-20000, 'You are not authorized to insert/update or delete in this context. ');
        return;
    end if;


    row := row_ori;


     -- Copy VM concepts
    nci_11179.spReturnConceptRow (v_item_id, v_ver_nr, 53, 1, row );

    -- Internal dummy is is set to 1.
    ihook.setColumnValue(row, 'STG_AI_ID', 1);
  --  ihook.setColumnValue(row, 'ITEM_2_ID', v_item_id);  --- Used in update later
  --  ihook.setColumnValue(row, 'ITEM_2_VER_NR', v_ver_nr);   --- Used in update later
    ihook.setColumnValue(row, 'VAL_DOM_ITEM_ID', ihook.getColumnValue(row_ori, 'VAL_DOM_ITEM_ID'));
    ihook.setColumnValue(row, 'VAL_DOM_VER_NR', ihook.getColumnValue(row_ori, 'VAL_DOM_VER_NR'));
    ihook.setColumnValue(row, 'PERM_VAL_NM', ihook.getColumnValue(row_ori, 'PERM_VAL_NM'));

    select conc_dom_item_id, conc_dom_Ver_nr into v_cd_item_id, v_cd_ver_nr from value_dom where item_id = ihook.getColumnValue(row_ori, 'VAL_DOM_ITEM_ID')
    and ver_nr = ihook.getColumnValue(row_ori, 'VAL_DOM_VER_NR');

    ihook.setColumnValue(row, 'CONC_DOM_ITEM_ID', v_cd_item_id);
    ihook.setColumnValue(row, 'CONC_DOM_VER_NR', v_cd_ver_nr);

        ihook.setColumnValue(row, 'ITEM_1_NM',  v_item_nm);
        ihook.setColumnValue(row, 'ITEM_1_DEF',  v_item_def);
        ihook.setColumnValue(row, 'ITEM_1_LONG_NM',  v_item_long_nm);
        ihook.setColumnValue(row, 'ITEM_1_ID',  v_item_id);
        ihook.setColumnValue(row, 'ITEM_1_VER_NR',  v_ver_nr);


    rows := t_rows();    rows.extend;    rows(rows.last) := row;
    rowset := t_rowset(rows, 'VM Edit (Hook)', 1, 'NCI_STG_AI_CNCPT_CREAT');

    nci_pv_vm.VMCreateEditCore(rowset, hookinput, hookoutput);

    V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);

nci_util.debugHook('GENERAL', v_data_out);

end;


procedure createPVVMBulk ( rowform in t_row,  hookInput in t_hookInput, hookOutput in out t_hookOutput)
AS
  forms t_forms;
  form1 t_form;

  row t_row;
  row_ori t_row;
  rowset            t_rowset;
 v_cncpt_long_nm  varchar2(255);
 v_cncpt_long_nm_int  varchar2(255);
 v_cncpt_nm  varchar2(255);
 v_cncpt_def varchar2(4000);
 v_item_id number;
 v_ver_nr number(4,2);
  cnt integer;
    actions t_actions := t_actions();
  action t_actionRowset;
  i integer := 0;
  v_cncpt_id number;
  v_cncpt_ver_nr number(4,2);
 v_temp integer;
  v_item_typ_glb integer;
  v_cncpt_id_int integer;
  v_pv  varchar2(255);
  v_vd_item_id number;
  v_vd_ver_nr number(4,2);
  v_cncpt_str  varchar2(255);
  v_vm_rows t_rows;
  v_vm_cd_rows t_rows;
  v_pv_rows  t_rows;
  v_cncpt_assoc_rows t_rows;
begin
    v_item_typ_glb := 53;
    row_ori :=  hookInput.originalRowset.rowset(1);
    v_vm_rows := t_rows();
    v_vm_cd_rows := t_rows();
    v_pv_rows := t_rows();
    v_cncpt_assoc_rows := t_rows();

      v_vd_item_id := ihook.getColumnValue(row_ori,'ITEM_ID');
      v_vd_ver_nr := ihook.getColumnValue(row_ori,'VER_NR');

      for i in 1..10 loop  -- Max of 10 pairs
        v_cncpt_id := ihook.getColumnValue(rowform,'CNCPT_1_ITEM_ID_' || i );
        v_cncpt_ver_nr := ihook.getColumnValue(rowform,'CNCPT_1_VER_NR_' || i );
        v_cncpt_str := ihook.getColumnValue(rowform,'STR_' || i );
        v_cncpt_id_int :=ihook.getColumnValue(rowform,'CNCPT_INT_1_' || i );
        if (v_cncpt_id is not null or v_cncpt_str is not null) then
            -- check if VM already exists

            -- IF concept ID specified and not integer
            if (v_cncpt_id is not null and (v_cncpt_id <> v_int_cncpt_id or (v_cncpt_id = v_int_cncpt_id and v_cncpt_id_int is null))  ) then
                select item_nm, item_long_nm, item_long_nm, item_desc into v_cncpt_nm, v_cncpt_long_nm,v_cncpt_long_nm_int, v_cncpt_def
                from admin_item where item_id = v_cncpt_id and ver_nr = v_cncpt_ver_nr;
            end if;
            -- IF concept ID specified and integer. Default for int is going to be 1
            if (v_cncpt_id = v_int_cncpt_id and v_cncpt_id_int is not null) then
                select  v_cncpt_id_int , item_long_nm, item_long_nm || '::' || v_cncpt_id_int , item_desc || '::' || v_cncpt_id_int into v_cncpt_nm, v_cncpt_long_nm,v_cncpt_long_nm_int, v_cncpt_def
                from admin_item where item_id = v_cncpt_id and ver_nr = v_cncpt_ver_nr;
            end if;
            -- if concept string specified
            if (v_cncpt_str is not null) then
                 v_cncpt_long_nm := v_cncpt_str;
                 v_cncpt_long_nm_int := v_cncpt_str;
                 v_cncpt_nm := v_cncpt_str;
                 v_cncpt_def := nvl(ihook.getColumnValue( rowform, 'STR_DESC_' || i), v_cncpt_str);
            end if;
        -- if PV is null, use VM name.

            v_pv :=  trim(nvl(ihook.getColumnValue(rowform,'PV_' || i), v_cncpt_nm));

                v_item_id := null;
                v_ver_nr := 1;
                -- Check if VM exists
                for cur in (select ai.item_id , ai.ver_nr from admin_item ai, nci_admin_item_ext e where ai.admin_item_typ_id = 53 and
                ai.item_id = e.item_id and ai.ver_nr = e.ver_nr and e.cncpt_concat_with_int = v_cncpt_long_nm_int) loop
                  v_item_id := cur.item_id;
                  v_ver_nr :=cur.ver_nr;
                end loop;
   --  raise_application_error(-20000, v_cncpt_long_nm || ' ' || v_item_id);

                if (v_item_id is null) then -- create new VM
                    v_ver_nr := 1;

                        row := t_row();
                        v_item_id := nci_11179.getItemId;
                        ihook.setColumnValue(row,'ITEM_ID', v_item_id);
                        ihook.setColumnValue(row,'VER_NR', 1);
                        ihook.setColumnValue(row,'CNCPT_ITEM_ID',v_cncpt_id);
                        ihook.setColumnValue(row,'CNCPT_VER_NR', v_cncpt_ver_nr);
                        if (v_cncpt_id = v_int_cncpt_id and v_cncpt_id_int is not null) then
                            ihook.setColumnValue(row,'NCI_CNCPT_VAL', v_cncpt_id_int);
                        end if;
                        ihook.setColumnValue(row,'NCI_ORD', 1);
                        ihook.setColumnValue(row,'NCI_PRMRY_IND', 1);
                        ihook.setColumnValue(row,'CURRNT_VER_IND', 1);
                        ihook.setColumnValue(row,'ADMIN_ITEM_TYP_ID', 53);
                        ihook.setColumnValue(row,'ADMIN_STUS_ID',66 );
                        ihook.setColumnValue(row,'REGSTR_STUS_ID',9 );
                        ihook.setColumnValue(row,'ITEM_LONG_NM', nci_11179_2.getStdShortName(v_item_id, 1));
                        ihook.setColumnValue(row,'ITEM_DESC', v_cncpt_def);
                        ihook.setColumnValue(row,'ITEM_NM', v_cncpt_nm);
                        ihook.setColumnValue(row,'CNTXT_ITEM_ID',20000000024); -- NCIP
                        ihook.setColumnValue(row,'CNTXT_VER_NR', 1);
                        ihook.setColumnValue(row,'CNCPT_CONCAT', v_cncpt_long_nm);
                        ihook.setColumnValue(row,'CNCPT_CONCAT_DEF', v_cncpt_def);
                        ihook.setColumnValue(row,'CNCPT_CONCAT_NM', v_cncpt_nm);
                        ihook.setColumnValue(row,'CNCPT_CONCAT_WITH_INT', v_cncpt_long_nm_int);
                        ihook.setColumnValue(row,'LST_UPD_DT',sysdate );

                          v_vm_rows.extend;            v_vm_rows(v_vm_rows.last) := row;

                    if (v_cncpt_id is not null) then
                          v_cncpt_assoc_rows.extend;            v_cncpt_assoc_rows(v_cncpt_assoc_rows.last) := row;
                    end if;

                end if;

                -- Check if VM-CD exists
                select count(*) into v_temp from CONC_DOM_VAL_MEAN where CONC_DOM_ITEM_ID = ihook.getColumnValue(rowform, 'CONC_DOM_ITEM_ID') and
                CONC_DOM_VER_NR = ihook.getColumnValue(rowform, 'CONC_DOM_VER_NR') and NCI_VAL_MEAN_ITEM_ID = v_item_id and NCI_VAL_MEAN_VER_NR =v_ver_nr;

                if (v_temp = 0) then
                    row := t_row();
                    ihook.setColumnValue(row,'CONC_DOM_ITEM_ID', ihook.getColumnValue(rowform, 'CONC_DOM_ITEM_ID'));
                    ihook.setColumnValue(row,'CONC_DOM_VER_NR', ihook.getColumnValue(rowform, 'CONC_DOM_VER_NR'));
                    ihook.setColumnValue(row,'NCI_VAL_MEAN_ITEM_ID',  v_item_id);
                    ihook.setColumnValue(row,'NCI_VAL_MEAN_VER_NR', v_ver_nr);

                    v_vm_cd_rows.extend;            v_vm_cd_rows(v_vm_cd_rows.last) := row;
                end if;

                -- Check if PV exists
                select count(*) into v_temp from PERM_VAL where VAL_DOM_ITEM_ID = ihook.getColumnValue(row_ori, 'ITEM_ID') and
                VAL_DOM_VER_NR = ihook.getColumnValue(row_ori, 'VER_NR') and NCI_VAL_MEAN_ITEM_ID = v_item_id and NCI_VAL_MEAN_VER_NR = v_ver_nr
                and upper(PERM_VAL_NM) = upper(v_pv);

                if (v_temp = 0) then
                    row := t_row();
                    ihook.setColumnValue(row,'PERM_VAL_NM', v_pv);
                    ihook.setColumnValue(row,'VAL_DOM_ITEM_ID', ihook.getColumnValue(row_ori, 'ITEM_ID'));
                    ihook.setColumnValue(row,'VAL_DOM_VER_NR', ihook.getColumnValue(row_ori, 'VER_NR'));
                    ihook.setColumnValue(row,'NCI_VAL_MEAN_ITEM_ID',  v_item_id);
                    ihook.setColumnValue(row,'NCI_VAL_MEAN_VER_NR', v_ver_nr);
                    ihook.setColumnValue(row,'VAL_ID',-1);
                    v_pv_rows.extend;   v_pv_rows(v_pv_rows.last) := row;
            end if;
           end if;  -- all values needed are not null
          end loop; -- i 1 to 10


        if (v_vm_rows.count > 0) then
                action := t_actionrowset(v_vm_rows, 'Administered Item (No Sequence)', 2,1,'insert');
                actions.extend;
                actions(actions.last) := action;

                action := t_actionrowset(v_vm_rows, 'NCI AI Extension (Hook)', 2,3,'insert');
                actions.extend;
                actions(actions.last) := action;

                action := t_actionrowset(v_vm_rows, 'Value Meaning', 2,2,'insert');
                actions.extend;
                actions(actions.last) := action;

        if (v_cncpt_assoc_rows.count > 0) then
                action := t_actionrowset(v_cncpt_assoc_rows, 'Items under Concept (Hook)', 2,6,'insert');
                actions.extend;
                actions(actions.last) := action;
            end if;
         end if;

          if (v_vm_cd_rows.count > 0) then
            action := t_actionrowset(v_vm_cd_rows, 'Value Meanings', 2,10,'insert');
            actions.extend;
            actions(actions.last) := action;
         end if;

          if (v_pv_rows.count > 0) then
            action := t_actionrowset(v_pv_rows, 'Permissible Values (Edit AI)', 2,11,'insert');
            actions.extend;
            actions(actions.last) := action;
         end if;


    if (actions.count > 0) then
        hookoutput.actions := actions;
        hookoutput.message := v_pv_rows.count || ' PV/VM created. ';
    end if;

END;


-- Common routine for DEC - Create or Update
-- v_init is the initial rowset to populate.
-- v_op is insert or update
PROCEDURE       spPVVMCommon ( v_init in t_rowset,  v_op  in varchar2,  hookInput in t_hookInput, hookOutput in out t_hookOutput)
AS
  rowform t_row;
  forms t_forms;
  form1 t_form;

  row t_row;
  rows  t_rows;
  row_ori t_row;
  rowset            t_rowset;
 v_str  varchar2(255);
 v_nm  varchar2(255);
 v_item_id number;
 v_ver_nr number(4,2);
  cnt integer;
k integer;
    actions t_actions := t_actions();
  action t_actionRowset;
  v_msg varchar2(1000);
  i integer := 0;
  v_err  integer;
  column  t_column;
  v_dec_nm varchar2(255);
  v_cncpt_nm varchar2(255);
  v_long_nm varchar2(255);
  v_def varchar2(4000);
  v_temp integer;
  is_valid boolean;
  v_item_typ_glb integer;
  v_pv  varchar2(255);
begin
    v_item_typ_glb := 53;
    row_ori :=  hookInput.originalRowset.rowset(1);

   if hookInput.invocationNumber = 0 then
        --  Get question. Either create or edit
          HOOKOUTPUT.QUESTION    := getPVVMQuestion;

        -- Send initial rowset to create the form.
          hookOutput.forms :=getPVVMCreateForm(v_init);

    else
        forms              := hookInput.forms;
        form1              := forms(1);
        rowform := form1.rowset.rowset(1);
        row := t_row();        rows := t_rows();
        is_valid := true;
        k := 1;
      -- Context is always going to be NCIP
        ihook.setColumnValue(rowform,'CNTXT_ITEM_ID',20000000024); -- NCIP
        ihook.setColumnValue(rowform,'CNTXT_VER_NR', 1);

        if HOOKINPUT.ANSWERID = 1 or Hookinput.answerid = 3 then  -- Validate using string
                     for i in  1..10 loop
                            ihook.setColumnValue(rowform, 'CNCPT_' || k  ||'_ITEM_ID_' || i,'');
                            ihook.setColumnValue(rowform, 'CNCPT_' || k || '_VER_NR_' || i, '');
                    end loop;
                nci_dec_mgmt.createValAIWithConcept(rowform , k,v_item_typ_glb ,'V','STRING',actions);
            end if;

        if HOOKINPUT.ANSWERID = 2 or Hookinput.answerid = 4 then  -- Validate using drop-down
          --  for k in  1..2  loop
               nci_dec_mgmt.createValAIWithConcept(rowform , k,v_item_typ_glb ,'V','DROP-DOWN',actions);
         --   end loop;
        end if;

       ihook.setColumnValue(rowform, 'GEN_STR',ihook.getColumnValue(rowform,'ITEM_1_NM') ) ;
       ihook.setColumnValue(rowform, 'CTL_VAL_MSG', 'VALIDATED');

        if (   ihook.getColumnValue(rowform, 'CNCPT_1_ITEM_ID_1') is null and hookinput.answerId < 5) then
                  ihook.setColumnValue(rowform, 'CTL_VAL_MSG', 'Concept missing');
                  is_valid := false;
        end if;
        if (   ihook.getColumnValue(rowform, 'ITEM_2_LONG_NM') is null and hookinput.answerid = 5) then
                  ihook.setColumnValue(rowform, 'CTL_VAL_MSG', 'No specified VM name');
                  is_valid := false;
        end if;

        if (   ihook.getColumnValue(rowform, 'ITEM_1_ID') is null and hookinput.answerid = 6) then
                  ihook.setColumnValue(rowform, 'CTL_VAL_MSG', 'No VM Specified');
                  is_valid := false;
        end if;

         rows := t_rows();

         -- If any of the test fails or if the user has triggered validation, then go back to the screen.
        if (is_valid=false or hookinput.answerid = 1 or hookinput.answerid = 2) then

              -- Read-only drop-downs do not migrate
                ihook.setColumnValue(rowform, 'VAL_DOM_ITEM_ID', ihook.getColumnValue(row_ori, 'ITEM_ID')); --Using not used attribute ITEM_2_NM to show selected VD.
                ihook.setColumnValue(rowform, 'VAL_DOM_VER_NR', ihook.getColumnValue(row_ori, 'VER_NR')); --Using not used attribute ITEM_2_NM to show selected VD.
                ihook.setColumnValue(rowform, 'ITEM_2_ID', ihook.getColumnValue(row_ori, 'ITEM_ID')); --Using not used attribute ITEM_2_NM to show selected VD.
                ihook.setColumnValue(rowform, 'ITEM_2_VER_NR', ihook.getColumnValue(row_ori, 'VER_NR')); --Using not used attribute ITEM_2_NM to show selected VD.
                rows.extend;
                rows(rows.last) := rowform;
                rowset := t_rowset(rows, 'AI Creation With Concepts', 1, 'NCI_STG_AI_CNCPT_CREAT');
                hookOutput.forms := getPVVMCreateForm(rowset);
                HOOKOUTPUT.QUESTION    := getPVVMQuestion;
                return;
        end if;

    -- If all the tests have passed and the user has asked for create, then create DEC and optionally OC and Prop.

    IF HOOKINPUT.ANSWERID in ( 3,4)  and is_valid = true THEN  -- Create
        nci_dec_mgmt.createValAIWithConcept(rowform , 1,v_item_typ_glb ,'C','DROP-DOWN',actions); -- Vm
    elsif (hookinput.answerid = 5 and is_Valid = true) then
        nci_dec_mgmt.createAIWithoutConcept(rowform , 1, 53, ihook.getColumnValue(rowform, 'ITEM_2_LONG_NM'),nvl(ihook.getColumnValue(rowform, 'ITEM_2_DEF'), ihook.getColumnValue(rowform, 'ITEM_2_LONG_NM')),
        actions);
    end if;
      -- Create PV

      v_item_id := ihook.getColumnValue(rowform,'ITEM_1_ID');
      v_ver_nr := ihook.getColumnValue(rowform,'ITEM_1_VER_NR');
      v_pv := ihook.getColumnValue(rowform,'PERM_VAL_NM');

      if (hookinput.answerid = 5) then -- use specified value
        v_pv :=  nvl(ihook.getColumnValue(rowform,'PERM_VAL_NM'),ihook.getColumnValue(rowform,'ITEM_2_LONG_NM') );
      end if;
      if (hookinput.answerid in (3,4)) then -- use specified value
        v_pv :=  nvl(ihook.getColumnValue(rowform,'PERM_VAL_NM'),ihook.getColumnValue(rowform,'ITEM_1_NM') );
      end if;

      if (hookinput.answerid =6 and v_pv is null) then -- use specified value
      select item_nm into v_pv from admin_item where item_id = v_item_id and ver_nr = v_ver_nr;
      end if;

      -- Show resue if string specified.
      if (hookinput.answerid = 5) then
        hookoutput.message := ihook.getColumnValue(rowform,'CTL_VAL_MSG');
    else
      hookoutput.message := 'PV/VM Created Successfully with VM ID: ' || v_item_id;
    end if;
        select count(*) into v_temp from CONC_DOM_VAL_MEAN where CONC_DOM_ITEM_ID = ihook.getColumnValue(rowform, 'CONC_DOM_ITEM_ID') and
        CONC_DOM_VER_NR = ihook.getColumnValue(rowform, 'CONC_DOM_VER_NR') and NCI_VAL_MEAN_ITEM_ID = v_item_id and NCI_VAL_MEAN_VER_NR = v_ver_nr;

        if (v_temp = 0) then
        rows := t_rows();
        row := t_row();
        ihook.setColumnValue(row,'CONC_DOM_ITEM_ID', ihook.getColumnValue(rowform, 'CONC_DOM_ITEM_ID'));
        ihook.setColumnValue(row,'CONC_DOM_VER_NR', ihook.getColumnValue(rowform, 'CONC_DOM_VER_NR'));
        ihook.setColumnValue(row,'NCI_VAL_MEAN_ITEM_ID',  v_item_id);
        ihook.setColumnValue(row,'NCI_VAL_MEAN_VER_NR', ihook.getColumnValue(rowform, 'ITEM_1_VER_NR'));

            rows.extend;
            rows(rows.last) := row;
          action := t_actionrowset(rows, 'Value Meanings', 2,10,'insert');
           actions.extend;
           actions(actions.last) := action;

      end if;
      if (v_pv is not null) then
        select count(*) into v_temp from PERM_VAL where VAL_DOM_ITEM_ID = ihook.getColumnValue(row_ori, 'ITEM_ID') and
        VAL_DOM_VER_NR = ihook.getColumnValue(row_ori, 'VER_NR') and NCI_VAL_MEAN_ITEM_ID = v_item_id and NCI_VAL_MEAN_VER_NR = v_ver_nr
        and upper(PERM_VAL_NM) = upper(v_pv);

        if (v_temp = 0) then
        rows := t_rows();
        row := t_row();
        ihook.setColumnValue(row,'PERM_VAL_NM', v_pv);
        ihook.setColumnValue(row,'VAL_DOM_ITEM_ID', ihook.getColumnValue(row_ori, 'ITEM_ID'));
        ihook.setColumnValue(row,'VAL_DOM_VER_NR', ihook.getColumnValue(row_ori, 'VER_NR'));
        ihook.setColumnValue(row,'NCI_VAL_MEAN_ITEM_ID',  v_item_id);
        ihook.setColumnValue(row,'NCI_VAL_MEAN_VER_NR', 1);

        ihook.setColumnValue(row,'VAL_ID',-1);
            rows.extend;
            rows(rows.last) := row;
          action := t_actionrowset(rows, 'Permissible Values (Edit AI)', 2,19,'insert');
           actions.extend;
           actions(actions.last) := action;

        end if;

      end if;
     end if;


    if (actions.count > 0) then
        hookoutput.actions := actions;
         --   raise_application_error(-20000,'Inside 1' || v_item_id);

    end if;

END;

PROCEDURE       spPVVMCommon2 ( v_init_rows in t_rows,  v_op  in varchar2,  hookInput in t_hookInput, hookOutput in out t_hookOutput)
AS
  rowform t_row;
  forms t_forms;
  form1 t_form;

  row t_row;
  rows  t_rows;
  rowforms t_rows;
  row_ori t_row;
  rowset            t_rowset;
 v_str  varchar2(255);
 v_nm  varchar2(255);
 v_item_id number;
 v_ver_nr number(4,2);
  v_cnt integer;
k integer;
    actions t_actions := t_actions();
  action t_actionRowset;
  v_msg varchar2(1000);
  i integer := 0;
  v_err  integer;
  column  t_column;
  v_dec_nm varchar2(255);
  v_cncpt_nm varchar2(255);
  v_long_nm varchar2(255);
  v_def varchar2(4000);
  v_temp integer;
  is_valid boolean;
  v_item_typ_glb integer;
  v_pv  varchar2(255);
  rep_idx integer;
  v_opt  integer;
begin
    v_item_typ_glb := 53;
    row_ori :=  hookInput.originalRowset.rowset(1);

   if hookInput.invocationNumber = 0 then
        --  Get question. Either create or edit
          HOOKOUTPUT.QUESTION    := getPVVMQuestion;

        -- Send initial rowset to create the form.
          hookOutput.forms :=getPVVMCreateForm2(v_init_rows);

    else
        forms              := hookInput.forms;

        is_valid := true;
        k := 1;
        rowforms := t_rows();
        for rep_idx in 1..10 loop
            form1              := forms(rep_idx);
            rowform := form1.rowset.rowset(1);
           setDefaultParamPVVM2 (row_ori, rowform);
        -- Rowforms holds all the data

        -- Context is always going to be NCIP

            ihook.setColumnValue(rowform,'CNTXT_ITEM_ID',20000000024); -- NCIP
            ihook.setColumnValue(rowform,'CNTXT_VER_NR', 1);

        -- determine what logic to use
        -- 1 - Use Existing
        -- 2 - Use Specified
        -- 3 - Concept String
        -- 4 - Concept Drop-down
            v_opt := 0    ;
           if (  ihook.getColumnValue(rowform, 'ITEM_2_ID') is not null) then -- user selected Vm
                v_opt := 1;
                ihook.setColumnValue(rowform, 'CTL_VAL_MSG', 'VALIDATED: User Specified VM will be used.');
                ihook.setColumnValue(rowform, 'CTL_VAL_STUS', '1');

          elsif (ihook.getColumnValue(rowform, 'ITEM_2_LONG_NM') is not null) then -- String
                v_opt := 2;
                ihook.setColumnValue(rowform, 'CTL_VAL_MSG', 'VALIDATED: User specified VM String will be used.');
                ihook.setColumnValue(rowform, 'CTL_VAL_STUS', '2');
          elsif (ihook.getColumnValue(rowform, 'CNCPT_CONCAT_STR_1') is not null) then -- Concept String
                v_opt := 3;

         elsif (ihook.getColumnValue(rowform, 'CNCPT_1_ITEM_ID_1') is not null) then
                v_opt := 4;
         end if;

         if (v_opt > 0) then
            if v_opt = 3 then
                     for i in  1..10 loop
                            ihook.setColumnValue(rowform, 'CNCPT_' || k  ||'_ITEM_ID_' || i,'');
                            ihook.setColumnValue(rowform, 'CNCPT_' || k || '_VER_NR_' || i, '');
                    end loop;
                nci_dec_mgmt.createValAIWithConcept(rowform , k,v_item_typ_glb ,'V','STRING',actions);
                ihook.setColumnValue(rowform, 'CTL_VAL_MSG', 'VALIDATED: Concept String will be used.');
                ihook.setColumnValue(rowform, 'CTL_VAL_STUS', '3');
     end if;

        if v_opt = 4 then
          --  for k in  1..2  loop
               nci_dec_mgmt.createValAIWithConcept(rowform , k,v_item_typ_glb ,'V','DROP-DOWN',actions);
               ihook.setColumnValue(rowform, 'CTL_VAL_MSG', 'VALIDATED: Concept drop-down will be used.');
               ihook.setColumnValue(rowform, 'CTL_VAL_STUS', '4');
         --   end loop;
        end if;

       ihook.setColumnValue(rowform, 'GEN_STR',replace(ihook.getColumnValue(rowform,'ITEM_1_NM'),'Integer::','') ) ;

        if (   ihook.getColumnValue(rowform, 'CNCPT_1_ITEM_ID_1') is null and v_opt > 2) then
                  ihook.setColumnValue(rowform, 'CTL_VAL_MSG', 'Concept missing');
                  is_valid := false;
        end if;
      end if;
        ihook.setColumnValue(rowform, 'STG_AI_ID', rep_idx);

        rowforms.extend;
                rowforms(rowforms.last) := rowform;

   end loop;


         -- If any of the test fails or if the user has triggered validation, then go back to the screen.
        if ( hookinput.answerid = 1 or is_valid = false) then

                hookOutput.forms := getPVVMCreateForm2(rowforms);
                HOOKOUTPUT.QUESTION    := getPVVMQuestion;
                return;
        end if;

    -- If all the tests have passed and the user has asked for create, then create DEC and optionally OC and Prop.

    v_cnt := 0;
            for rep_idx in 1..10 loop

                rowform :=rowforms(rep_idx);
                v_opt := nvl(ihook.getColumnValue(rowform, 'CTL_VAL_STUS'),0);
                if (v_opt > 0) then
                    IF v_opt in ( 3,4) and nvl(ihook.getColumnValue(rowform, 'UOM_ID'),0) = 0  THEN  -- Create; no duplicate allowed
                        nci_dec_mgmt.createValAIWithConcept(rowform , 1,v_item_typ_glb ,'C','DROP-DOWN',actions); -- Vm
                    end if;
                     IF v_opt in ( 3,4) and nvl(ihook.getColumnValue(rowform, 'UOM_ID'),0) = 1  THEN  -- Create; Duplicate
                        nci_dec_mgmt.createValAIWithConcept(rowform , 1,v_item_typ_glb ,'O','DROP-DOWN',actions); -- Vm
                    end if;
                    if (v_opt = 2 ) then
                        nci_dec_mgmt.createAIWithoutConcept(rowform , 1, 53, ihook.getColumnValue(rowform, 'ITEM_2_LONG_NM'),nvl(ihook.getColumnValue(rowform, 'ITEM_2_DEF'), ihook.getColumnValue(rowform, 'ITEM_2_LONG_NM')),
                        actions);
                    end if;

                      v_item_id := ihook.getColumnValue(rowform,'ITEM_1_ID');
                      v_ver_nr := ihook.getColumnValue(rowform,'ITEM_1_VER_NR');

                if (v_opt = 1 ) then
                      v_item_id := ihook.getColumnValue(rowform,'ITEM_2_ID');
                      v_ver_nr := ihook.getColumnValue(rowform,'ITEM_2_VER_NR');
                end if;

                    -- Create PV
      v_pv := ihook.getColumnValue(rowform,'PERM_VAL_NM');

                      if (v_opt = 2) then -- use specified value
                        v_pv :=  nvl(ihook.getColumnValue(rowform,'PERM_VAL_NM'),ihook.getColumnValue(rowform,'ITEM_2_LONG_NM') );
                      end if;
                      if (v_opt in (3,4)) then -- use specified value
                        v_pv :=  nvl(ihook.getColumnValue(rowform,'PERM_VAL_NM'),ihook.getColumnValue(rowform,'ITEM_1_NM') );
                      end if;

                        if (v_opt = 1 and v_pv is null) then -- use specified value
                            select item_nm into v_pv from admin_item where item_id = v_item_id and ver_nr = v_ver_nr;
                        end if;

                    select count(*) into v_temp from CONC_DOM_VAL_MEAN where CONC_DOM_ITEM_ID = ihook.getColumnValue(rowform, 'CONC_DOM_ITEM_ID') and
                    CONC_DOM_VER_NR = ihook.getColumnValue(rowform, 'CONC_DOM_VER_NR') and NCI_VAL_MEAN_ITEM_ID = v_item_id and NCI_VAL_MEAN_VER_NR = v_ver_nr;

                    if (v_temp = 0) then
                        rows := t_rows();
                        row := t_row();
                        ihook.setColumnValue(row,'CONC_DOM_ITEM_ID', ihook.getColumnValue(rowform, 'CONC_DOM_ITEM_ID'));
                        ihook.setColumnValue(row,'CONC_DOM_VER_NR', ihook.getColumnValue(rowform, 'CONC_DOM_VER_NR'));
                        ihook.setColumnValue(row,'NCI_VAL_MEAN_ITEM_ID',  v_item_id);
                        ihook.setColumnValue(row,'NCI_VAL_MEAN_VER_NR', nvl(ihook.getColumnValue(rowform, 'ITEM_1_VER_NR'),1));

                        rows.extend;
                        rows(rows.last) := row;
                        action := t_actionrowset(rows, 'Value Meanings', 2,10,'insert');
                        actions.extend;
                        actions(actions.last) := action;
                    end if;

                    if (v_pv is not null) then
                        select count(*) into v_temp from PERM_VAL where VAL_DOM_ITEM_ID = ihook.getColumnValue(row_ori, 'ITEM_ID') and
                        VAL_DOM_VER_NR = ihook.getColumnValue(row_ori, 'VER_NR') and NCI_VAL_MEAN_ITEM_ID = v_item_id and NCI_VAL_MEAN_VER_NR = v_ver_nr
                        and upper(PERM_VAL_NM) = upper(v_pv);

                        if (v_temp = 0) then
                            rows := t_rows();
                            row := t_row();
                            ihook.setColumnValue(row,'PERM_VAL_NM', v_pv);
                            ihook.setColumnValue(row,'VAL_DOM_ITEM_ID', ihook.getColumnValue(row_ori, 'ITEM_ID'));
                            ihook.setColumnValue(row,'VAL_DOM_VER_NR', ihook.getColumnValue(row_ori, 'VER_NR'));
                            ihook.setColumnValue(row,'NCI_VAL_MEAN_ITEM_ID',  v_item_id);
                            ihook.setColumnValue(row,'NCI_VAL_MEAN_VER_NR', 1);
                            v_cnt := v_cnt + 1;
                            ihook.setColumnValue(row,'VAL_ID',-1);
                            rows.extend;     rows(rows.last) := row;
                              action := t_actionrowset(rows, 'Permissible Values (Edit AI)', 2,19,'insert');
                               actions.extend;
                               actions(actions.last) := action;
                        end if;
                    end if;
        end if; -- v_opt > 0
        end loop;

        end if;

    if (actions.count > 0) then
        hookoutput.actions := actions;
        hookoutput.message := v_cnt || ' PV/VM created.';
         --   raise_application_error(-20000,'Inside 1' || v_item_id);

    end if;

END;

procedure spPVVMImport ( row_ori in out t_row, actions in out t_actions)
AS

  forms t_forms;
  form1 t_form;

  row t_row;
  rows  t_rows;
  rowset            t_rowset;
  v_str  varchar2(255);
 v_nm  varchar2(255);
 v_item_id number;
 v_ver_nr number(4,2);
  cnt integer;
k integer;
  action t_actionRowset;
  i integer := 0;
  v_typ  varchar2(50);
  v_temp integer;
  is_valid boolean;
  v_item_typ_glb integer;
  v_pv  varchar2(255);
begin
    v_item_typ_glb := 53;
        row := t_row();        rows := t_rows();
        k := 1;


    v_typ := upper(ihook.getColumnValue(row_ori, 'ITEM_2_LONG_NM'));

    case
    when v_typ = 'CONCEPTS' then
        nci_dec_mgmt.createValAIWithConcept(row_ori , 1,v_item_typ_glb ,'C','DROP-DOWN',actions); -- Vm
     when v_typ = 'TEXT' then
        nci_dec_mgmt.createAIWithoutConcept(row_ori , 1, 53, ihook.getColumnValue(row_ori, 'CNCPT_CONCAT_STR_1'),nvl(ihook.getColumnValue(row_ori, 'ITEM_1_DEF'), ihook.getColumnValue(row_ori, 'CNCPT_CONCAT_STR_1')),
        actions);

    end case;
      -- Create PV
        v_item_id := ihook.getColumnValue(row_ori,'ITEM_1_ID');
        v_ver_nr :=  ihook.getColumnValue(row_ori, 'ITEM_1_VER_NR');

        select count(*) into v_temp from CONC_DOM_VAL_MEAN where CONC_DOM_ITEM_ID = ihook.getColumnValue(row_ori, 'CONC_DOM_ITEM_ID') and
        CONC_DOM_VER_NR = ihook.getColumnValue(row_ori, 'CONC_DOM_VER_NR') and NCI_VAL_MEAN_ITEM_ID = v_item_id and NCI_VAL_MEAN_VER_NR = v_ver_nr;

--  If VM/CONC_DOM new
        if (v_temp = 0) then
        rows := t_rows();
        row := t_row();
        ihook.setColumnValue(row,'CONC_DOM_ITEM_ID', ihook.getColumnValue(row_ori, 'CONC_DOM_ITEM_ID'));
        ihook.setColumnValue(row,'CONC_DOM_VER_NR', ihook.getColumnValue(row_ori, 'CONC_DOM_VER_NR'));
        ihook.setColumnValue(row,'NCI_VAL_MEAN_ITEM_ID',  v_item_id);
        ihook.setColumnValue(row,'NCI_VAL_MEAN_VER_NR', v_ver_nr);

            rows.extend;
            rows(rows.last) := row;
          action := t_actionrowset(rows, 'Value Meanings', 2,10,'insert');
           actions.extend;
           actions(actions.last) := action;

      end if;
        rows := t_rows();
        row := t_row();
        ihook.setColumnValue(row,'PERM_VAL_NM', ihook.getColumnValue(row_ori, 'PERM_VAL_NM'));
        ihook.setColumnValue(row,'VAL_DOM_ITEM_ID', ihook.getColumnValue(row_ori, 'ITEM_2_ID'));
        ihook.setColumnValue(row,'VAL_DOM_VER_NR', ihook.getColumnValue(row_ori, 'ITEM_2_VER_NR'));
        ihook.setColumnValue(row,'NCI_VAL_MEAN_ITEM_ID',  v_item_id);
        ihook.setColumnValue(row,'NCI_VAL_MEAN_VER_NR', v_ver_nr);

        ihook.setColumnValue(row,'VAL_ID',-1);
            rows.extend;
            rows(rows.last) := row;

          action := t_actionrowset(rows, 'Permissible Values (Edit AI)', 2,19,'insert');
           actions.extend;
           actions(actions.last) := action;


        ihook.setColumnValue(row_ori,'CTL_VAL_STUS',  'PROCESSED');
        ihook.setColumnValue(row_ori,'CTL_VAL_MSG', 'Value Meaning ID: ' || v_item_id);




END;

-- Only called from VM Edit  Inplace Edit
PROCEDURE       VMEditCore ( v_init in t_rowset,  hookInput in t_hookInput, hookOutput in out t_hookOutput)
AS
  rowform t_row;
  forms t_forms;
  form1 t_form;
    v_temp_id number;
    v_temp_ver number(4,2);
    idx integer;
  row t_row;
  rows  t_rows;
  row_ori t_row;
  rowset            t_rowset;
 v_str  varchar2(255);
 v_nm  varchar2(255);
 v_item_id number;
 v_ver_nr number(4,2);
  cnt integer;
j integer;
k integer;
    actions t_actions := t_actions();
  action t_actionRowset;
  v_msg varchar2(1000);
  v_def varchar2(4000);
  v_temp integer;
  is_valid boolean;
  v_item_typ_glb integer;
  v_pv  varchar2(255);
  v_dup_item_id number;
  v_dup_ver_nr number(4,2);
  v_long_nm_suf varchar2(255);
  v_long_nm_suf_int varchar2(255);
  v_long_nm  varchar2(255);
  v_id number;
  v_err_str varchar2(255);
  v_cncpt_id number;
  v_cncpt_ver_nr number(4,2);
  is_dup boolean;
begin
    v_item_typ_glb := 53;
    row_ori :=  hookInput.originalRowset.rowset(1);
 is_dup := false;
   if hookInput.invocationNumber = 0 then
        --  Get question. Either create or edit
          HOOKOUTPUT.QUESTION    := getVMEditQuestion(hookinput.originalrowset.tablename, false);

          hookOutput.forms :=getVMEditForm(v_init);

    else
        forms              := hookInput.forms;
        form1              := forms(1);
        rowform := form1.rowset.rowset(1);
        row := t_row();        rows := t_rows();
        is_valid := true;
        k := 1;
        idx := 1;
        j :=0;

  --      if (HOOKINPUT.ANSWERID  in ( 1 ,3)) then  -- Validate using drop-down
             --- Only update definition and long name. No name change
                if  (ihook.getColumnValue(rowform, 'CNCPT_1_ITEM_ID_1') is not null) then
                idx := 1;
                   for i in 1..10 loop
                        v_temp_id := ihook.getColumnValue(rowform, 'CNCPT_' || idx  ||'_ITEM_ID_' || i);
                        v_temp_ver := ihook.getColumnValue(rowform, 'CNCPT_' || idx || '_VER_NR_' || i);
                        if (v_temp_id is not null) then
                        for cur in(select item_id, item_nm , item_long_nm , item_desc from admin_item where admin_item_typ_id = 49 and item_id = v_temp_id and ver_nr = v_temp_ver) loop
                                v_def := substr( v_def || '_' ||cur.item_desc  ,1,4000);
                                if (cur.item_id = v_int_cncpt_id and trim(ihook.getColumnValue(rowform,'CNCPT_INT_' || idx || '_' || i)) is not null ) then --- integer concept
                                            v_long_nm_suf_int := trim(v_long_nm_suf_int || ':' || cur.item_long_nm) || '::' || trim(ihook.getColumnValue(rowform,'CNCPT_INT_' || idx || '_' || i));
                                            v_def := v_def || '::' ||  trim(ihook.getColumnValue(rowform,'CNCPT_INT_' || idx || '_' || i));
                                else
                                            v_long_nm_suf_int := trim(v_long_nm_suf_int || ':' || cur.item_long_nm);
                                end if;
                            v_long_nm_suf := trim(v_long_nm_suf || ':' || cur.item_long_nm);
                        end loop;
                        end if;
                end loop;

              --  raise_application_error(-20000, v_long_nm_suf_int);

                 for cur in (select ext.* from nci_admin_item_ext ext,admin_item a
                where nvl(a.fld_delete,0) = 0 and a.item_id = ext.item_id and a.ver_nr = ext.ver_nr and cncpt_concat_with_int =substr(v_long_nm_suf_int,2) and a.admin_item_typ_id = v_item_typ_glb) loop
                        hookoutput.message :=  'WARNING: Duplicate found based on concepts: ' || cur.item_id;
                        v_dup_item_id := cur.item_id;
                        v_dup_ver_nr :=cur.ver_nr;
                        is_dup := true;
                end loop;
                ihook.setColumnValue(rowform, 'ITEM_1_DEF', substr(v_def,2));
               ihook.setColumnValue(rowform, 'ITEM_1_LONG_NM', substr(v_long_nm_suf,2));
               ihook.setColumnValue(rowform, 'ITEM_1_LONG_NM_INT', substr(v_long_nm_suf_int,2));
               rows := t_rows();  rows.extend;  rows(rows.last) := rowform;
               rowset := t_rowset(rows, 'VM Edit (Hook)', 1, 'NCI_STG_AI_CNCPT_CREAT');
               else
                  is_Valid := false;
                  hookoutput.message := 'You need to specify at least one concept.';
               rows := t_rows();  rows.extend;  rows(rows.last) := rowform;
               rowset := t_rowset(rows, 'VM Edit (Hook)', 1, 'NCI_STG_AI_CNCPT_CREAT');
                end if;
  --      end if;
        v_err_str := '';
     --    nci_11179_2.stdCncptRowValidation(rowform, 1,is_valid, v_err_str );
        hookoutput.message := hookoutput.message || ' ' || v_err_str;

        if (is_valid = false or HOOKINPUT.ANSWERID = 1) then
        if (is_valid = true and is_dup = false) then
                          hookoutput.message := 'VALIDATED';
        end if;
        if (is_dup = true and hookinput.originalRowset.tablename <> 'Administered Item') then
                HOOKOUTPUT.QUESTION    := getVMEditQuestion(hookinput.originalrowset.tablename, true);
        else
                HOOKOUTPUT.QUESTION    := getVMEditQuestion(hookinput.originalrowset.tablename, false);
        end if;
          hookOutput.forms :=getVMEditForm(rowset);
          return;
    end if;

        if (HOOKINPUT.ANSWERID = 2 and is_Valid = true) then
          v_item_id := ihook.getColumnValue(rowform, 'ITEM_1_ID');
          v_ver_nr :=ihook.getColumnValue(rowform, 'ITEM_1_VER_NR');

        -- Delete purge existing relationship
            rows := t_rows();
            for cur in (select * from cncpt_admin_item where item_id = v_item_id and ver_nr = v_ver_nr) loop
                row := t_row();
                ihook.setColumnValue(row,'CNCPT_AI_ID', cur.CNCPT_AI_ID);
                rows.extend; rows(rows.last) := row;

            end loop;
            if (rows.count > 0) then
            action := t_actionrowset(rows, 'Items under Concept (Hook)', 2,1,'delete');
            actions.extend;
            actions(actions.last) := action;
            action := t_actionrowset(rows, 'Items under Concept (Hook)', 2,2,'purge');
            actions.extend;
            actions(actions.last) := action;
            end if;

        if (ihook.getColumnValue(rowform, 'CNCPT_1_ITEM_ID_1') is not null) then  --- If drop-down specified, manually entered text is overwritten.
            rows := t_rows();

            for i in reverse 0..10 loop
                    v_cncpt_id := ihook.getColumnValue(rowform, 'CNCPT_' || idx  ||'_ITEM_ID_' || i);
                    v_cncpt_ver_nr :=  ihook.getColumnValue(rowform, 'CNCPT_' || idx || '_VER_NR_' || i);
                    if( v_cncpt_id is not null) then
                        for cur in (select item_nm, item_long_nm, item_desc from admin_item where item_id = v_cncpt_id and ver_nr = v_cncpt_ver_nr) loop
                                row := t_row();
                                ihook.setColumnValue(row,'ITEM_ID', v_item_id);
                                ihook.setColumnValue(row,'VER_NR', v_ver_nr);
                                ihook.setColumnValue(row,'CNCPT_ITEM_ID',v_cncpt_id);
                                ihook.setColumnValue(row,'CNCPT_VER_NR', v_cncpt_ver_nr);
                                ihook.setColumnValue(row,'NCI_ORD', j);
                                ihook.setColumnValue(row,'CNCPT_AI_ID', -1);
     if (v_cncpt_id = v_int_cncpt_id and trim(ihook.getColumnValue(rowform,'CNCPT_INT_' || idx || '_' || i)) is not null) then
                            ihook.setColumnValue(row,'NCI_CNCPT_VAL',ihook.getColumnValue(rowform,'CNCPT_INT_' || idx || '_' || i));

                        end if;

                         --       v_temp := v_temp || i || ':' ||  v_cncpt_id;
                                if j = 0 then
                                    ihook.setColumnValue(row,'NCI_PRMRY_IND', 1);
                                else ihook.setColumnValue(row,'NCI_PRMRY_IND', 0);
                                end if;

                                rows.extend;
                                rows(rows.last) := row;
                                j := j+ 1;
                        end loop;
                    end if;
            end loop;
            action := t_actionrowset(rows, 'Items under Concept (Hook)', 2,6,'insert');
            actions.extend;
            actions(actions.last) := action;
        end if;
        rows := t_rows();
        row := t_row();

       nci_11179.spReturnAIRow (v_item_id, v_ver_nr, row);
       nci_11179.spReturnAIExtRow (v_item_id, v_ver_nr,  row);

       ihook.setColumnValue(row,'ITEM_NM', ihook.getColumnValue(rowform, 'ITEM_1_NM'));
       -- Setting the Vm short name to id + version as per tracker 882
        ihook.setColumnValue(row,'ITEM_LONG_NM', v_item_id ||  'v' || trim(to_char(v_ver_nr, '9999.99')));

      ihook.setColumnValue(row,'ITEM_DESC', ihook.getColumnValue(rowform, 'ITEM_1_DEF'));
        ihook.setColumnValue(row,'ADMIN_STUS_ID', ihook.getColumnValue(rowform, 'ADMIN_STUS_ID'));
        ihook.setColumnValue(row,'REGSTR_STUS_ID', ihook.getColumnValue(rowform, 'REGSTR_STUS_ID'));

       ihook.setColumnValue(row,'CNCPT_CONCAT_DEF', ihook.getColumnValue(rowform, 'ITEM_1_DEF'));
       ihook.setColumnValue(row,'CNCPT_CONCAT', ihook.getColumnValue(rowform, 'ITEM_1_LONG_NM'));
       ihook.setColumnValue(row,'CNCPT_CONCAT_NM', ihook.getColumnValue(rowform, 'ITEM_1_NM'));
       ihook.setColumnValue(row,'CNCPT_CONCAT_WITH_INT', ihook.getColumnValue(rowform, 'ITEM_1_LONG_NM_INT'));
       rows.extend;
       rows(rows.last) := row;

        action := t_actionrowset(rows, 'Administered Item (No Sequence)', 2,7,'update');
        actions.extend;
        actions(actions.last) := action;


        action := t_actionrowset(rows, 'NCI AI Extension (Hook)', 2,8,'update');
        actions.extend;
        actions(actions.last) := action;
        end if;

    if (hookinput.answerid = 3 and is_dup = true) then
        rows := t_rows();
        row := row_ori;
        ihook.setColumnValue(row, 'NCI_VAL_MEAN_ITEM_ID', v_dup_item_id);
        ihook.setColumnValue(row, 'NCI_VAL_MEAN_VER_NR', v_dup_ver_nr);
       rows.extend;
       rows(rows.last) := row;

        action := t_actionrowset(rows, 'Permissible Values (Edit AI)', 2,1,'update');
        actions.extend;
        actions(actions.last) := action;
        hookoutput.message := 'Value Meaning assigned.' || v_dup_item_id;

    end if;
    if (actions.count > 0) then
        hookoutput.actions := actions;
    end if;


end if;

END;


-- Only called from VM Edit
PROCEDURE       VMCreateEditCore ( v_init in t_rowset,  hookInput in t_hookInput, hookOutput in out t_hookOutput)
AS
  rowform t_row;
  forms t_forms;
  form1 t_form;

  row t_row;
  rows  t_rows;
  row_ori t_row;
  rowset            t_rowset;
 v_str  varchar2(255);
 v_nm  varchar2(255);
 v_item_id number;
 v_ver_nr number(4,2);
  cnt integer;
k integer;
    actions t_actions := t_actions();
  action t_actionRowset;
  v_msg varchar2(1000);

  v_dec_nm varchar2(255);
  v_cncpt_nm varchar2(255);
  v_long_nm varchar2(255);
  v_def varchar2(4000);
  v_temp integer;
  is_valid boolean;
  v_item_typ_glb integer;
  v_pv  varchar2(255);
begin
    v_item_typ_glb := 53;
    row_ori :=  hookInput.originalRowset.rowset(1);

   if hookInput.invocationNumber = 0 then
        --  Get question. Either create or edit
          HOOKOUTPUT.QUESTION    := getVMCreateEditQuestion(hookinput.originalrowset.tablename);

          hookOutput.forms :=getVMCreateEditForm(v_init);

    else
        forms              := hookInput.forms;
        form1              := forms(1);
        rowform := form1.rowset.rowset(1);
        row := t_row();        rows := t_rows();
        is_valid := true;
        k := 1;


        if (HOOKINPUT.ANSWERID = 1 and ihook.getColumnValue(rowform, 'CNCPT_1_ITEM_ID_1') is not null) then  -- Validate using drop-down
               nci_dec_mgmt.createValAIWithConcept(rowform , k,v_item_typ_glb ,'V','DROP-DOWN',actions);
                  ihook.setColumnValue(rowform, 'VAL_DOM_ITEM_ID', ihook.getColumnValue(row_ori, 'VAL_DOM_ITEM_ID'));
    ihook.setColumnValue(rowform, 'VAL_DOM_VER_NR', ihook.getColumnValue(row_ori, 'VAL_DOM_VER_NR'));

               rows := t_rows();  rows.extend;  rows(rows.last) := rowform;
               rowset := t_rowset(rows, 'VM Create Edit (Hook)', 1, 'NCI_STG_AI_CNCPT_CREAT');
                HOOKOUTPUT.QUESTION    := getVMCreateEditQuestion(hookinput.originalrowset.tablename);

          hookOutput.forms :=getVMCreateEditForm(rowset);
          return;

        end if;

      if (HOOKINPUT.ANSWERID = 3 and ihook.getColumnValue(rowform, 'ITEM_2_ID') is null) then  -- Associate using specified but no value specified
               rows := t_rows();  rows.extend;  rows(rows.last) := rowform;
               rowset := t_rowset(rows, 'VM Create Edit (Hook)', 1, 'NCI_STG_AI_CNCPT_CREAT');
                hookoutput.message := 'No Value Meaning spectified';
                HOOKOUTPUT.QUESTION    := getVMCreateEditQuestion(hookinput.originalrowset.tablename);

          hookOutput.forms :=getVMCreateEditForm(rowset);
          return;

        end if;

    rows := t_rows();
        if (HOOKINPUT.ANSWERID = 2) then
         if (ihook.getColumnValue(rowform,'ITEM_1_ID') is null) then
             nci_dec_mgmt.createValAIWithConcept(rowform , 1,v_item_typ_glb ,'C','DROP-DOWN',actions);
            end if;
                ihook.setColumnValue(row_ori, 'NCI_VAL_MEAN_ITEM_ID', ihook.getColumnValue(rowform, 'ITEM_1_ID'));
              ihook.setColumnValue(row_ori, 'NCI_VAL_MEAN_VER_NR', ihook.getColumnValue(rowform, 'ITEM_1_VER_NR'));
                   rows.extend;
            rows(rows.last) := row_ori;
          action := t_actionrowset(rows, 'Permissible Values (Edit AI)', 2,19,'update');
           actions.extend;
           actions(actions.last) := action;

         --   end loop;

        end if;

        if (HOOKINPUT.ANSWERID = 3) then -- Associate using specified
                ihook.setColumnValue(row_ori, 'NCI_VAL_MEAN_ITEM_ID', ihook.getColumnValue(rowform, 'ITEM_2_ID'));
              ihook.setColumnValue(row_ori, 'NCI_VAL_MEAN_VER_NR', ihook.getColumnValue(rowform, 'ITEM_2_VER_NR'));
                   rows.extend;
            rows(rows.last) := row_ori;
          action := t_actionrowset(rows, 'Permissible Values (Edit AI)', 2,19,'update');
           actions.extend;
           actions(actions.last) := action;

         --   end loop;
         end if;


    if (actions.count > 0) then
        hookoutput.actions := actions;
    end if;


end if;

END;


function getPVVMQuestion return t_question
is
  question t_question;
  answer t_answer;
  answers t_answers;
begin

ANSWERS                    := T_ANSWERS();
    ANSWER                     := T_ANSWER(1, 1, 'Validate');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
      ANSWER                     := T_ANSWER(2, 2, 'Create');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
/*
 ANSWERS                    := T_ANSWERS();
    ANSWER                     := T_ANSWER(1, 1, 'Validate Using String');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
  --  ANSWERS                    := T_ANSWERS();
    ANSWER                     := T_ANSWER(2, 2, 'Validate Using Drop-Down');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
    ANSWER                     := T_ANSWER(3, 3, 'Create Using String');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
    ANSWER                     := T_ANSWER(4, 4, 'Create Using Drop-Down');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
      ANSWER                     := T_ANSWER(5, 5, 'Create Using Specified');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
          ANSWER                     := T_ANSWER(6, 6, 'Create Using Existing VM');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER; */
    QUESTION               := T_QUESTION('Create PV/VM', ANSWERS);

return question;
end;



function getPVVMQuestionBulk return t_question
is
  question t_question;
  answer t_answer;
  answers t_answers;
begin

 ANSWERS                    := T_ANSWERS();
    ANSWER                     := T_ANSWER(1, 1, 'Create');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
  QUESTION               := T_QUESTION('Create Multiple PV with/without VM Using Single Concept', ANSWERS);

return question;
end;

function getVMEditQuestion (v_src_tbl_nm in varchar2, v_dup in boolean) return t_question is
  question t_question;
  answer t_answer;
  answers t_answers;
begin
--- If Edit DEC
 ANSWERS                    := T_ANSWERS();
    ANSWER                     := T_ANSWER(1, 1, 'Validate Using Drop-Down');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
    ANSWER                     := T_ANSWER(2, 2, 'Update VM');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
    if (v_dup = true) then
    ANSWER                     := T_ANSWER(3, 3, 'Replace VM in PV');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
    end if;

    QUESTION               := T_QUESTION('Edit VM', ANSWERS);

return question;
end;


function getVMCreateEditQuestion (v_src_tbl_nm in varchar2) return t_question is
  question t_question;
  answer t_answer;
  answers t_answers;
begin
--- If Edit DEC
 ANSWERS                    := T_ANSWERS();
    ANSWER                     := T_ANSWER(1, 1, 'Validate Using Drop-Down');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
    ANSWER                     := T_ANSWER(2, 2, 'Associate Using Drop-Down');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
    ANSWER                     := T_ANSWER(3, 3, 'Associate Using Specified');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
    QUESTION               := T_QUESTION('Change PV Association', ANSWERS);

return question;
end;

-- Create form for Multi-concept VM
function getPVVMCreateForm (v_rowset in t_rowset) return t_forms is
  forms t_forms;
  form1 t_form;
begin
    forms                  := t_forms();
    form1                  := t_form('PV VM Creation (Hook)', 2,1);
    form1.rowset :=v_rowset;
    forms.extend;    forms(forms.last) := form1;
  return forms;
end;


-- Create form for Multi-concept VM
function getPVVMCreateForm2 (v_init_rows in t_rows) return t_forms is
  forms t_forms;
  form1 t_form;
  i integer;
  row t_row;
  rows t_rows;
  rowset t_rowset;
begin
    forms                  := t_forms();
   -- raise_application_error(-20000, 'Error' || v_init_rows.count);
    for i in 1..10 loop
      row := v_init_rows(i);
    rows := t_rows();    rows.extend;    rows(rows.last) := row;
    rowset := t_rowset(rows, 'AI Creation With Concepts', 1, 'NCI_STG_AI_CNCPT_CREAT'); -- Default values for form

    form1                  := t_form('PV VM Creation 5 (Hook)', 2,1);
    form1.rowset :=rowset;
    forms.extend;  forms(forms.last) := form1;
    end loop;
  return forms;
end;
function getVMEditForm (v_rowset in t_rowset) return t_forms is
  forms t_forms;
  form1 t_form;
begin
    forms                  := t_forms();
    form1                  := t_form('VM Edit (Hook)', 2,1);
    form1.rowset :=v_rowset;
    forms.extend;    forms(forms.last) := form1;
  return forms;
end;

function getVMCreateEditForm (v_rowset in t_rowset) return t_forms is
  forms t_forms;
  form1 t_form;
begin
    forms                  := t_forms();
    form1                  := t_form('VM Create Edit (Hook)', 2,1);
    form1.rowset :=v_rowset;
    forms.extend;    forms(forms.last) := form1;
  return forms;
end;

-- Create form for single concept VM
function getPVVMCreateFormBulk (v_rowset in t_rowset) return t_forms is
  forms t_forms;
  form1 t_form;
begin
    forms                  := t_forms();
    form1                  := t_form('PV VM Creation Single (Hook)', 2,1);
    form1.rowset :=v_rowset;
    forms.extend;    forms(forms.last) := form1;
  return forms;
end;


-- v_mode : V - Validate, C - Validation and Create;  v_cncpt_src:  STRING: String; DROP-DOWN: Drop-downs
procedure createVMConcept(rowform in out t_row, v_cncpt_src in varchar2, v_mode in varchar2,  actions in out t_actions) as
v_nm  varchar2(255);
v_long_nm varchar2(255);
v_def  varchar2(4000);
row t_row;
rows t_rows;
 action t_actionRowset;
 v_cncpt_id  number;
 v_cncpt_ver_nr number(4,2);
 v_temp_id  number;
 v_temp_ver number(4,2);
 v_item_id  number;
 v_ver_nr number(4,2);
 v_id integer;
 v_long_nm_suf  varchar2(255);
 j integer;
i integer;
cnt integer;
v_str varchar2(255);
v_obj_nm  varchar2(100);
v_temp varchar2(4000);
v_cncpt_nm varchar2(255);
idx integer;
v_item_typ_id integer;
begin

idx := 1;
v_item_typ_id := 53;

/*
3 possible scenarios

1. Clicked on update without changing anything. Do nothing.
2. Only updated specified name. No concepts. In this case, only update the name.
3.  Updated concepts. Delete existing concepts and add new concepts.

Only drop-downs allowed.

GEN_STR holds current VM name
ITEM_2_ID holds Item ID of VM and ITEM_2_VER_NR holds Version number
*/

-- Initialize variables if something has changed
        rows := t_rows();
        row := t_row();
        j := 0;
        v_item_id := ihook.getColumnValue(rowform, 'ITEM_2_ID');
        v_ver_nr := ihook.getColumnValue(rowform, 'ITEM_2_VER_NR');

-- If only name specified
            nci_11179.spReturnAIRow (v_item_id, v_ver_nr, row);
            nci_11179.spReturnAIExtRow (v_item_id, v_ver_nr,  row);
            ihook.setColumnValue(row,'ITEM_NM', ihook.getColumnValue(rowform, 'ITEM_2_NM'));
            ihook.setColumnValue(row,'ITEM_DESC', nvl(ihook.getColumnValue(rowform, 'ITEM_2_DEF'), ihook.getColumnValue(rowform, 'ITEM_2_NM')));
            ihook.setColumnValue(row,'CNCPT_CONCAT', ihook.getColumnValue(rowform, 'ITEM_2_NM'));
            ihook.setColumnValue(row,'CNCPT_CONCAT_NM', ihook.getColumnValue(rowform, 'ITEM_2_NM'));
            ihook.setColumnValue(row,'CNCPT_CONCAT_DEF', ihook.getColumnValue(row, 'ITEM_DESC'));

            rows.extend;     rows(rows.last) := row;

            action := t_actionrowset(rows, 'Administered Item (No Sequence)', 2,1,'update');
            actions.extend;
            actions(actions.last) := action;

            action := t_actionrowset(rows, 'NCI AI Extension (Hook)', 2,3,'update');
            actions.extend;
            actions(actions.last) := action;


-- Scenario 3 - first delete current concepts and then insert
        rows := t_rows();
        row := t_row();

        for cur in (select CNCPT_AI_ID from cncpt_admin_item where item_id = v_item_id and ver_nr = v_ver_nr) loop
                row := t_row();
                ihook.setColumnValue (row, 'CNCPT_AI_ID', cur.CNCPT_AI_ID);
                rows.extend;     rows(rows.last) := row;
        end loop;

        if rows.count > 0 then
            action := t_actionrowset(rows, 'Items under Concept (Hook)', 2,1,'delete');
            actions.extend;
            actions(actions.last) := action;

            action := t_actionrowset(rows, 'Items under Concept (Hook)', 2,2,'purge');
            actions.extend;
            actions(actions.last) := action;
        end if;

        rows := t_rows();

        if (ihook.getColumnValue(rowform, 'CNCPT_1_ITEM_ID_1') is not null) then  --- If drop-down specified, manually entered text is overwritten.
            for i in reverse 0..10 loop
                    v_cncpt_id := ihook.getColumnValue(rowform, 'CNCPT_' || idx  ||'_ITEM_ID_' || i);
                    v_cncpt_ver_nr :=  ihook.getColumnValue(rowform, 'CNCPT_' || idx || '_VER_NR_' || i);
                    if( v_cncpt_id is not null) then
                        for cur in (select item_nm, item_long_nm, item_desc from admin_item where item_id = v_cncpt_id and ver_nr = v_cncpt_ver_nr) loop
                                row := t_row();
                                ihook.setColumnValue(row,'ITEM_ID', v_item_id);
                                ihook.setColumnValue(row,'VER_NR', v_ver_nr);
                                ihook.setColumnValue(row,'CNCPT_ITEM_ID',v_cncpt_id);
                                ihook.setColumnValue(row,'CNCPT_VER_NR', v_cncpt_ver_nr);
                                ihook.setColumnValue(row,'NCI_ORD', j);
                                ihook.setColumnValue(row,'CNCPT_AI_ID', -1);

                                v_temp := v_temp || i || ':' ||  v_cncpt_id;
                                if j = 0 then
                                    ihook.setColumnValue(row,'NCI_PRMRY_IND', 1);
                                else ihook.setColumnValue(row,'NCI_PRMRY_IND', 0);
                                end if;
                                rows.extend;
                                rows(rows.last) := row;
                                j := j+ 1;
                        end loop;
                    end if;
            end loop;
            action := t_actionrowset(rows, 'Items under Concept (Hook)', 2,6,'insert');
            actions.extend;
            actions(actions.last) := action;
        end if;


end;



END;
/


DROP PACKAGE BODY ONEDATA_WA.NCI_UTIL;

CREATE OR REPLACE PACKAGE BODY ONEDATA_WA.nci_util AS

procedure debugHook ( v_param_val in varchar2, v_data_out in clob)
as
v_cnt integer;
begin
for cur in (select * from nci_mdr_cntrl where upper(param_nm) = 'HOOK_DEBUG' and upper(param_val) = upper(v_param_val)) loop
insert into NCI_MDR_DEBUG (DATA_CLOB, PARAM_VAL) values (v_data_out, v_param_val);
commit;
end loop;
end;

end;
/


DROP PACKAGE BODY ONEDATA_WA.NCI_VD;

CREATE OR REPLACE PACKAGE BODY ONEDATA_WA.nci_vd AS
c_long_nm_len  integer := 30;
c_nm_len integer := 255;
c_ver_suffix varchar2(5) := 'v1.00';
v_dflt_txt    varchar2(100) := 'Enter text or auto-generated.';

v_int_cncpt_id  number := 2433736;

function getVDCreateForm (v_rowset1 in t_rowset,v_rowset2 in t_rowset) return t_forms is
  forms t_forms;
  form1 t_form;
begin
    forms                  := t_forms();
    form1                  := t_form('Administered Item (Data Element CO)', 2,1);
    form1.rowset :=v_rowset1;
    forms.extend;    forms(forms.last) := form1;

    form1                  := t_form('Rep Term (Hook Creation)', 2,1);
    form1.rowset :=v_rowset2;
    forms.extend;    forms(forms.last) := form1;

  return forms;

end;

function getVDcreateQuestion(v_first in Boolean,V_from in number) return t_question is
  question t_question;
  answer t_answer;
  answers t_answers;
begin

 ANSWERS                    := T_ANSWERS();
    ANSWER                     := T_ANSWER(1, 1, 'Validate Using String');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
  --  ANSWERS                    := T_ANSWERS();
    ANSWER                     := T_ANSWER(2, 2, 'Validate Using Drop-Down');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
    IF v_first=false then
    ANSWER                     := T_ANSWER(3, 3, 'Create/Edit Using String');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
    ANSWER                     := T_ANSWER(4, 4, 'Create/Edit Using Drop-Down');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
    end IF;
    If V_from=1 then
    QUESTION               := T_QUESTION('Create New VD', ANSWERS);
    elsif V_from=2 then
    QUESTION               := T_QUESTION('Create VD from Existing', ANSWERS);
    else
    QUESTION               := T_QUESTION('Edit VD', ANSWERS);
    end if;
return question;
end;

procedure createVD (rowai in t_row, rowvd in t_row, actions in out t_actions, v_id out  number) as
v_nm  varchar2(255);
v_long_nm varchar2(255);
v_def  varchar2(4000);
v_dtype_id integer;
row t_row;
rows t_rows;
 action t_actionRowset;
 --v_id number;
begin
   rows := t_rows();
   row := rowai;
     v_id := nci_11179.getItemId;
        ihook.setColumnValue(row,'ITEM_ID', v_id);
      --  raise_application_error (-20000, ihook.getColumnValue(rowform,'CONC_DOM_ITEM_ID')  || ihook.getColumnValue(rowform, 'ITEM_1_ID') || ihook.getColumnValue(rowform, 'ITEM_2_ID'));
      if (ihook.getColumnValue(rowai, 'ITEM_LONG_NM') = v_dflt_txt or upper(ihook.getColumnValue(rowai, 'ITEM_LONG_NM')) = 'SYSGEN') then
         ihook.setColumnValue(row,'ITEM_LONG_NM', v_id || c_ver_suffix);
      end if;

    -- Create New.
      if (ihook.getColumnValue(rowai, 'ITEM_NM') = v_dflt_txt ) then
         ihook.setColumnValue(row,'ITEM_NM', ihook.getColumnValue(rowvd, 'ITEM_1_NM')  );
      end if;

    -- Remove INteger::
     ihook.setColumnValue(row,'ITEM_NM', replace(ihook.getColumnValue(row, 'ITEM_NM'),'Integer::','')  );

      if (ihook.getColumnValue(rowai, 'ITEM_DESC') = v_dflt_txt) then
        ihook.setColumnValue(row,'ITEM_DESC',substr(ihook.getColumnValue(rowvd, 'ITEM_1_DEF')  ,1,4000));
     end if;

     ihook.setColumnValue(row, 'ADMIN_ITEM_TYP_ID', 3);

        rows.extend;
        rows(rows.last) := row;
--raise_application_error(-20000, 'Deep' || ihook.getColumnValue(row,'CNTXT_ITEM_ID') || 'ggg'|| ihook.getColumnValue(row,'ADMIN_STUS_ID') || 'GGGG' || ihook.getColumnValue(row,'ITEM_ID'));

        action := t_actionrowset(rows, 'Administered Item (No Sequence)', 2,7,'insert');
        actions.extend;
        actions(actions.last) := action;
--Rep Term (Hook Creation)
        rows := t_rows();
        row := rowvd;
        ihook.setColumnValue(row,'ITEM_ID', v_id);
        ihook.setColumnValue(row,'VER_NR', 1);
        ihook.setColumnValue(row,'REP_CLS_ITEM_ID',  ihook.getColumnValue(rowvd,'ITEM_1_ID'));
        ihook.setColumnValue(row,'REP_CLS_VER_NR',  ihook.getColumnValue(rowvd,'ITEM_1_VER_NR'));
        ihook.setColumnValue(row, 'NCI_STD_DTTYPE_ID', nci_11179_2.getStdDataType(ihook.getColumnValue(row, 'DTTYPE_ID')));

--         if (ihook.getColumnValue(row, 'DTTYPE_ID') is null and  ihook.getColumnValue(row,'NCI_STD_DTTYPE_ID') is not null) then --- Tracker 667
--            select NCI_DFLT_LEGCY_ID into v_dtype_id from data_typ where DTTYPE_ID = ihook.getColumnValue(row,'NCI_STD_DTTYPE_ID');
--            ihook.setColumnValue(row, 'DTTYPE_ID', v_dtype_id);
--        end if;
        rows.extend;
        rows(rows.last) := row;
       action := t_actionrowset(rows, 'Value Domain', 2,8,'insert');
       actions.extend;
       actions(actions.last) := action;


end;


procedure createSA (rowai in t_row, rowcncpt in t_row, v_item_typ_id in integer, actions in out t_actions, v_id out  number) as
v_nm  varchar2(255);
v_long_nm varchar2(255);
v_def  varchar2(4000);
v_dtype_id integer;
row t_row;
rows t_rows;
v_obj_nm varchar2(100);
v_cncpt_id number;
v_cncpt_ver_nr number(4,2);
j integer;
idx integer;
 action t_actionRowset;
 --v_id number;
begin
    rows := t_rows();
    row := rowai;
    v_id := nci_11179.getItemId;
    idx := 1;

    ihook.setColumnValue(row,'ITEM_ID', v_id);
    if (ihook.getColumnValue(rowai, 'ITEM_LONG_NM') = v_dflt_txt) then
         ihook.setColumnValue(row,'ITEM_LONG_NM',nci_11179_2.getStdShortName(v_id, 1));
    end if;
    ihook.setColumnValue(row, 'ADMIN_ITEM_TYP_ID', v_item_typ_id);

    -- Remove Integer++ from VM only
    if (v_item_typ_id = 53) then
        ihook.setColumnValue(row, 'ITEM_NM', replace(ihook.getColumnValue(rowai, 'ITEM_NM'), 'Integer::',''));
    end if;
    ihook.setColumnValue(row,'CNCPT_CONCAT', ihook.getColumnValue(rowcncpt, 'ITEM_1_LONG_NM'));
    ihook.setColumnValue(row,'CNCPT_CONCAT_DEF', ihook.getColumnValue(rowai, 'ITEM_DESC'));
    ihook.setColumnValue(row,'CNCPT_CONCAT_NM', ihook.getColumnValue(rowai, 'ITEM_NM'));
  ihook.setColumnValue(row,'CNCPT_CONCAT_WITH_INT', ihook.getColumnValue(rowcncpt, 'ITEM_1_LONG_NM_INT'));

    rows.extend;
    rows(rows.last) := row;

    action := t_actionrowset(rows, 'Administered Item (No Sequence)', 2,7,'insert');
    actions.extend;
    actions(actions.last) := action;
    action := t_actionrowset(rows, 'NCI AI Extension (Hook)', 2,3,'insert');
    actions.extend;        actions(actions.last) := action;

    if v_item_typ_id = 7 then
            v_obj_nm := 'Representation Class';
    else
          v_obj_nm := 'Value Meaning';
    end if;
    action := t_actionrowset(rows, v_obj_nm, 2,8,'insert');
    actions.extend;       actions(actions.last) := action;

    rows := t_rows();
    if (v_item_typ_id = 53) then  --- VM
        j := 0;
        for i in reverse 1..10 loop
            v_cncpt_id := ihook.getColumnValue(rowcncpt, 'CNCPT_' || idx  ||'_ITEM_ID_' || i);
             v_cncpt_ver_nr :=  ihook.getColumnValue(rowcncpt, 'CNCPT_' || idx || '_VER_NR_' || i);
            if( v_cncpt_id is not null) then
                        row := t_row();
                        ihook.setColumnValue(row,'ITEM_ID', v_id);
                        ihook.setColumnValue(row,'VER_NR', 1);
                        ihook.setColumnValue(row,'CNCPT_ITEM_ID',v_cncpt_id);
                        ihook.setColumnValue(row,'CNCPT_VER_NR', v_cncpt_ver_nr);
                        ihook.setColumnValue(row,'NCI_ORD', j);
                        if j = 0 then
                            ihook.setColumnValue(row,'NCI_PRMRY_IND', 1);
                        else ihook.setColumnValue(row,'NCI_PRMRY_IND', 0);
                        end if;
                        if (v_cncpt_id = v_int_cncpt_id and trim(ihook.getColumnValue(rowcncpt,'CNCPT_INT_' || idx || '_' || i)) is not null) then
                            ihook.setColumnValue(row,'NCI_CNCPT_VAL',ihook.getColumnValue(rowcncpt,'CNCPT_INT_' || idx || '_' || i));
                        end if;

                        rows.extend;
                        rows(rows.last) := row;
                        j := j+ 1;
            end if;
        end loop;
        end if;
        if (v_item_typ_id = 7) then
             j := 1;
        for i in reverse 2..10 loop

          v_cncpt_id := ihook.getColumnValue(rowcncpt, 'CNCPT_' || idx  ||'_ITEM_ID_' || i);
             v_cncpt_ver_nr :=  ihook.getColumnValue(rowcncpt, 'CNCPT_' || idx || '_VER_NR_' || i);
          if( v_cncpt_id is not null) then
    --   raise_application_error(-20000, 'Test'  || i || v_cncpt_id);
            row := t_row();
            ihook.setColumnValue(row,'ITEM_ID', v_id);
            ihook.setColumnValue(row,'VER_NR', 1);
            ihook.setColumnValue(row,'CNCPT_ITEM_ID',v_cncpt_id);
            ihook.setColumnValue(row,'CNCPT_VER_NR', v_cncpt_ver_nr);
            ihook.setColumnValue(row,'NCI_ORD', j);
                   ihook.setColumnValue(row,'NCI_PRMRY_IND', 0);
       if (v_cncpt_id = v_int_cncpt_id and trim(ihook.getColumnValue(rowcncpt,'CNCPT_INT_' || idx || '_' || i)) is not null) then
                            ihook.setColumnValue(row,'NCI_CNCPT_VAL',ihook.getColumnValue(rowcncpt,'CNCPT_INT_' || idx || '_' || i));
                        end if;

            rows.extend;
            rows(rows.last) := row;
            j := j+ 1;
        end if;
        end loop;


          v_cncpt_id := ihook.getColumnValue(rowcncpt, 'CNCPT_' || idx  ||'_ITEM_ID_1' );
             v_cncpt_ver_nr :=  ihook.getColumnValue(rowcncpt, 'CNCPT_' || idx || '_VER_NR_1' );
            row := t_row();
            ihook.setColumnValue(row,'ITEM_ID', v_id);
            ihook.setColumnValue(row,'VER_NR', 1);
            ihook.setColumnValue(row,'CNCPT_ITEM_ID',v_cncpt_id);
            ihook.setColumnValue(row,'CNCPT_VER_NR', v_cncpt_ver_nr);
            ihook.setColumnValue(row,'NCI_ORD', 0);
            ihook.setColumnValue(row,'NCI_PRMRY_IND', 1);
             if (v_cncpt_id = v_int_cncpt_id and trim(ihook.getColumnValue(rowcncpt,'CNCPT_INT_' || idx || '_1' )) is not null) then
                            ihook.setColumnValue(row,'NCI_CNCPT_VAL',ihook.getColumnValue(rowcncpt,'CNCPT_INT_' || idx || '_1'));
                end if;

            rows.extend;
            rows(rows.last) := row;

        end if;
     action := t_actionrowset(rows, 'Items under Concept (Hook)', 2,50,'insert');
        actions.extend;
        actions(actions.last) := action;


end;

procedure spVDValCreateImport ( rowform in out t_row , v_op  in varchar2, actions in out t_actions,  v_val_ind in out boolean)
AS

    row t_row;
    rows  t_rows;
    row_ori t_row;
    v_id number;
    v_ver_nr number(4,2);
    v_nm  varchar2(255);
    action t_actionRowset;
    v_msg varchar2(1000);
    i integer := 0;
    v_item_nm varchar2(255);
    v_item_id number;
    v_rep_id number;
    v_rep_ver number(4,2);
    v_item_desc varchar2(4000);
    v_count number;
    v_valid boolean;
    v_temp varchar2(100);
    v_substr  varchar2(100);
    v_temp_id number;
    v_temp_ver number(4,2);
    rowsetvd t_rowset;
    rowsetai t_rowset;
    rowsetrp t_rowset;
    rowset            t_rowset;
     v_rep_nm varchar2(255);
    v_cncpt_nm varchar2(255);
    v_long_nm varchar2(255);
    v_def varchar2(4000);
    v_dtype_id integer;
 BEGIN

 if (ihook.getColumnValue(rowform, 'VAL_DOM_ITEM_ID') is null) then --- only if Value Domain not specified
        if (   ihook.getColumnValue(rowform, 'CNCPT_3_ITEM_ID_1') is null ) then
                  ihook.setColumnValue(rowform, 'CTL_VAL_MSG', ihook.getColumnValue(rowform, 'CTL_VAL_MSG') || 'Rep Term primary concept missing.' || chr(13));
                  v_val_ind  := false;
        end if;

        if (   ihook.getColumnValue(rowform, 'VAL_DOM_TYP_ID') is null ) then
                  ihook.setColumnValue(rowform, 'CTL_VAL_MSG', ihook.getColumnValue(rowform, 'CTL_VAL_MSG') || 'Value Domain Type is missing.' || chr(13));
                  v_val_ind  := false;
        end if;

        if (   ihook.getColumnValue(rowform, 'NCI_STD_DTTYPE_ID') is null ) then
                  ihook.setColumnValue(rowform, 'CTL_VAL_MSG', ihook.getColumnValue(rowform, 'CTL_VAL_MSG') || 'Standard Data Type is missing.' || chr(13));
                  v_val_ind  := false;
        end if;

          if (   ihook.getColumnValue(rowform, 'CONC_DOM_ITEM_ID') is null and ihook.getColumnValue(rowform, 'VD_CONC_DOM_ITEM_ID') is null) then
                  ihook.setColumnValue(rowform, 'CTL_VAL_MSG', ihook.getColumnValue(rowform, 'CTL_VAL_MSG') || 'VD Conceptual Domain is missing.' || chr(13));
                  v_val_ind  := false;
        end if;


      if (ihook.getColumnValue(rowform, 'DTTYPE_ID') is null and  ihook.getColumnValue(rowform,'NCI_STD_DTTYPE_ID') is not null) then --- Tracker 667
            select NCI_DFLT_LEGCY_ID into v_dtype_id from data_typ where DTTYPE_ID = ihook.getColumnValue(rowform,'NCI_STD_DTTYPE_ID');
            ihook.setColumnValue(rowform, 'DTTYPE_ID', v_dtype_id);
        end if;



    IF v_op  = 'C'  and v_val_ind = true THEN  -- Create

        createValAIWithConcept(rowform , 3,7,'C','DROP-DOWN',actions); -- Rep

                createVDImport(rowform, actions);

        end if;

 else -- if VD specified
        for cur in (select item_nm from admin_item where item_id = ihook.getColumnValue(rowform, 'VAL_DOM_ITEM_ID') and ver_nr = ihook.getColumnValue(rowform, 'VAL_DOM_VER_NR')) loop
       ihook.setColumnValue(rowform, 'VAL_DOM_NM',cur.item_nm ) ;
        end loop;
end if;


--V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);


END;


  procedure createVDImport(rowform in out t_row, actions in out t_actions)
   as
v_nm  varchar2(255);
v_long_nm varchar2(255);
v_def  varchar2(4000);
v_dtype_id integer;
row t_row;
rows t_rows;
 action t_actionRowset;
 v_id number;
begin
   rows := t_rows();
   row := rowform;
     v_id := nci_11179.getItemId;
        ihook.setColumnValue(row,'ITEM_ID', v_id);
        ihook.setColumnValue(rowform,'VAL_DOM_ITEM_ID_CREAT', v_id);

         ihook.setColumnValue(row,'ITEM_LONG_NM', v_id || c_ver_suffix);

         ihook.setColumnValue(row,'ITEM_NM',  nvl(ihook.getColumnValue(rowform, 'VAL_DOM_NM'),ihook.getColumnValue(rowform, 'ITEM_3_NM'))  );
        ihook.setColumnValue(row,'ITEM_DESC',substr(ihook.getColumnValue(rowform, 'ITEM_3_DEF')  ,1,4000));

     ihook.setColumnValue(row, 'ADMIN_ITEM_TYP_ID', 3);
        ihook.setColumnValue(row,'REP_CLS_ITEM_ID',  ihook.getColumnValue(rowform,'ITEM_3_ID'));
        ihook.setColumnValue(row,'REP_CLS_VER_NR',  ihook.getColumnValue(rowform,'ITEM_3_VER_NR'));
        ihook.setColumnValue(row,'CONC_DOM_ITEM_ID',  nvl(ihook.getColumnValue(rowform,'VD_CONC_DOM_ITEM_ID'),ihook.getColumnValue(rowform,'CONC_DOM_ITEM_ID')));
        ihook.setColumnValue(row,'CONC_DOM_VER_NR',  nvl(ihook.getColumnValue(rowform,'VD_CONC_DOM_VER_NR'),ihook.getColumnValue(rowform,'CONC_DOM_VER_NR')));
          nci_11179_2.setStdAttr(row);


        rows.extend;
        rows(rows.last) := row;
--raise_application_error(-20000, 'Deep' || ihook.getColumnValue(row,'CNTXT_ITEM_ID') || 'ggg'|| ihook.getColumnValue(row,'ADMIN_STUS_ID') || 'GGGG' || ihook.getColumnValue(row,'ITEM_ID'));

        action := t_actionrowset(rows, 'Administered Item (No Sequence)', 2,7,'insert');
        actions.extend;
        actions(actions.last) := action;

--Rep Term (Hook Creation)
        action := t_actionrowset(rows, 'Value Domain', 2,8,'insert');
       actions.extend;
       actions(actions.last) := action;
   ihook.setColumnValue(rowform, 'CTL_VAL_MSG', ihook.getColumnValue(rowform, 'CTL_VAL_MSG') || 'VD Created Successfully with ID ' || v_id || chr(13)) ;


end;




  PROCEDURE       spVDCommon ( v_init_ai in t_rowset,v_init_vd in t_rowset,v_from in number,  v_op  in varchar2,  hookInput in t_hookInput, hookOutput in out t_hookOutput)
AS

  showRowset t_showableRowset;
    rowform t_row;
    rowai t_row;
    rowvd t_row;
    forms t_forms;
    form1 t_form;
    row t_row;
    rows  t_rows;
    row_ori t_row;
    v_id number;
    v_ver_nr number(4,2);
    v_nm  varchar2(255);
    actions t_actions := t_actions();
    action t_actionRowset;
    v_msg varchar2(1000);
    i integer := 0;
    v_item_nm varchar2(255);
    v_item_id number;
    v_rep_id number;
    v_rep_ver number(4,2);
    v_item_desc varchar2(4000);
    v_count number;
    v_valid boolean;
    v_temp varchar2(100);
    v_substr  varchar2(100);
    v_temp_id number;
    v_temp_ver number(4,2);
    rowsetvd t_rowset;
    rowsetai t_rowset;
    rowsetrp t_rowset;
    rowvdold t_row;
    rowset            t_rowset;
     v_rep_nm varchar2(255);
    v_cncpt_nm varchar2(255);
    v_long_nm varchar2(255);
    v_def varchar2(4000);
    is_valid boolean;
    v_dtype_id integer;
    v_err_str varchar2(4000);
 BEGIN


    if hookInput.invocationNumber = 0 then
        --  Get question. Either create or edit
        hookOutput.question    := getVDCreateQuestion(true,v_from);

        -- Send initial rowset to create the form.
        hookOutput.forms := getVDCreateForm(v_init_ai,v_init_vd);

  ELSE
 --          raise_application_error(-20000, 'Here 1');
        forms              := hookInput.forms;
        form1              := forms(1);
        rowai := form1.rowset.rowset(1);
        form1              := forms(2);
        rowvd := form1.rowset.rowset(1);
        row := t_row();
        rows := t_rows();
        is_valid := true;

        if (v_op ='update') then
            row_ori :=  hookInput.originalRowset.rowset(1);

                    v_item_id := ihook.getColumnValue(row_ori,'ITEM_ID');
                    v_ver_nr := ihook.getColumnValue(row_ori,'VER_NR');

        end if;
    IF HOOKINPUT.ANSWERID = 1 or Hookinput.answerid = 3 THEN  -- Validate using string

                for i in  2..10 loop
                        ihook.setColumnValue(rowvd, 'CNCPT_1_ITEM_ID_' || i,'');
                        ihook.setColumnValue(rowvd, 'CNCPT_1_VER_NR_' || i, '');
                end loop;
           --     raise_application_error(-20000, 'Here');

               createValAIWithConcept(rowvd ,  1,7,'V','STRING',actions);

    end if;

    IF HOOKINPUT.ANSWERID = 2 or Hookinput.answerid = 4 THEN  -- Validate using drop-down
               createValAIWithConcept(rowvd , 1,7,'V','DROP-DOWN',actions);
    end if;

      --ihook.setColumnValue(rowform, 'GEN_STR',v_dec_nm ) ;
       ihook.setColumnValue(rowvd, 'GEN_STR',replace(ihook.getColumnValue(rowvd,'ITEM_1_NM'),'Integer::','')  ) ;
       ihook.setColumnValue(rowvd, 'CTL_VAL_MSG', 'VALIDATED');

      if (ihook.getColumnValue(rowvd, 'DTTYPE_ID') is null and  ihook.getColumnValue(rowvd,'NCI_STD_DTTYPE_ID') is not null) then --- Tracker 667
            select NCI_DFLT_LEGCY_ID into v_dtype_id from data_typ where DTTYPE_ID = ihook.getColumnValue(rowvd,'NCI_STD_DTTYPE_ID');
            ihook.setColumnValue(rowvd, 'DTTYPE_ID', v_dtype_id);
        --    raise_application_error(-20000, v_dtype_id);
        end if;



        if (   ihook.getColumnValue(rowvd, 'CNCPT_1_ITEM_ID_1') is null ) then
                  ihook.setColumnValue(rowvd, 'CTL_VAL_MSG', 'Rep Term missing.');
                  is_valid := false;
        end if;

-- Create new
        if (   ihook.getColumnValue(rowai, 'ADMIN_STUS_ID') = 75 and  ihook.getColumnValue(rowvd, 'VAL_DOM_TYP_ID') =  17
        and v_op = 'insert' and v_from <> 2) then -- Status cannot be released if VD is enumerated
                  ihook.setColumnValue(rowvd, 'CTL_VAL_MSG', 'An Enumerated VD WFS cannot be Released if there are no permissible values.');
                  is_valid := false;
        end if;
-- Edit
       if (   ihook.getColumnValue(rowai, 'ADMIN_STUS_ID') = 75 and  ihook.getColumnValue(rowvd, 'VAL_DOM_TYP_ID') =  17
        and v_op = 'update' ) then -- Status cannot be released if VD is enumerated
            select count(*) into v_temp from perm_val where val_dom_item_id = v_item_id and val_dom_Ver_nr = v_ver_nr and nvl(fld_delete,0) = 0;
            if v_temp = 0 then
                  ihook.setColumnValue(rowvd, 'CTL_VAL_MSG', 'An Enumerated VD WFS cannot be Released if there are no permissible values.');
                  is_valid := false;
                end if;
        end if;

-- Create from Existing
         if (   ihook.getColumnValue(rowai, 'ADMIN_STUS_ID') = 75 and  ihook.getColumnValue(rowvd, 'VAL_DOM_TYP_ID') =  17
        and v_op = 'insert' and v_from = 2) then -- Status cannot be released if VD is enumerated
         row_ori :=  hookInput.originalRowset.rowset(1);
            select count(*) into v_temp from perm_val where val_dom_item_id = ihook.getColumnValue(row_ori,'ITEM_ID')
            and val_dom_Ver_nr = ihook.getColumnValue(row_ori,'VER_NR') and nvl(fld_delete,0) = 0;
            if v_temp = 0 then
                  ihook.setColumnValue(rowvd, 'CTL_VAL_MSG', 'An Enumerated VD WFS cannot be Released if there are no permissible values.');
                  is_valid := false;
                end if;

        end if;
--raise_application_error(-20000, ihook.getColumnValue(rowai,'ITEM_LONG_NM'));
-- Short name uniqueness
--raise_application_error(-20000, ihook.getColumnValue(rowai,'ITEM_LONG_NM'));
   v_err_str := '';
    nci_11179_2.stdAIValidation(rowai, 3,is_valid, v_err_str );
  --  nci_11179_2.stdCncptRowValidation(rowvd, 1,is_valid, v_err_str );

        if (v_err_str is not null) then
        ihook.setColumnValue(rowvd, 'CTL_VAL_MSG', v_err_Str);
        end if;
         rows := t_rows();

              if (v_op = 'insert') then -- create from existing then update name and definition
                    ihook.setColumnValue(rowai,'ITEM_NM', replace(ihook.getColumnValue(rowvd,'ITEM_1_NM' ),'Integer::',''));
                    ihook.setColumnValue(rowai,'ITEM_DESC', ihook.getColumnValue(rowvd,'ITEM_1_DEF'));

                end if;
             -- If any of the test fails or if the user has triggered validation, then go back to the screen.
        if is_valid=false or hookinput.answerid in (1, 2) then
                rows := t_rows();
                rows.extend;

            --- Add Concept to name if edit and concepts changed. Tracker 866
           if (v_op = 'update') then
                rowvdold := v_init_vd.rowset(1);
                v_nm := ihook.getColumnValue(rowai, 'ITEM_NM');
                v_def := ihook.getColumnValue(rowai, 'ITEM_DESC');

                for i in 1..10 loop
                    if (ihook.getColumnValue(rowvd, 'CNCPT_1_ITEM_ID_' || i) <> nvl(ihook.getColumnValue(rowvdold, 'CNCPT_1_ITEM_ID_' || i),0) ) then
                       for cur in (select item_nm, item_desc from admin_item  where item_id = ihook.getColumnValue(rowvd, 'CNCPT_1_ITEM_ID_' || i) and ver_nr = ihook.getColumnValue(rowvd, 'CNCPT_1_VER_NR_' || i)) loop
                        v_nm := v_nm || ' ' || cur.item_nm;
                        v_def := v_def || '_' || cur.item_desc;

                       end loop;
                    end if;
                end loop;
                ihook.setColumnValue (rowai, 'ITEM_NM', v_nm);
                ihook.setColumnValue (rowai, 'ITEM_DESC', v_def);
            end if;

                ihook.setColumnValue(rowai,'ADMIN_ITEM_TYP_ID', 3);

                rows(rows.last) := rowai;
                rowsetai := t_rowset(rows, 'Administered Item (Hook Creation)', 1, 'ADMIN_ITEM');
                rows := t_rows();
                rows.extend;
                rows(rows.last) := rowvd;
                rowset := t_rowset(rows, 'Rep Term (Hook Creation)', 1, 'NCI_STG_AI_CNCPT_CREAT');
                hookoutput.message := ihook.getColumnValue(rowvd, 'CTL_VAL_MSG');
                      hookOutput.forms := getVDCreateForm(rowsetai,rowset);
                HOOKOUTPUT.QUESTION    := getVDCreateQuestion(false,v_from);
        end if;


     -- If all the tests have passed and the user has asked for create, then create VD and Repp.
    -- raise_application_error(-20000, 'Here2');
    IF HOOKINPUT.ANSWERID in ( 3,4)  and is_valid = true THEN  -- Create
        ihook.setColumnValue(rowvd, 'CNTXT_ITEM_ID', ihook.getColumnValue(rowai,'CNTXT_ITEM_ID'));
        ihook.setColumnValue(rowvd, 'CNTXT_VER_NR', ihook.getColumnValue(rowai,'CNTXT_VER_NR'));

        createValAIWithConcept(rowvd , 1,7,'C','DROP-DOWN',actions); -- Rep

              if (v_op = 'insert') then
                createVD(rowai, rowvd, actions, v_item_id);
                hookoutput.message := 'VD Created Successfully with ID ' || v_item_id ;

              else
                -- Update VD. Get the selected row, update name, definition, context.
                    row := t_row();
                    row_ori :=  hookInput.originalRowset.rowset(1);

                    v_item_id := ihook.getColumnValue(row_ori,'ITEM_ID');
                    v_ver_nr := ihook.getColumnValue(row_ori,'VER_NR');

                     --- Update name, definition, context
                    row := rowai;
                         ihook.setColumnValue(row, 'ADMIN_ITEM_TYP_ID', 3);
            rows := t_rows();    rows.extend;    rows(rows.last) := row;
                action := t_actionrowset(rows, 'Administered Item (No Sequence)', 2,10,'update');
                actions.extend;
                actions(actions.last) := action;
                row := rowvd;
           -- Get the Sub-type row. Update REP CD.

         --   nci_11179.spReturnSubtypeRow (v_item_id, v_ver_nr, 2, row );
            ihook.setColumnValue(row, 'REP_CLS_ITEM_ID', ihook.getColumnValue(rowvd,'ITEM_1_ID'));
            ihook.setColumnValue(row, 'REP_CLS_VER_NR', ihook.getColumnValue(rowvd,'ITEM_1_VER_NR'));
            ihook.setColumnValue(row, 'ITEM_ID', v_item_id);
            ihook.setColumnValue(row, 'VER_NR', v_ver_nr);


             rows := t_rows();    rows.extend;    rows(rows.last) := row;
             action := t_actionrowset(rows, 'Value Domain', 2,11,'update');
        actions.extend;
        actions(actions.last) := action;
        end if;

        if (v_from = 2 and v_op = 'insert') then --- create from existing and enumerated copy Perm Val
             rows := t_rows();
               row_ori := hookinput. originalrowset.rowset(1);

            nci_11179.CopyPermVal (actions, ihook.getColumnValue(row_ori,'ITEM_ID'), ihook.getColumnValue(row_ori,'VER_NR'), v_item_id, 1);

        end if;


        hookoutput.actions := actions;

    end if;

end if;

--V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);


END;
--

 procedure SACommonRT ( v_init_ai in t_rowset, v_item_typ_id in integer, hookInput in t_hookInput, hookOutput in out t_hookOutput)
 AS

  showRowset t_showableRowset;
    rowform t_row;
    rowai t_row;
    rowst t_row;
    rowcncpt t_row;
    forms t_forms;
    form1 t_form;
    row t_row;
    rows  t_rows;
    row_ori t_row;
    v_id number;
    v_ver_nr number(4,2);
    v_nm  varchar2(255);
    actions t_actions := t_actions();
    action t_actionRowset;
    v_msg varchar2(1000);
    i integer := 0;
    v_item_nm varchar2(255);
    v_item_id number;
    v_rep_id number;
    v_rep_ver number(4,2);
    v_item_desc varchar2(4000);
    v_count number;
    v_valid boolean;
    v_temp varchar2(100);
    v_substr  varchar2(100);
    v_temp_id number;
    v_temp_ver number(4,2);
     rowsetai t_rowset;
    rowsetcncpt t_rowset;
    rowset            t_rowset;
     v_rep_nm varchar2(255);
    v_cncpt_nm varchar2(255);
    v_long_nm varchar2(255);
    v_def varchar2(4000);
    is_valid boolean;
    v_err_str varchar2(4000);

 BEGIN


    if hookInput.invocationNumber = 0 then
        --  Get question. Either create or edit
        hookOutput.question    := getSACreateQuestion(true,v_item_typ_id);
  row := t_row();
    ihook.setColumnValue(row, 'STG_AI_ID', 1);
    rows := t_rows(); rows.extend;    rows(rows.last) := row;
    rowsetcncpt := t_rowset(rows, 'Rep Term (Stand Alone)', 1, 'NCI_STG_AI_CNCPT_CREAT'); -- Default values for cncpt form

        -- Send initial rowset to create the form.
        hookOutput.forms := getSACreateForm(v_init_ai, rowsetcncpt, v_item_typ_id);

  ELSE
 --          raise_application_error(-20000, 'Here 1');
        forms              := hookInput.forms;
        form1              := forms(1);
        rowai := form1.rowset.rowset(1);
        form1              := forms(2);
        rowcncpt := form1.rowset.rowset(1);
        row := t_row();
        rows := t_rows();
        is_valid := true;

-- Context is always going to be NCIP for VM and RT
        ihook.setColumnValue(rowai,'CNTXT_ITEM_ID',20000000024); -- NCIP
        ihook.setColumnValue(rowai,'CNTXT_VER_NR', 1);
    IF HOOKINPUT.ANSWERID = 1 or Hookinput.answerid = 3 THEN  -- Validate using string
               for i in  2..10 loop
                        ihook.setColumnValue(rowcncpt, 'CNCPT_1_ITEM_ID_' || i,'');
                        ihook.setColumnValue(rowcncpt, 'CNCPT_1_VER_NR_' || i, '');
                end loop;
               createValAIWithConcept(rowcncpt ,  1,v_item_typ_id,'V','STRING',actions);
    end if;

    IF HOOKINPUT.ANSWERID = 2 or Hookinput.answerid = 4 THEN  -- Validate using drop-down
               createValAIWithConcept(rowcncpt , 1,v_item_typ_id,'V','DROP-DOWN',actions);
    end if;

      --ihook.setColumnValue(rowform, 'GEN_STR',v_dec_nm ) ;
       ihook.setColumnValue(rowcncpt, 'GEN_STR',ihook.getColumnValue(rowcncpt,'ITEM_1_NM')  ) ;
       ihook.setColumnValue(rowcncpt, 'CTL_VAL_MSG', 'VALIDATED');


        if (   ihook.getColumnValue(rowcncpt, 'CNCPT_1_ITEM_ID_1') is null ) then
                  ihook.setColumnValue(rowcncpt, 'CTL_VAL_MSG', 'At least one concept has to be specified.');
                  is_valid := false;
        end if;

   if (   ihook.getColumnValue(rowcncpt, 'ITEM_1_ID') is  not null ) then
                  ihook.setColumnValue(rowcncpt, 'CTL_VAL_MSG', 'Duplicate found based on concepts: ' || ihook.getColumnValue(rowcncpt, 'ITEM_1_ID') );
                  is_valid := false;
        end if;

   v_err_str := '';
    nci_11179_2.stdAIValidation(rowai, v_item_typ_id,is_valid, v_err_str );
     --  nci_11179_2.stdCncptRowValidation(rowcncpt, 1,is_valid, v_err_str );

        if (v_err_str is not null) then
        ihook.setColumnValue(rowcncpt, 'CTL_VAL_MSG', v_err_Str);
        end if;
         rows := t_rows();
             if (ihook.getColumnValue(rowcncpt,'ITEM_1_NM') is not null) then
        ihook.setColumnValue(rowai,'ITEM_NM', ihook.getColumnValue(rowcncpt,'ITEM_1_NM'));
              ihook.setColumnValue(rowai,'ITEM_DESC', ihook.getColumnValue(rowcncpt,'ITEM_1_DEF'));
        end if;

             -- If any of the test fails or if the user has triggered validation, then go back to the screen.
        if is_valid=false or hookinput.answerid in (1, 2) then
                rows := t_rows();
                rows.extend;
        ihook.setColumnValue(rowai,'ADMIN_ITEM_TYP_ID', v_item_typ_id);
                rows(rows.last) := rowai;
                rowsetai := t_rowset(rows, 'Administered Item (Hook Creation)', 1, 'ADMIN_ITEM');
                rows := t_rows();
                rows.extend;
                rows(rows.last) := rowcncpt;
                rowset := t_rowset(rows, 'Rep Term (Hook Creation)', 1, 'NCI_STG_AI_CNCPT_CREAT');
                hookoutput.message := ihook.getColumnValue(rowcncpt, 'CTL_VAL_MSG');
                      hookOutput.forms := getSACreateForm(rowsetai,rowset,v_item_typ_id);
                HOOKOUTPUT.QUESTION    := getSACreateQuestion(false,v_item_typ_id);
        end if;


     -- If all the tests have passed and the user has asked for create, then create VD and Repp.
    -- raise_application_error(-20000, 'Here2');
    IF HOOKINPUT.ANSWERID in ( 3,4)  and is_valid = true THEN  -- Create

                createSA(rowai, rowcncpt, v_item_typ_id, actions, v_item_id);
                hookoutput.message := 'Rep Term Created Successfully with ID ' || v_item_id ;
         hookoutput.actions := actions;

    end if;

end if;

--V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);


END;


 procedure SACommonVM ( v_init_ai in t_rowset, v_item_typ_id in integer, hookInput in t_hookInput, hookOutput in out t_hookOutput)
 AS

    rowform t_row;
    rowai t_row;
    rowst t_row;
    rowcncpt t_row;
    forms t_forms;
    form1 t_form;
    row t_row;
    rows  t_rows;
    row_ori t_row;
    v_id number;
    v_ver_nr number(4,2);
    v_nm  varchar2(255);
    actions t_actions := t_actions();
    action t_actionRowset;
    v_msg varchar2(1000);
    i integer := 0;
    v_item_nm varchar2(255);
    v_item_id number;
    v_rep_id number;
    v_rep_ver number(4,2);
    v_item_desc varchar2(4000);
    v_count number;
    v_valid boolean;
    v_temp varchar2(100);
    v_substr  varchar2(100);
    v_temp_id number;
    v_temp_ver number(4,2);
     rowsetai t_rowset;
    rowsetcncpt t_rowset;
    rowset            t_rowset;
     v_rep_nm varchar2(255);
    v_cncpt_nm varchar2(255);
    v_long_nm varchar2(255);
    v_def varchar2(4000);
    is_valid boolean;
    v_err_str varchar2(4000);

 BEGIN

    if hookInput.invocationNumber = 0 then
        hookOutput.question    := getSACreateQuestion(true,v_item_typ_id);
        row := t_row();
        ihook.setColumnValue(row, 'STG_AI_ID', 1);
        rows := t_rows(); rows.extend;    rows(rows.last) := row;
        rowsetcncpt := t_rowset(rows, 'Rep Term (Stand Alone)', 1, 'NCI_STG_AI_CNCPT_CREAT'); -- Default values for cncpt form

        -- Send initial rowset to create the form.
        hookOutput.forms := getSACreateForm(v_init_ai, rowsetcncpt, v_item_typ_id);

    else
        forms              := hookInput.forms;
        form1              := forms(1);
        rowai := form1.rowset.rowset(1);

        form1              := forms(2);
        rowcncpt := form1.rowset.rowset(1);

        row := t_row();
        rows := t_rows();
        is_valid := true;

-- Context is always going to be NCIP for VM and RT
        ihook.setColumnValue(rowai,'CNTXT_ITEM_ID',20000000024); -- NCIP
        ihook.setColumnValue(rowai,'CNTXT_VER_NR', 1);
        if HOOKINPUT.ANSWERID = 1 or Hookinput.answerid = 3 THEN  -- Validate using string
                for i in 1..10 loop
                        ihook.setColumnValue(rowcncpt, 'CNCPT_1_ITEM_ID_' || i,'');
                        ihook.setColumnValue(rowcncpt, 'CNCPT_1_VER_NR_' || i, '');
                end loop;
               nci_dec_mgmt.createValAIWithConcept(rowcncpt ,  1,v_item_typ_id,'V','STRING',actions);
        end if;

      if HOOKINPUT.ANSWERID = 2 or Hookinput.answerid = 4 THEN  -- Validate using drop-down
               nci_dec_mgmt.createValAIWithConcept(rowcncpt , 1,v_item_typ_id,'V','DROP-DOWN',actions);
        end if;

       ihook.setColumnValue(rowcncpt, 'GEN_STR',replace(ihook.getColumnValue(rowcncpt,'ITEM_1_NM'),'Integer::','')  ) ;
       ihook.setColumnValue(rowcncpt, 'CTL_VAL_MSG', 'VALIDATED');

        if (   ihook.getColumnValue(rowcncpt, 'CNCPT_1_ITEM_ID_1') is null ) then
                  ihook.setColumnValue(rowcncpt, 'CTL_VAL_MSG', 'At least one concept has to be specified.');
                  is_valid := false;
        end if;

        if (   ihook.getColumnValue(rowcncpt, 'ITEM_1_ID') is  not null ) then
                  ihook.setColumnValue(rowcncpt, 'CTL_VAL_MSG', 'Duplicate found based on concepts: ' || ihook.getColumnValue(rowcncpt, 'ITEM_1_ID') );
                  is_valid := false;
        end if;

        v_err_str := '';
        nci_11179_2.stdAIValidation(rowai, v_item_typ_id,is_valid, v_err_str );
      --  nci_11179_2.stdCncptRowValidation(rowcncpt, 1,is_valid, v_err_str );

        if (v_err_str is not null) then
            ihook.setColumnValue(rowcncpt, 'CTL_VAL_MSG', v_err_Str);
        end if;

                   if (ihook.getColumnValue(rowcncpt,'ITEM_1_NM') is not null) then
                    ihook.setColumnValue(rowai,'ITEM_NM', ihook.getColumnValue(rowcncpt,'ITEM_1_NM'));
                    ihook.setColumnValue(rowai,'ITEM_DESC', ihook.getColumnValue(rowcncpt,'ITEM_1_DEF'));
                end if;

                    ihook.setColumnValue(rowai, 'ITEM_NM', replace(ihook.getColumnValue(rowai, 'ITEM_NM'), 'Integer::',''));

             -- If any of the test fails or if the user has triggered validation, then go back to the screen.
        if is_valid=false or hookinput.answerid in (1, 2) then
                rows := t_rows();
                rows.extend;
                ihook.setColumnValue(rowai,'ADMIN_ITEM_TYP_ID', v_item_typ_id);
                 rows(rows.last) := rowai;
                rowsetai := t_rowset(rows, 'Administered Item (Hook Creation)', 1, 'ADMIN_ITEM');
                rows := t_rows();
                rows.extend;
                rows(rows.last) := rowcncpt;
                rowset := t_rowset(rows, 'Rep Term (Hook Creation)', 1, 'NCI_STG_AI_CNCPT_CREAT');
                hookoutput.message := ihook.getColumnValue(rowcncpt, 'CTL_VAL_MSG');

                hookOutput.forms := getSACreateForm(rowsetai,rowset,v_item_typ_id);
                HOOKOUTPUT.QUESTION    := getSACreateQuestion(false,v_item_typ_id);
        end if;


     -- If all the tests have passed and the user has asked for create, then create VD and Repp.
    -- raise_application_error(-20000, 'Here2');
        if HOOKINPUT.ANSWERID in ( 3,4)  and is_valid = true THEN  -- Create
                createSA(rowai, rowcncpt, v_item_typ_id, actions, v_item_id);
                hookoutput.message := 'Value Meaning Created Successfully with ID ' || v_item_id ;
            hookoutput.actions := actions;
        end if;

    end if;

--V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);


END;

function getSACreateQuestion(v_first in Boolean,v_item_typ_id in integer) return t_question
  is
  question t_question;
  answer t_answer;
  answers t_answers;
begin

 ANSWERS                    := T_ANSWERS();
    ANSWER                     := T_ANSWER(1, 1, 'Validate Using String');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
  --  ANSWERS                    := T_ANSWERS();
    ANSWER                     := T_ANSWER(2, 2, 'Validate Using Drop-Down');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
    IF v_first=false then
    ANSWER                     := T_ANSWER(3, 3, 'Create/Edit Using String');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
    ANSWER                     := T_ANSWER(4, 4, 'Create/Edit Using Drop-Down');
    ANSWERS.EXTEND;
    ANSWERS(ANSWERS.LAST) := ANSWER;
    end IF;
   if (v_item_typ_id =7) then
    QUESTION               := T_QUESTION('Create New Rep Term', ANSWERS);
    else
       QUESTION               := T_QUESTION('Create New Value Meaning', ANSWERS);
end if;
return question;
end;

  function getSACreateForm (v_rowset1 in t_rowset,v_rowset2 in t_rowset,v_item_typ_id in integer) return t_forms is
   forms t_forms;
  form1 t_form;
begin
    forms                  := t_forms();

  form1                  := t_form('Administered Item (No Short Name)', 2,1);
    form1.rowset :=v_rowset1;
    forms.extend;    forms(forms.last) := form1;
if (v_item_typ_id = 7) then -- Rep term

    form1                  := t_form('Rep Term (Stand Alone)', 2,1);
else

   form1                  := t_form('VM (Stand Alone)', 2,1);
end if;
    form1.rowset :=v_rowset2;
    forms.extend;    forms(forms.last) := form1;

  return forms;

end;


PROCEDURE spVDCreateFrom ( v_data_in IN CLOB, v_data_out OUT CLOB) as
    hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();
    row_ori  t_row;
    row  t_row;
    rows t_rows;
    v_item_id  number;
    v_rc_item_id number;
    v_rc_ver_nr number(4,2);
    v_ver_nr  number(4,2);
    v_ori_rep_cls number;
    v_item_type_id number;
    rowai t_row;
    rowvd t_row;
    rowset  t_rowset;
    rowsetst  t_rowset;
    rowsetai  t_rowset;
    rowsetrp  t_rowset;
begin
--    -- Standard header
    hookinput                    := Ihook.gethookinput (v_data_in);
    hookoutput.invocationnumber  := hookinput.invocationnumber;
    hookoutput.originalrowset    := hookinput.originalrowset;

    -- Get the selected row
    row_ori :=  hookInput.originalRowset.rowset(1);
    v_item_id := ihook.getColumnValue(row_ori, 'ITEM_ID');
    v_ver_nr := ihook.getColumnValue(row_ori, 'VER_NR');
    v_item_type_id := ihook.getColumnValue(row_ori, 'ADMIN_ITEM_TYP_ID');
--

    if (hookinput.invocationnumber = 0) then
--    -- check that a selected AI is VD type
    if (v_item_type_id <> 3) then -- 3 - VALUE DOMAIN in table OBJ_KEY
        raise_application_error(-20000,'!!! This functionality is only applicable for VD !!!');
    end if;
--
--
    rowai := row_ori;
    rowvd := t_row();

select rep_cls_item_id, rep_cls_ver_nr into v_rc_item_id, v_rc_ver_nr
from value_dom where item_id = v_item_id and ver_nr = v_ver_nr;
--
    nci_11179.spReturnSubtypeRow (v_item_id, v_ver_nr, 3,  rowvd );

--     -- Copy subtype specific attributes
    nci_11179.spReturnRTConceptRow (v_rc_item_id, v_rc_ver_nr, 7, 1, rowvd );
--
--
     ihook.setColumnValue(rowai, 'ITEM_ID', -1);
    ihook.setColumnValue(rowvd, 'STG_AI_ID', 1);
    nci_11179_2.setStdAttr(rowai);
           ihook.setColumnValue(rowai, 'ITEM_LONG_NM', v_dflt_txt);

     rows := t_rows();    rows.extend;    rows(rows.last) := rowai;
     rowsetai := t_rowset(rows, 'Administered Item', 1, 'ADMIN_ITEM');
--
     rows := t_rows();    rows.extend;    rows(rows.last) := rowvd;

    rowsetst := t_rowset(rows, 'Rep Term (Hook Creation)', 1, 'NCI_STG_AI_CNCPT_CREAT');
--
    end if;

   spVDCommon(rowsetai, rowsetst, 2, 'insert', hookinput, hookoutput);

--
    V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
     nci_util.debugHook('GENERAL',v_data_out);
end;
--

PROCEDURE spVDEdit ( v_data_in IN CLOB, v_data_out OUT CLOB, v_usr_id in varchar2) as
    hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();
    row_ori  t_row;
    row  t_row;
    rows t_rows;
    v_item_id  number;
    v_rc_item_id number;
    v_rc_ver_nr number(4,2);
    v_ver_nr  number(4,2);
    v_ori_rep_cls number;
    v_item_type_id number;
    rowai t_row;
    rowvd t_row;
    rowset  t_rowset;
    rowsetst  t_rowset;
    rowsetai  t_rowset;
    rowsetrp  t_rowset;
begin
--    -- Standard header
    hookinput                    := Ihook.gethookinput (v_data_in);
    hookoutput.invocationnumber  := hookinput.invocationnumber;
    hookoutput.originalrowset    := hookinput.originalrowset;

    -- Get the selected row
    row_ori :=  hookInput.originalRowset.rowset(1);
    v_item_id := ihook.getColumnValue(row_ori, 'ITEM_ID');
    v_ver_nr := ihook.getColumnValue(row_ori, 'VER_NR');
    v_item_type_id := ihook.getColumnValue(row_ori, 'ADMIN_ITEM_TYP_ID');
--

 --   if (hookinput.invocationnumber = 0) then
--    -- check that a selected AI is VD type
    if (v_item_type_id <> 3) then -- 3 - VALUE DOMAIN in table OBJ_KEY
        raise_application_error(-20000,'!!! This functionality is only applicable for VD !!!');
    end if;
--
--  user authorization
   if (nci_11179_2.isUserAuth(v_item_id, v_ver_nr, v_usr_id) = false) then
        raise_application_error(-20000, 'You are not authorized to insert/update or delete in this context. ');
        return;
    end if;

    rowai := row_ori;
    rowvd := t_row();

select rep_cls_item_id, rep_cls_ver_nr into v_rc_item_id, v_rc_ver_nr
from value_dom where item_id = v_item_id and ver_nr = v_ver_nr;
--
    nci_11179.spReturnSubtypeRow (v_item_id, v_ver_nr, 3,  rowvd );

--     -- Copy subtype specific attributes
    nci_11179.spReturnRTConceptRow (v_rc_item_id, v_rc_ver_nr, 7, 1, rowvd );
--
--


    ihook.setColumnValue(rowvd, 'STG_AI_ID', 1);

     rows := t_rows();    rows.extend;    rows(rows.last) := rowai;
     rowsetai := t_rowset(rows, 'Administered Item', 1, 'ADMIN_ITEM');
--
     rows := t_rows();    rows.extend;    rows(rows.last) := rowvd;

    rowsetst := t_rowset(rows, 'Rep Term (Hook Creation)', 1, 'NCI_STG_AI_CNCPT_CREAT');
--
 --   end if;

   spVDCommon(rowsetai, rowsetst, 3, 'update', hookinput, hookoutput);

--
    V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
 --nci_util.debugHook('GENERAL',v_data_out);

end;

--
PROCEDURE spVDCreateNew ( v_data_in IN CLOB, v_data_out OUT CLOB)
as
  hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();
    row_ori  t_row;
    row  t_row;
    rows t_rows;
    rowsetai  t_rowset;
    rowsetst  t_rowset;
begin
    -- Standard header
    hookinput                    := Ihook.gethookinput (v_data_in);
    hookoutput.invocationnumber  := hookinput.invocationnumber;
    hookoutput.originalrowset    := hookinput.originalrowset;


    -- Default for new row. Dummy Identifier has to be set else error.
    row := t_row();
    ihook.setColumnValue(row, 'STG_AI_ID', 1);
       nci_11179_2.setStdAttr(row);
          ihook.setColumnValue(row, 'ADMIN_ITEM_TYP_ID', 3);
          ihook.setColumnValue(row, 'ITEM_NM', v_dflt_txt);
          ihook.setColumnValue(row, 'ITEM_DESC', v_dflt_txt);
          ihook.setColumnValue(row, 'ITEM_LONG_NM', v_dflt_txt);

    rows := t_rows(); rows.extend;    rows(rows.last) := row;
    rowsetai := t_rowset(rows, 'Administered Item', 1, 'ADMIN_ITEM'); -- Default values for AI form
    rowsetst := t_rowset(rows, 'Value Domain', 1, 'VALUE_DOM'); -- Default values for VD form

    spVDCommon(rowsetai,rowsetst,1, 'insert', hookinput, hookoutput);

    V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
   --  nci_util.debugHook('GENERAL',v_data_out);
end;



PROCEDURE spCreateVMSA ( v_data_in IN CLOB, v_data_out OUT CLOB, v_usr_id in varchar2)
as
  hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();
    row_ori  t_row;
    row  t_row;
    rows t_rows;
    rowsetai  t_rowset;
    rowsetst  t_rowset;
    v_item_typ_id integer;
begin
    -- Standard header
    hookinput                    := Ihook.gethookinput (v_data_in);
    hookoutput.invocationnumber  := hookinput.invocationnumber;
    hookoutput.originalrowset    := hookinput.originalrowset;

      v_item_typ_id := 53;
      row := t_row();
    -- Default for new row. Dummy Identifier has to be set else error.
      nci_11179_2.setStdAttr(row);
              ihook.setColumnValue(row, 'ADMIN_ITEM_TYP_ID', v_item_typ_id);
          ihook.setColumnValue(row, 'ITEM_NM', v_dflt_txt);
          ihook.setColumnValue(row, 'ITEM_DESC', v_dflt_txt);
          ihook.setColumnValue(row, 'ITEM_LONG_NM', v_dflt_txt);

    rows := t_rows(); rows.extend;    rows(rows.last) := row;


    rowsetai := t_rowset(rows, 'Administered Item', 1, 'ADMIN_ITEM'); -- Default values for AI form

    SACommonVM(rowsetai,v_item_typ_id, hookinput, hookoutput);

    V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);

  --  nci_util.debugHook('GENERAL',v_data_out);
end;


PROCEDURE spCreateRTSA ( v_data_in IN CLOB, v_data_out OUT CLOB,  v_usr_id in varchar2)
as
  hookInput t_hookInput;
    hookOutput t_hookOutput := t_hookOutput();
    row_ori  t_row;
    row  t_row;
    rows t_rows;
    rowsetai  t_rowset;
    rowsetst  t_rowset;
    v_item_typ_id integer;
begin
    -- Standard header
    hookinput                    := Ihook.gethookinput (v_data_in);
    hookoutput.invocationnumber  := hookinput.invocationnumber;
    hookoutput.originalrowset    := hookinput.originalrowset;

    row := t_row();
    v_item_typ_id := 7;
    -- Default for new row. Dummy Identifier has to be set else error.
       nci_11179_2.setStdAttr(row);
             ihook.setColumnValue(row, 'ADMIN_ITEM_TYP_ID', v_item_typ_id);
          ihook.setColumnValue(row, 'ITEM_NM', v_dflt_txt);
          ihook.setColumnValue(row, 'ITEM_DESC', v_dflt_txt);
          ihook.setColumnValue(row, 'ITEM_LONG_NM', v_dflt_txt);

    rows := t_rows(); rows.extend;    rows(rows.last) := row;


    rowsetai := t_rowset(rows, 'Administered Item', 1, 'ADMIN_ITEM'); -- Default values for AI form

    SACommonRT(rowsetai,v_item_typ_id, hookinput, hookoutput);

    V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
   --  nci_util.debugHook('GENERAL',v_data_out);
end;
--
--PROCEDURE spVDEdit ( v_data_in IN CLOB, v_data_out OUT CLOB, v_usr_id  IN varchar2)
--as
--    hookInput t_hookInput;
--    hookOutput t_hookOutput := t_hookOutput();
--    row_ori  t_row;
--    row  t_row;
--    rows t_rows;
--    v_item_id  number;
--    v_ver_nr  number(4,2);
--    v_ori_rep_cls number;
--    v_item_type_id number;
--    v_oc_item_id number;
--    v_prop_item_id number;
--    v_oc_ver_nr number(4,2);
--    v_prop_ver_nr number(4,2);
--      v_conc_dom_item_id number;
--    v_conc_dom_ver_nr number(4,2);
--    rowsetrp  t_rowset;
--    rowsetai  t_rowset;
--    rowsetst  t_rowset;
--    rowset  t_rowset;
--
--begin
--    -- Standard header
--    hookInput                    := Ihook.gethookinput (v_data_in);
--    hookOutput.invocationnumber  := hookInput.invocationnumber;
--    hookOutput.originalrowset    := hookInput.originalrowset;
--
--    -- Get the selected row
--    row_ori :=  hookInput.originalRowset.rowset(1);
--    v_item_id := ihook.getColumnValue(row_ori, 'ITEM_ID');
--    v_ver_nr := ihook.getColumnValue(row_ori, 'VER_NR');
--    v_item_type_id := ihook.getColumnValue(row_ori, 'ADMIN_ITEM_TYP_ID');
--
--
--    -- Check if user is authorized to edit
--    if (nci_11179_2.isUserAuth(v_item_id, v_ver_nr, v_usr_id) = false) then
--        raise_application_error(-20000, 'You are not authorized to insert/update or delete in this context. ');
--        return;
--    end if;
--
--    -- check that a selected AI is VD type
--    if (v_item_type_id <> 3) then -- 3 - VALUE DOMAIN in table OBJ_KEY
--        raise_application_error(-20000,'!!! This functionality is only applicable for VD !!!');
--    end if;
--
--
--    row := row_ori;
--
--select obj_cls_item_id, obj_cls_ver_nr, prop_item_id, prop_ver_nr, conc_dom_item_id, conc_dom_ver_nr into v_oc_item_id, v_oc_ver_nr, v_prop_item_id, v_prop_ver_nr ,
--v_conc_dom_item_id, v_conc_dom_ver_nr
--from de_conc where item_id = v_item_id and ver_nr = v_ver_nr;
--
--     -- Copy subtype specific attributes
--    nci_11179.spReturnConceptRow (v_oc_item_id, v_oc_ver_nr, 7, 1, row );
--
--    ihook.setColumnValue(row, 'STG_AI_ID', 1);
--     ihook.setColumnValue(row, 'CONC_DOM_ITEM_ID', v_conc_dom_item_id);
--    ihook.setColumnValue(row, 'CONC_DOM_VER_NR', v_conc_dom_ver_nr);
--
--
--rows := t_rows();    rows.extend;    rows(rows.last) := row;
--     rowset := t_rowset(rows, 'AI Creation With Concepts', 1, 'NCI_STG_AI_CNCPT_CREAT');
--
--    --spVDCommon(rowset, 'update', hookinput, hookoutput);
--spVDCommon(rowsetai, rowsetst, rowsetrp, 2, 'update', hookinput, hookoutput);
--
--    V_DATA_OUT := IHOOK.GETHOOKOUTPUT (HOOKOUTPUT);
--
--end;
--
--
--
-- v_mode : V - Validate, C - Validation and Create;  v_cncpt_src:  STRING: String; DROP-DOWN: Drop-downs
procedure createValAIWithConcept(rowform in out t_row,  idx in integer,v_item_typ_id in integer,v_mode in varchar2, v_cncpt_src in varchar2, actions in out t_actions) as
v_nm  varchar2(255);
v_long_nm varchar2(255);
v_def  varchar2(4000);
row t_row;
rows t_rows;
 action t_actionRowset;
 v_cncpt_id  number;
 v_cncpt_ver_nr number(4,2);
 v_temp_id  number;
 v_temp_ver number(4,2);
 v_item_id  number;
 v_ver_nr number(4,2);
 v_id integer;
 v_long_nm_suf  varchar2(255);
 v_long_nm_suf_int varchar2(255);
 j integer;
i integer;
cnt integer;
v_str varchar2(255);
v_obj_nm  varchar2(100);
v_temp varchar2(4000);
v_cncpt_nm varchar2(255);
begin

if (v_cncpt_src ='STRING') then
      if (ihook.getColumnValue(rowform, 'CNCPT_CONCAT_STR_' || idx) is not null) then
                v_str := trim(ihook.getColumnValue(rowform, 'CNCPT_CONCAT_STR_'|| idx));
                cnt := nci_11179.getwordcount(v_str);
                v_nm := '';
                v_long_nm := '';
                v_long_nm_suf := '';
                v_long_nm_suf_int := '';
                v_def := '';
                for i in  1..cnt loop
                if (v_item_typ_id = 7) then
                        j := i+1;
                else
                        j :=i;
                end if;
                        v_cncpt_nm := nci_11179.getWord(v_str, i, cnt);
                        ihook.setColumnValue(rowform, 'CNCPT_' || idx  ||'_ITEM_ID_' || j,'');
                        ihook.setColumnValue(rowform, 'CNCPT_' || idx || '_VER_NR_' || j, '');
                        for cur in(select item_id, item_nm , item_long_nm, item_desc from admin_item where admin_item_typ_id = 49 and upper(item_long_nm) = upper(trim(v_cncpt_nm))) loop
                                ihook.setColumnValue(rowform, 'CNCPT_' || idx  ||'_ITEM_ID_' || j,cur.item_id);
                                ihook.setColumnValue(rowform, 'CNCPT_' || idx || '_VER_NR_' || j, 1);
                               -- v_dec_nm := trim(v_dec_nm || ' ' || cur.item_nm) ;
                                v_long_nm_suf := trim(v_long_nm_suf || ':' || cur.item_long_nm);
                                v_long_nm_suf_int := trim(v_long_nm_suf_int || ':' || cur.item_long_nm);
                                v_nm := trim(v_nm || ' ' || cur.item_nm);
                              v_def := substr( v_def || '_' ||cur.item_desc  ,1,4000);

                        end loop;
                end loop;
                   if (v_item_typ_id = 7) then
                for i in  cnt+2..10 loop
                        ihook.setColumnValue(rowform, 'CNCPT_' || idx  ||'_ITEM_ID_' || i,'');
                        ihook.setColumnValue(rowform, 'CNCPT_' || idx || '_VER_NR_' || i, '');
                end loop;
                end if;
                   if (v_item_typ_id = 53) then
                for i in  cnt+1..10 loop
                        ihook.setColumnValue(rowform, 'CNCPT_' || idx  ||'_ITEM_ID_' || i,'');
                        ihook.setColumnValue(rowform, 'CNCPT_' || idx || '_VER_NR_' || i, '');
                end loop;
                end if;

    --            ihook.setColumnValue(rowform, 'ITEM_' || idx || '_NM', v_nm);
  --
            end if;

end if;

if (v_cncpt_src ='DROP-DOWN') then
        v_nm := '';
        v_long_nm_suf :='';
        v_def := '';
        v_long_nm_suf_int:= '';
                for i in 2..10 loop
                        v_temp_id := ihook.getColumnValue(rowform, 'CNCPT_' || idx  ||'_ITEM_ID_' || i);
                        v_temp_ver := ihook.getColumnValue(rowform, 'CNCPT_' || idx || '_VER_NR_' || i);
                        if (v_temp_id is not null) then
                        for cur in(select item_id, item_nm , item_long_nm, item_desc from admin_item where admin_item_typ_id = 49 and item_id = v_temp_id and ver_nr = v_temp_ver) loop
                     --            v_def := substr( v_def || '_' ||cur.item_desc  ,1,4000);
                         v_def := substr( v_def || '_' ||cur.item_desc  ,1,4000);

                                if (cur.item_id = v_int_cncpt_id and trim(ihook.getColumnValue(rowform,'CNCPT_INT_' || idx || '_' || i)) is not null) then --- integer concept

                                        v_long_nm_suf_int := trim(v_long_nm_suf_int || ':' || cur.item_long_nm) || '::' || trim(ihook.getColumnValue(rowform,'CNCPT_INT_' || idx || '_' || i));
                                        v_nm := trim(v_nm || ' ' || cur.item_nm) || '::' ||  trim(ihook.getColumnValue(rowform,'CNCPT_INT_' || idx || '_' || i)) ;
                                      v_def := v_def || '::' ||  trim(ihook.getColumnValue(rowform,'CNCPT_INT_' || idx || '_' || i));
                             else
                                    v_long_nm_suf_int := trim(v_long_nm_suf_int || ':' || cur.item_long_nm);
                                v_nm := trim(v_nm || ' ' || cur.item_nm);

                                end if;
                            v_long_nm_suf := trim(v_long_nm_suf || ':' || cur.item_long_nm);

                         end loop;
                        end if;
                end loop;

  end if;
        --- Primary Concept
             for cur in (select item_id, item_nm , item_long_nm, item_desc from admin_item where admin_item_typ_id = 49 and item_id = ihook.getColumnValue(rowform, 'CNCPT_' || idx || '_ITEM_ID_1')
             and ver_nr  = ihook.getColumnValue(rowform, 'CNCPT_' || idx || '_VER_NR_1')) loop
                          --       v_dec_nm := trim(v_dec_nm || ' ' || cur.item_nm) ;
                              v_long_nm_suf := trim(v_long_nm_suf || ':' || cur.item_long_nm);
                                                  v_def := substr( v_def || '_' ||cur.item_desc  ,1,4000);
                               if (cur.item_id = v_int_cncpt_id and trim(ihook.getColumnValue(rowform,'CNCPT_INT_' || idx || '_' || i)) is not null) then --- integer concept
                                        v_long_nm_suf_int := trim(v_long_nm_suf_int || ':' || cur.item_long_nm) || '::' || trim(ihook.getColumnValue(rowform,'CNCPT_INT_' || idx || '_1')) ;
                                        v_nm := trim(v_nm || ' ' || cur.item_nm) || '::' ||  trim(ihook.getColumnValue(rowform,'CNCPT_INT_' || idx || '_1' )) ;
                          --      v_def := substr(cur.item_desc || '::' || trim(ihook.getColumnValue(rowform,'CNCPT_INT_' || idx || '_' || i)) || '_' || v_def,1,4000);
                                                               v_def := v_def || '::' ||  trim(ihook.getColumnValue(rowform,'CNCPT_INT_' || idx || '_' || i));

                     else
                                    v_long_nm_suf_int := trim(v_long_nm_suf_int || ':' || cur.item_long_nm);
                                v_nm := trim(v_nm || ' ' || cur.item_nm);
                                --                  v_def := substr( cur.item_desc || '_' || v_def,1,4000);
          end if;

                                --raise_application_error(-20000, 'In HEre' || cur.item_long_nm);
             end loop;
            v_long_nm_suf := substr(v_long_nm_suf,2);

     --  raise_application_error(-20000, v_long_nm_suf || '  Long name: ' || v_nm);
                ihook.setColumnValue(rowform,'ITEM_' || idx || '_LONG_NM', v_long_nm_suf);
                ihook.setColumnValue(rowform,'ITEM_' || idx || '_NM', v_nm);
               ihook.setColumnValue(rowform,'ITEM_' || idx || '_DEF', substr(v_def,2));
        ihook.setColumnValue(rowform,'ITEM_' || idx || '_LONG_NM_INT', substr(v_long_nm_suf_int,2));

            nci_DEC_MGMT.CncptCombExistsNew (rowform , substr(v_long_nm_suf_int,2), v_item_typ_id, idx , v_item_id, v_ver_nr);
      --      raise_application_error(-20000, 'HErer ' || v_item_id);

if (v_mode = 'C') AND V_ITEM_ID  is null then --- Create


        v_id := nci_11179.getItemId;

       rows := t_rows();
   --     raise_application_error(-20000,'OC');
          j := 1;
 --     v_nm := '';
       v_long_nm := '';
  --     v_def := '';
          for i in reverse 2..10 loop

          v_cncpt_id := ihook.getColumnValue(rowform, 'CNCPT_' || idx  ||'_ITEM_ID_' || i);
             v_cncpt_ver_nr :=  ihook.getColumnValue(rowform, 'CNCPT_' || idx || '_VER_NR_' || i);
          if( v_cncpt_id is not null) then
    --   raise_application_error(-20000, 'Test'  || i || v_cncpt_id);
           for cur in (select item_nm, item_long_nm, item_desc from admin_item where item_id = v_cncpt_id and ver_nr = v_cncpt_ver_nr) loop
            row := t_row();
            ihook.setColumnValue(row,'ITEM_ID', v_id);
            ihook.setColumnValue(row,'VER_NR', 1);
            ihook.setColumnValue(row,'CNCPT_ITEM_ID',v_cncpt_id);
            ihook.setColumnValue(row,'CNCPT_VER_NR', v_cncpt_ver_nr);
            ihook.setColumnValue(row,'NCI_ORD', j);
            v_temp := v_temp || i || ':' ||  v_cncpt_id;
                --   v_def := substr( cur.item_desc || '_' || v_def,1,4000);

                  if (v_cncpt_id = v_int_cncpt_id and trim(ihook.getColumnValue(rowform,'CNCPT_INT_' || idx || '_' || i)) is not null) then
                        --    v_nm := trim(cur.item_nm) ||  '::' || trim(ihook.getColumnValue(rowform,'CNCPT_INT_' || idx || '_' || i)) || ' ' || v_nm ;
                            ihook.setColumnValue(row,'NCI_CNCPT_VAL',ihook.getColumnValue(rowform,'CNCPT_INT_' || idx || '_' || i));
            --                   v_def := substr(cur.item_desc || '::' || trim(ihook.getColumnValue(rowform,'CNCPT_INT_' || idx || '_' || i)) || '_' || v_def,1,4000);

                      --  else
             --                               v_def := substr( cur.item_desc || '_' || v_def,1,4000);
        --
                      --      v_nm := trim(cur.item_nm) || ' ' || v_nm ;
                        end if;
            rows.extend;
            rows(rows.last) := row;

            v_long_nm := cur.item_long_nm || ':' || v_long_nm   ;
            j := j+ 1;
        end loop;
        end if;
        end loop;


          v_cncpt_id := ihook.getColumnValue(rowform, 'CNCPT_' || idx  ||'_ITEM_ID_1' );
             v_cncpt_ver_nr :=  ihook.getColumnValue(rowform, 'CNCPT_' || idx || '_VER_NR_1' );
           for cur in (select item_nm, item_long_nm, item_desc from admin_item where item_id = v_cncpt_id and ver_nr = v_cncpt_ver_nr) loop
            row := t_row();
            ihook.setColumnValue(row,'ITEM_ID', v_id);
            ihook.setColumnValue(row,'VER_NR', 1);
            ihook.setColumnValue(row,'CNCPT_ITEM_ID',v_cncpt_id);
            ihook.setColumnValue(row,'CNCPT_VER_NR', v_cncpt_ver_nr);
            ihook.setColumnValue(row,'NCI_ORD', 0);
            ihook.setColumnValue(row,'NCI_PRMRY_IND', 1);
               --      v_def := substr( v_def  || cur.item_desc,1,4000 ) ;

            v_temp := v_temp || i || ':' ||  v_cncpt_id;
                 if (v_cncpt_id = v_int_cncpt_id and trim(ihook.getColumnValue(rowform,'CNCPT_INT_' || idx || '_' || i)) is not null) then
                    --        v_nm := trim(cur.item_nm) ||  '::' || trim(ihook.getColumnValue(rowform,'CNCPT_INT_' || idx || '_' || i)) || ' ' || v_nm ;
                            ihook.setColumnValue(row,'NCI_CNCPT_VAL',ihook.getColumnValue(rowform,'CNCPT_INT_' || idx || '_' || i));
                --                  v_def := substr(cur.item_desc || '::' || trim(ihook.getColumnValue(rowform,'CNCPT_INT_' || idx || '_' || i)) || '_' || v_def,1,4000);

                   --     else
                     --       v_nm := trim(cur.item_nm) || ' ' || v_nm ;
               --                     v_def := substr( cur.item_desc || '_' || v_def,1,4000);
                end if;

            rows.extend;
            rows(rows.last) := row;
            v_long_nm := v_long_nm  || cur.item_long_nm    ;
        end loop;


       action := t_actionrowset(rows, 'Items under Concept (Hook)', 2,6,'insert');
        actions.extend;
        actions(actions.last) := action;

        rows := t_rows();
        row := t_row();
        v_long_nm := substr(v_long_nm,1, length(v_long_nm)-1);
        v_nm := substr(trim(v_nm),1, c_nm_len);
        -- if lenght of short name is greater than 30, then use IDv1.00
        if (length(v_long_nm) > 30) then
            v_long_nm := v_id || c_ver_suffix;
        end if;

    -- raise_application_error (-20000, v_nm || '$$$' || v_long_nm);
        ihook.setColumnValue(row,'ITEM_ID', v_id);
        ihook.setColumnValue(row,'VER_NR', 1);
        ihook.setColumnValue(row,'CURRNT_VER_IND', 1);
        ihook.setColumnValue(row,'ADMIN_ITEM_TYP_ID', v_item_typ_id);
        ihook.setColumnValue(row,'ADMIN_STUS_ID',66 );
               ihook.setColumnValue(row,'REGSTR_STUS_ID',9 );
               -- Context is NCIP for RT
                  ihook.setColumnValue(row,'CNTXT_ITEM_ID',20000000024); -- NCIP
        ihook.setColumnValue(row,'CNTXT_VER_NR', 1);

   --     ihook.setColumnValue(row,'ITEM_LONG_NM', v_long_nm);
   -- REp Term short name change to IDvVersion
    ihook.setColumnValue(row,'ITEM_LONG_NM', nci_11179_2.getStdShortName(v_id, 1));
        ihook.setColumnValue(row,'ITEM_DESC', substr(v_def, 2));
        ihook.setColumnValue(row,'ITEM_NM', v_nm);
        ihook.setColumnValue(row,'CNTXT_ITEM_ID', 20000000024);
        ihook.setColumnValue(row,'CNTXT_VER_NR', 1);
        ihook.setColumnValue(row,'CNCPT_CONCAT', v_long_nm_suf);
        ihook.setColumnValue(row,'CNCPT_CONCAT_DEF', substr(v_def,2));
        ihook.setColumnValue(row,'CNCPT_CONCAT_NM', v_nm);
        ihook.setColumnValue(row,'CNCPT_CONCAT_WITH_INT', substr(v_long_nm_suf_int,2));

        rows.extend;
        rows(rows.last) := row;
    -- raise_application_error(-20000, 'HEre ' || v_nm || v_long_nm || v_def);
        ihook.setColumnValue(rowform,'ITEM_' || idx || '_LONG_NM', v_long_nm);
        ihook.setColumnValue(rowform,'ITEM_' || idx || '_DEF', substr(v_def, 1, length(v_def)-1));
        ihook.setColumnValue(rowform,'ITEM_' || idx || '_NM', v_nm);
        ihook.setColumnValue(rowform, 'ITEM_' || idx || '_ID', v_id);
         ihook.setColumnValue(rowform, 'ITEM_' || idx || '_VER_NR', 1);

        action := t_actionrowset(rows, 'Administered Item (No Sequence)', 2,1,'insert');
        actions.extend;
        actions(actions.last) := action;


        action := t_actionrowset(rows, 'NCI AI Extension (Hook)', 2,3,'insert');
        actions.extend;
        actions(actions.last) := action;

       case v_item_typ_id
       when 5 then v_obj_nm := 'Object Class';
       when 6 then v_obj_nm := 'Property';
	   when 7 then v_obj_nm := 'Representation Class';

        end case;
        action := t_actionrowset(rows, v_obj_nm, 2,2,'insert');
        actions.extend;
        actions(actions.last) := action;
end if;

end;
END;
/


DROP PACKAGE BODY ONEDATA_WA.RE;

CREATE OR REPLACE PACKAGE BODY ONEDATA_WA.re
AS
   TYPE t_rule_steps IS TABLE OF re_rule_steps%ROWTYPE
      INDEX BY PLS_INTEGER;
   TYPE t_join_metadata IS RECORD (
      maintablename        VARCHAR2 (30),
      reltablename         VARCHAR2 (30),
      joincolumnfrommain   VARCHAR2 (30),
      joincolumnfromrel    VARCHAR2 (30),
      evalcolumn           VARCHAR2 (30)
   );
   default_ts_format        VARCHAR2 (50)    := 'YYYY-MM-DD HH24:MI:SS';
   default_ts_full_format   VARCHAR2 (50)    := 'YYYY-MM-DD HH24:MI:SS.FF9';
   actions                  t_actions;
   tablename                VARCHAR2 (30);
   conceptualobjectname     VARCHAR2 (100);
   actiontype               VARCHAR2 (30);
   debugoutput              VARCHAR2 (32767);
   FUNCTION evalexpression (expression VARCHAR2)
      RETURN BOOLEAN
   AS
   BEGIN
      EXECUTE IMMEDIATE    'begin '
                        || 'if '
                        || expression
                        || ' then'
                        || '    re.eval := true;'
                        || 'else '
                        || '    re.eval := false;'
                        || 'end if;'
                        || 'end;';
      RETURN eval;
   EXCEPTION
      WHEN OTHERS
      THEN
         raise_application_error (-20000,
                                     'Error in rule evaluation ('
                                  || expression
                                  || ').'
                                 );
   END;
   FUNCTION extractcolumnname (fqcolumnname VARCHAR2)
      RETURN VARCHAR2
   AS
   BEGIN
      IF fqcolumnname IS NULL
      THEN
         RETURN NULL;
      END IF;
      RETURN SUBSTR (fqcolumnname, INSTR (fqcolumnname, '.') + 1);
   END;
   FUNCTION extracttablename (fqcolumnname VARCHAR2)
      RETURN VARCHAR2
   AS
   BEGIN
      IF fqcolumnname IS NULL
      THEN
         RETURN NULL;
      END IF;
      RETURN SUBSTR (fqcolumnname, 1, INSTR (fqcolumnname, '.') - 1);
   END;
   FUNCTION escapevalue (s VARCHAR2)
      RETURN VARCHAR2
   AS
      t   VARCHAR2 (32767);
   BEGIN
      IF s IS NULL
      THEN
         RETURN NULL;
      END IF;
      FOR i IN 1 .. LENGTH (s)
      LOOP
         t := t || SUBSTR (s, i, 1);
         IF SUBSTR (s, i, 1) = ''''
         THEN
            t := t || '''';
         END IF;
      END LOOP;
      RETURN t;
   END;
   FUNCTION unwrap (s VARCHAR2)
      RETURN VARCHAR2
   AS
   BEGIN
      IF s IS NULL
      THEN
         RETURN NULL;
      END IF;
      RETURN TRIM ('%' FROM s);
   END;
   FUNCTION getparameter (s VARCHAR2, n NUMBER)
      RETURN VARCHAR2
   AS
      frompos   NUMERIC;
      topos     NUMERIC;
   BEGIN
      frompos := INSTR (s, '%', 1, n * 2 - 1);
      topos := INSTR (s, '%', 1, n * 2);
      RETURN SUBSTR (s, frompos + 1, topos - frompos - 1);
   END;
   FUNCTION getjoinmetadata (s VARCHAR2)
      RETURN t_join_metadata
   AS
      joinmetadata   t_join_metadata;
   BEGIN
/*
 $JOIN
 (%MAIN_TABLE%,
 %REL_TABLE%,
 (%JOIN_CONDITION_COLUMNS_FROM_MAIN_TABLE^% comma separated), -- FIXME: just single column supported
 (%JOIN_CONDITION_COLUMNS_FROM_REL_TABLE^% comma separated),
 %EVAL_COLUMN_FROM_REL_TABLE%
 )
*/
      joinmetadata.maintablename := getparameter (s, 1);
      joinmetadata.reltablename := getparameter (s, 2);
      joinmetadata.joincolumnfrommain := getparameter (s, 3);
      joinmetadata.joincolumnfromrel := getparameter (s, 4);
      joinmetadata.evalcolumn := getparameter (s, 5);
      RETURN joinmetadata;
   END;
   FUNCTION resolvejoin (joinmetadata t_join_metadata, ROW t_row)
      RETURN VARCHAR2
   AS
      sqltext                   VARCHAR2 (32767);
      joincolumnfrommainvalue   VARCHAR2 (32767);
      COLUMN                    t_column;
      s                         VARCHAR2 (32767);
   BEGIN
      FOR i IN ROW.FIRST .. ROW.LAST
      LOOP
         COLUMN := ROW (i);
         IF COLUMN.NAME = joinmetadata.joincolumnfrommain
         THEN
            joincolumnfrommainvalue := COLUMN.VALUE;
         END IF;
      END LOOP;
      sqltext :=
            'select '
         || joinmetadata.evalcolumn
         || ' from '
         || joinmetadata.reltablename
         || ' where '
         || joinmetadata.joincolumnfromrel
         || '=:1';
      LOGGING.LOG (debugoutput, 'Resolving join (SQL: ' || sqltext || ').');
      BEGIN
         EXECUTE IMMEDIATE sqltext
                      INTO s
                     USING joincolumnfrommainvalue;
      EXCEPTION
         WHEN NO_DATA_FOUND
         THEN
            s := NULL;
      END;
      RETURN s;
   END;
   PROCEDURE parsefunctions (s IN OUT VARCHAR2, ROW t_row)
   AS
      joinmetadata   t_join_metadata;
   BEGIN
      IF s IS NULL OR UPPER (SUBSTR (TRIM (s), 1, 5)) != '$JOIN'
      THEN
         RETURN;
      END IF;
      joinmetadata := getjoinmetadata (s);
      s := resolvejoin (joinmetadata, ROW);
   END;
   FUNCTION parseexpression (s VARCHAR2, ROW t_row)
      RETURN VARCHAR2
   AS
      t        VARCHAR2 (32767) := s;
      temp     VARCHAR2 (32767);
      COLUMN   t_column;
   BEGIN
      IF s IS NULL
      THEN
         RETURN NULL;
      END IF;
      SELECT TO_CHAR (SYSDATE, default_ts_format)
        INTO temp
        FROM DUAL;
      t := REPLACE (t, '%SYSDATE%', temp);
      SELECT TO_CHAR (SYSTIMESTAMP, default_ts_full_format)
        INTO temp
        FROM DUAL;
      t := REPLACE (t, '%SYSTIMESTAMP%', temp);
      FOR i IN ROW.FIRST .. ROW.LAST
      LOOP
         COLUMN := ROW (i);
         t :=
            REPLACE (t,
                     '%' || tablename || '.' || COLUMN.NAME || '%',
                     COLUMN.VALUE
                    );
      END LOOP;
      parsefunctions (t, ROW);
      RETURN t;
   END;
   FUNCTION quotevalue (s VARCHAR2)
      RETURN VARCHAR2
   AS
   BEGIN
      RETURN '''' || s || '''';
   END;
   FUNCTION buildexpressionstep (v_rule_step re_rule_steps%ROWTYPE, ROW t_row)
      RETURN VARCHAR2
   AS
      expr    VARCHAR2 (32767);
      lexpr   VARCHAR2 (32767);
      rexpr   VARCHAR2 (32767);
      op      NUMBER;
   BEGIN
      lexpr :=
             escapevalue (parseexpression (v_rule_step.left_expression, ROW));
      rexpr :=
            escapevalue (parseexpression (v_rule_step.right_expression, ROW));
      op := v_rule_step.OPERATOR;
      expr :=
            expr
         || ' '
         || v_rule_step.left_logical_operator
         || ' '
         || v_rule_step.left_parenthesis
         || quotevalue (lexpr)
         || ' ';
      IF op = 1
      THEN
         expr := expr || ' = ' || quotevalue (rexpr);
      ELSIF op = 2
      THEN
         expr := expr || ' is null';
      ELSIF op = 3
      THEN
         expr := expr || ' is not null';
      ELSIF op = 5
      THEN
         expr := expr || ' < ' || quotevalue (rexpr);
      ELSIF op = 6
      THEN
         expr := expr || ' <= ' || quotevalue (rexpr);
      ELSIF op = 7
      THEN
         expr := expr || ' > ' || quotevalue (rexpr);
      ELSIF op = 8
      THEN
         expr := expr || ' >= ' || quotevalue (rexpr);
      ELSIF op = 9
      THEN
         expr := expr || ' like ' || quotevalue (rexpr || '%');
      ELSIF op = 10
      THEN
         expr := expr || ' like ' || quotevalue ('%' || rexpr);
      ELSIF op = 13
      THEN
         expr := expr || ' like ' || quotevalue ('%' || rexpr || '%');
      END IF;
      expr :=
            expr
         || ' '
         || v_rule_step.right_parenthesis
         || ' '
         || v_rule_step.right_logical_operator;
      RETURN expr;
   END;
   FUNCTION isactionrule (v_rule IN re_rules%ROWTYPE)
      RETURN BOOLEAN
   AS
   BEGIN
      RETURN v_rule.rule_type = 'A';
   END;
   FUNCTION joinrulesteps (
      v_rule_steps_i   IN   t_rule_steps,
      v_rule_steps_t   IN   t_rule_steps
   )
      RETURN t_rule_steps
   AS
      v_rule_steps   t_rule_steps;
      counter        PLS_INTEGER  := 1;
   BEGIN
      FOR i IN v_rule_steps_i.FIRST .. v_rule_steps_i.LAST
      LOOP
         v_rule_steps (counter) := v_rule_steps_i (i);
         counter := counter + 1;
      END LOOP;
      FOR i IN v_rule_steps_t.FIRST .. v_rule_steps_t.LAST
      LOOP
         v_rule_steps (counter) := v_rule_steps_t (i);
         counter := counter + 1;
      END LOOP;
      RETURN v_rule_steps;
   END;
   FUNCTION ruleexpressioncolumnchanged (
      v_rule           IN   re_rules%ROWTYPE,
      v_rule_steps_i   IN   t_rule_steps,
      v_rule_steps_t   IN   t_rule_steps,
      ROW                   t_row
   )
      RETURN BOOLEAN
   AS
      v_rule_steps   t_rule_steps;
      v_rule_step    re_rule_steps%ROWTYPE;
      COLUMN         t_column;
   BEGIN
      IF actiontype = 'insert'
      THEN
         RETURN TRUE;
      END IF;
      IF isactionrule (v_rule)
      THEN
         v_rule_steps := v_rule_steps_i;
      ELSE
         v_rule_steps := joinrulesteps (v_rule_steps_i, v_rule_steps_t);
      END IF;
      FOR i IN v_rule_steps.FIRST .. v_rule_steps.LAST
      LOOP
         v_rule_step := v_rule_steps (i);
         FOR j IN ROW.FIRST .. ROW.LAST
         LOOP
            COLUMN := ROW (j);
            IF    (INSTR (v_rule_step.left_expression,
                          '%' || tablename || '.' || COLUMN.NAME || '%'
                         ) > 0
                  )                                          -- %TABLE.COLUMN%
               OR (INSTR (v_rule_step.right_expression,
                          '%' || tablename || '.' || COLUMN.NAME || '%'
                         ) > 0
                  )
               OR (INSTR (v_rule_step.left_expression,
                          '%' || COLUMN.NAME || '%'
                         ) > 0
                  )
               OR (INSTR (v_rule_step.right_expression,
                          '%' || COLUMN.NAME || '%'
                         ) > 0
                  )
            THEN
               IF    COLUMN.VALUE != COLUMN.oldvalue
                  OR COLUMN.VALUE IS NULL AND COLUMN.oldvalue IS NOT NULL
                  OR COLUMN.VALUE IS NOT NULL AND COLUMN.oldvalue IS NULL
               THEN
                  RETURN TRUE;
               END IF;
            END IF;
         END LOOP;
      END LOOP;
      RETURN FALSE;
   END;
   FUNCTION buildexpression (v_rule_steps IN t_rule_steps, ROW t_row)
      RETURN VARCHAR2
   AS
      expression    VARCHAR2 (32767)        := '';
      v_rule_step   re_rule_steps%ROWTYPE;
   BEGIN
      FOR i IN v_rule_steps.FIRST .. v_rule_steps.LAST
      LOOP
         v_rule_step := v_rule_steps (i);
         expression := expression || buildexpressionstep (v_rule_step, ROW);
      END LOOP;
      RETURN expression;
   END;
   PROCEDURE buildaction (v_rule_steps_t IN t_rule_steps, ROW t_row)
   AS
      action        t_actionrowset;
      action_row    t_row                   := t_row ();
      action_rows   t_rows                  := t_rows ();
      COLUMN        t_column;
      v_rule_step   re_rule_steps%ROWTYPE;
   BEGIN
      FOR i IN ROW.FIRST .. ROW.LAST
      LOOP
         COLUMN := ROW (i);
         IF COLUMN.primarykey = 1
         THEN
            ihook.setcolumnvalue (action_row, COLUMN.NAME, COLUMN.VALUE);
         END IF;
      END LOOP;
      FOR i IN v_rule_steps_t.FIRST .. v_rule_steps_t.LAST
      LOOP
         v_rule_step := v_rule_steps_t (i);
         ihook.setcolumnvalue
                     (action_row,
                      extractcolumnname (unwrap (v_rule_step.left_expression)),
                      parseexpression (v_rule_step.right_expression, ROW)
                     );
      END LOOP;
      action_rows.EXTEND;
      action_rows (action_rows.LAST) := action_row;
      action :=
         t_actionrowset (action_rows,
                         tablename,
                         0,
                         'update',
                         conceptualobjectname
                        );
      actions.EXTEND;
      actions (actions.LAST) := action;
      LOGGING.LOG (debugoutput, 'Built action.');
   END;
   PROCEDURE validaterule (v_rule re_rules%ROWTYPE, ROW t_row)
   AS
      expression            VARCHAR2 (32767);
      v_rule_steps_i        t_rule_steps;
      v_rule_steps_t        t_rule_steps;
      v_rule_step           re_rule_steps%ROWTYPE;
      v_violation_message   VARCHAR2 (32767);
   BEGIN
      SELECT   *
      BULK COLLECT INTO v_rule_steps_i
          FROM re_rule_steps
         WHERE rule_id = v_rule.rule_id AND condition_type = 'I'
      ORDER BY step_id;
      SELECT   *
      BULK COLLECT INTO v_rule_steps_t
          FROM re_rule_steps
         WHERE rule_id = v_rule.rule_id AND condition_type = 'T'
      ORDER BY step_id;
      IF NOT ruleexpressioncolumnchanged (v_rule,
                                          v_rule_steps_i,
                                          v_rule_steps_t,
                                          ROW
                                         )
      THEN
         LOGGING.LOG (debugoutput, '"I" column(s) didn''t change.');
         RETURN;
      END IF;
      expression := buildexpression (v_rule_steps_i, ROW);
      LOGGING.LOG (debugoutput, '"I" expression: ' || expression || '.');
      IF evalexpression (expression)
      THEN
         LOGGING.LOG (debugoutput, '"I" expression evaluated positively.');
         IF isactionrule (v_rule)
         THEN
            buildaction (v_rule_steps_t, ROW);
         ELSE
            expression := buildexpression (v_rule_steps_t, ROW);
            LOGGING.LOG (debugoutput, '"T" expression: ' || expression);
            IF NOT evalexpression (expression)
            THEN
               LOGGING.LOG (debugoutput,
                            '"T" expression evaluated negatively.'
                           );
               IF misc.debug_re
               THEN
                  raise_application_error (-20000, 'DEBUG: ' || debugoutput);
               ELSE
                  IF v_rule.rule_violation_message IS NULL
                  THEN
                     raise_application_error (-20000,
                                                 'Rule "'
                                              || v_rule.rule_name
                                              || '" violated.'
                                             );
                  ELSE
                     raise_application_error (-20000,
                                              v_rule.rule_violation_message
                                             );
                  END IF;
               END IF;
            ELSE
               LOGGING.LOG (debugoutput,
                            '"T" expression evaluated positively.'
                           );
            END IF;
         END IF;
      ELSE
         LOGGING.LOG (debugoutput, '"I" expression evaluated negatively.');
      END IF;
   END;
   PROCEDURE firerulesengine (in_xml IN CLOB, out_xml OUT CLOB)
   AS
      hookinput    t_hookinput;
      hookoutput   t_hookoutput := t_hookoutput ();
      ROW          t_row;
   BEGIN
      debugoutput := '';
      LOGGING.LOG (debugoutput, 're.fireRulesEngine started.');
      hookinput := ihook.gethookinput (in_xml);
      hookoutput.invocationnumber := hookinput.invocationnumber;
      hookoutput.originalrowset := hookinput.originalrowset;
      tablename := hookinput.originalrowset.tablename;
      conceptualobjectname := hookinput.originalrowset.conceptualobjectname;
      actiontype := hookinput.originalrowset.actiontype;
      actions := t_actions ();
      FOR rule IN
         (SELECT *
            FROM re_rules
           WHERE (rule_id) IN (
                    SELECT rule_id
                      FROM re_rule_steps
                     WHERE (   (left_expression LIKE
                                                    '%\%' || tablename || '.%' ESCAPE '\'
                               )                             -- %TABLE.COLUMN%
                            OR (right_expression LIKE
                                                    '%\%' || tablename || '.%' ESCAPE '\'
                               )
                            OR (left_expression LIKE
                                                    '%(\%' || tablename || '%' ESCAPE '\'
                               )                                  -- F(%TABLE%
                            OR (right_expression LIKE
                                                   '%(\%' || tablename || '.%' ESCAPE '\'
                               )
                           ))
             AND disabled = 0)
      LOOP
         FOR i IN 1 .. hookinput.originalrowset.rowset.COUNT
         LOOP
            ROW := hookinput.originalrowset.rowset (i);
            LOGGING.LOG (debugoutput,
                            'Executing rule '
                         || rule.rule_id
                         || ' for row# '
                         || i
                         || '.'
                        );
            validaterule (rule, ROW);
            LOGGING.LOG (debugoutput,
                            'Finished executing rule '
                         || rule.rule_id
                         || ' for row# '
                         || i
                         || '.'
                        );
         END LOOP;
      END LOOP;
      IF actions.COUNT > 0
      THEN
         hookoutput.actions := actions;
      END IF;
      out_xml := ihook.gethookoutput (hookoutput);
      LOGGING.LOG (debugoutput, 're.fireRulesEngine finished.');
      IF misc.debug_re
      THEN
         raise_application_error (-20000, 'DEBUG: ' || debugoutput);
      END IF;
      RETURN;
   END;
END;
/


DROP PACKAGE BODY ONEDATA_WA.TEMPLATE_11179;

CREATE OR REPLACE PACKAGE BODY ONEDATA_WA.template_11179 AS

v_err_str      varchar2(1000) := '';
DEFAULT_TS_FORMAT    varchar2(50) := 'YYYY-MM-DD HH24:MI:SS';
type       t_orgs is table of org_cntct.org_id%type;

/***********************************************/

function getColumnCount(v_table_name in varchar2) return number
as

v_meta_col_cnt      number;

begin

 select count(*) into v_meta_col_cnt
 from cols
 where table_name=v_table_name;

 return v_meta_col_cnt;

end;

/***********************************************/

function getSelectSql(v_table_name in varchar2) return varchar2
as

v_sql        varchar2(4000);

begin

    v_sql := 'select ';

 for rec in (select column_name, data_type
             from cols
                where table_name=v_table_name) loop
        if rec.data_type != 'DATE' then
      v_sql := v_sql || rec.column_name || ', ';
  else
      v_sql := v_sql || 'to_char(' || rec.column_name || ', ''' || DEFAULT_TS_FORMAT || ''') '
       || rec.column_name || ', ';
  end if;
 end loop;

 v_sql := substr (v_sql, 1, length(v_sql) - 2) || ' from ' || v_table_name;

 return v_sql;

end;

/***********************************************/

function getParsedAdminItemsData (originalRowset in t_actionRowset) return tab_admin_item_pk
as

v_admin_item    obj_admin_item_pk;
v_tab_admin_item   tab_admin_item_pk;

row       t_row;

begin

 v_tab_admin_item := tab_admin_item_pk();
 v_tab_admin_item.extend(originalRowset.rowset.count);

 for i in 1..originalRowset.rowset.count loop
        row := originalRowset.rowset(i);
  v_admin_item := obj_admin_item_pk(ihook.getColumnValue(row, 'ITEM_ID'), ihook.getColumnValue(row, 'VER_NR'));
  v_tab_admin_item(i) := v_admin_item;
 end loop;

 return v_tab_admin_item;

end;

/***********************************************/

function isStatusCertified
(v_to_stus_id number, v_admin_item admin_item%rowtype) return boolean as

v_no_of_columns_to_check  number := 0;
v_not_null_check_query    varchar2(32767) := 'select sum(a) from (select 0 a from dual';

type cv_type     is ref cursor;
cv           cv_type;
v_temp       number;

v_temp_str      varchar2(4000);
v_certified       boolean := true;

v_err_hdr       varchar2(100) := 'Certification conditions failed:';

/*

performs sequence of checks

*/

begin

    -- check #1
 -- some required columns are not filled in
    for rec in (
 select entty_nm, col_nm from regist_rul_req_colmns
 where to_stus_id=v_to_stus_id and nvl(admin_item_typ_id, 0) in (0, v_admin_item.admin_item_typ_id)
 and nvl(fld_delete, 0)=0)
 loop

        v_no_of_columns_to_check := v_no_of_columns_to_check + 1;
  v_not_null_check_query := v_not_null_check_query
      || ' union all select 1 a from ' || rec.entty_nm
   || ' where item_id=' || v_admin_item.item_id || ' and ver_nr=' || v_admin_item.ver_nr
   || ' and ' || rec.col_nm || ' is not null';

 end loop;
 v_not_null_check_query := v_not_null_check_query || ')';

 open cv for v_not_null_check_query;
    fetch cv into v_temp;
    v_certified := v_temp = v_no_of_columns_to_check;
    close cv;

 if not v_certified then
     v_err_str := v_err_str || '<br>Required columns not filled in.';
 end if;

    -- check #2
 -- if type is DE and row exists in DE_DERV(PRMRY_DE_...) and DE.DERV_DE_IND is not 1
    for x in (select count(*) cnt from dual
        where exists (
      select null from de_derv a, de b
   where v_admin_item.admin_item_typ_id=4 /* DE */
   and a.prmry_de_item_id=v_admin_item.item_id and a.prmry_de_ver_nr=v_admin_item.ver_nr
   and nvl(a.fld_delete, 0)=0
   and b.item_id=v_admin_item.item_id and b.ver_nr=v_admin_item.ver_nr
   and nvl(b.derv_de_ind, 0) != 1
  ))
    loop
        if (x.cnt = 1) then
         v_err_str := v_err_str || '<br>Derived indicator not set.';
   v_certified := false;
     end if;
    end loop;

    -- check #3
 -- if type is DE and row do not exist in DE_DERV(PRMRY_DE_...) and DE.DERV_DE_IND is 1
 if v_admin_item.admin_item_typ_id=4 then
     select nvl(derv_de_ind,0) into v_temp
  from de b
  where b.item_id=v_admin_item.item_id and b.ver_nr=v_admin_item.ver_nr;
  if v_temp = 1 then
      select count(*) into v_temp from de_derv a
      where a.prmry_de_item_id=v_admin_item.item_id and a.prmry_de_ver_nr=v_admin_item.ver_nr
      and nvl(a.fld_delete, 0)=0;
   if v_temp = 0 then
       v_err_str := v_err_str || '<br>Derived components are not defined.';
   end if;
   end if;
    end if;

    -- check #4
 -- if type is VALUE_DOM and VAL_DOM_TYP_ID is enumerated (17) and row do not exist in PERM_VAL(VAL_DOM_...)
 if v_admin_item.admin_item_typ_id=3 /* VALUE_DOM */ then
     select b.val_dom_typ_id, trim(b.NON_ENUM_VAL_DOM_DESC) into v_temp, v_temp_str
  from value_dom b
  where b.item_id=v_admin_item.item_id and b.ver_nr=v_admin_item.ver_nr;
     if v_temp = 17 then
         select count(*) into v_temp
   from perm_val a
      where a.val_dom_item_id=v_admin_item.item_id and a.val_dom_ver_nr=v_admin_item.ver_nr
   and nvl(fld_delete,0) = 0;
      if v_temp < 2 then
             v_err_str := v_err_str || '<br>At least 2 permissible values need to be defined for enumerated value domain.';
       v_certified := false;
         end if;
        elsif v_temp = 18 then
         select count(*) into v_temp
   from perm_val a
      where a.val_dom_item_id=v_admin_item.item_id and a.val_dom_ver_nr=v_admin_item.ver_nr
   and nvl(fld_delete,0) = 0;
      if v_temp > 0 then
             v_err_str := v_err_str || '<br>No permissible values can be defined for non-enumerated value domain.';
       v_certified := false;
         end if;

   if v_temp_str is null then
      v_err_str := v_err_str || '<br>Non-enumerated description needs to be filled in for non-enumerated value domains.';
       v_certified := false;
         end if;
  end if;
    end if;

    -- check #5
 -- if type is CONC_DOM and CONC_DOM_TYP_ID is enumerated (17) and row do not exist in VAL_MEAN(CONC_DOM_...)
 if v_admin_item.admin_item_typ_id=1 /* CONC_DOM */ then
     select b.conc_dom_typ_id into v_temp
  from conc_dom b
  where b.item_id=v_admin_item.item_id and b.ver_nr=v_admin_item.ver_nr;
     if v_temp = 17 then
         select count(*) into v_temp
   from conc_dom_val_mean a
      where a.conc_dom_item_id=v_admin_item.item_id and a.conc_dom_ver_nr=v_admin_item.ver_nr
   and nvl(fld_delete,0) = 0;
      if v_temp = 0 then
             v_err_str := v_err_str || '<br>No value meaning defined for enumerated conceptual domain.';
       v_certified := false;
         end if;
        end if;
    end if;

    -- check #6
 -- make sure all the parents are STANDARDIZED before the child is STANDARDIZED
 if v_to_stus_id = 4 then

    /* Value Domain */
     if v_admin_item.admin_item_typ_id=3 then

     for v_rec in (select conc_dom_item_id item_id, conc_dom_ver_nr ver_nr
      from value_dom
      where item_id=v_admin_item.item_id
      and ver_nr=v_admin_item.ver_nr and
   conc_dom_item_id is not null)
   loop
             select regstr_stus_id into v_temp from admin_item
       where item_id = v_rec.item_id and
       ver_nr = v_rec.ver_nr;


          if v_temp != 4 then
             v_err_str := v_err_str || '<br>Conceptual Domain is not in STANDARDIZED status.';
             v_certified := false;
          end if;
   end loop;
        end if;

    /* Data Element */
     if v_admin_item.admin_item_typ_id=4 then

     for v_rec in (select val_dom_item_id item_id, val_dom_ver_nr ver_nr
      from de
      where item_id=v_admin_item.item_id
      and ver_nr=v_admin_item.ver_nr and
   val_dom_item_id is not null)
   loop
             select regstr_stus_id into v_temp from admin_item
       where item_id = v_rec.item_id and
       ver_nr = v_rec.ver_nr;

          if v_temp != 4 or v_temp is not null then
             v_err_str := v_err_str || '<br>Value Domain is not in STANDARDIZED status.';
             v_certified := false;
          end if;
   end loop;

     for v_rec in (select de_conc_item_id item_id, de_conc_ver_nr ver_nr
      from de
      where item_id=v_admin_item.item_id
      and ver_nr=v_admin_item.ver_nr and
   de_conc_item_id is not null)
   loop
             select regstr_stus_id into v_temp from admin_item
       where item_id = v_rec.item_id and
       ver_nr = v_rec.ver_nr;

          if v_temp != 4 or v_temp is not null then
             v_err_str := v_err_str || '<br>Data Element Concept is not in STANDARDIZED status.';
             v_certified := false;
          end if;
   end loop;
     end if;

    /* Data Element Concept */
     if v_admin_item.admin_item_typ_id=2 then
     for v_rec in (select obj_cls_item_id item_id, obj_cls_ver_nr ver_nr
      from de_conc
      where item_id=v_admin_item.item_id
      and ver_nr=v_admin_item.ver_nr and
   obj_cls_item_id is not null)
   loop
             select regstr_stus_id into v_temp from admin_item
       where item_id = v_rec.item_id and
       ver_nr = v_rec.ver_nr;

          if v_temp != 4  then
             v_err_str := v_err_str || '<br>Object Class is not in STANDARDIZED status.';
             v_certified := false;
          end if;
   end loop;

     for v_rec in (select prop_item_id item_id, prop_ver_nr ver_nr
      from de_conc
      where item_id=v_admin_item.item_id
      and ver_nr=v_admin_item.ver_nr and
   prop_item_id is not null)
   loop
        select regstr_stus_id into v_temp from admin_item
       where item_id = v_rec.item_id and
       ver_nr = v_rec.ver_nr;


          if v_temp != 4 then
             v_err_str := v_err_str || '<br>Property is not in STANDARDIZED status.';
             v_certified := false;
          end if;
   end loop;
     end if;

 end if;

 if not v_certified then
     v_err_str := v_err_hdr || v_err_str;
 end if;

 return v_certified;

end;

/***********************************************/

function isPartOfOrgList
(v_member org_cntct.org_id%type, v_collection t_orgs) return boolean as

begin

    if v_collection.count = 0 then
     return false;
    end if;

    for i in v_collection.first..v_collection.last loop
     if (v_collection(i) = v_member) then
         return true;
  end if;
 end loop;

    return false;

end;

/***********************************************/

procedure spChangeStatus (v_stus_typ_id number, v_to_stus_id number, v_data_in in clob, v_data_out out clob, v_user_id varchar2)
as

/*

1. obtain user's org IDs
2. read the current admin item row
3. determine what are the registration authority/steward/submitter group IDs
4. confirm (using rules table) that the user has rights to update status
5. confirm that required columns condition is met
6. update admin item status
7. if current data_id_str is null and status being changed is 11 (recorded)
   or 14 (standard), then data_id_str column needs to
   be populated with concatenation of regstr_auth.org_prt_id + item_id + ver_nr
   exception for FAA: data_id_str is a sequential number

testing:

begin
spchangestatus(1,222,'<ITEM_ID><![CDATA[1]]></ITEM_ID><VER_NR><![CDATA[1]]></VER_NR>', 'SUBMIT1');
end;

*/

hookInput         t_hookInput;
hookOutput         t_hookOutput := t_hookOutput();
actions         t_actions := t_actions();
action         t_actionRowset;
ai_action_rows       t_rows := t_rows();
ai_audit_action_rows   t_rows := t_rows();
row        t_row;

v_admin_item      admin_item%rowtype;
v_data_id_str      admin_item.data_id_str%type;

v_tab_admin_item    tab_admin_item_pk;

v_orgs          t_orgs;

v_usr_grp_id1      number := 0;
v_usr_grp_id2      number := 0;
v_usr_grp_id3      number := 0;

v_temp         number;
v_found        boolean;

v_apply_cert     number;
v_creat_irdi     number;
v_to_stus_nm     varchar(100);

cursor c1
(v_from_stus_id regist_rul.from_stus_id%type,
v_to_stus_id regist_rul.to_stus_id%type,
v_stus_typ_id regist_rul.stus_typ_id%type)
is select 1 from regist_rul
where nvl(from_stus_id, 0)=nvl(v_from_stus_id, 0) and to_stus_id=v_to_stus_id
and stus_typ_id=v_stus_typ_id
and usr_grp_id in (v_usr_grp_id1, v_usr_grp_id2, v_usr_grp_id3)
and nvl(fld_delete, 0)=0;

begin

    hookInput := ihook.getHookInput(v_data_in);

 hookOutput.invocationNumber := hookInput.invocationNumber;
 hookOutput.originalRowset := hookInput.originalRowset;

 v_tab_admin_item := getParsedAdminItemsData(hookInput.originalRowset);

    select b.org_id bulk collect into v_orgs
 from cntct a, org_cntct b
    where a.cntct_secu_id=v_user_id and a.cntct_id=b.cntct_id;

 for i in 1..v_tab_admin_item.count loop

     select * into v_admin_item from admin_item
     where item_id=v_tab_admin_item(i).item_id and ver_nr=v_tab_admin_item(i).ver_nr
  for update nowait;

     if isPartOfOrgList(v_admin_item.regstr_auth_id, v_orgs) then
      v_usr_grp_id3 := 3;
  end if;

     if isPartOfOrgList(v_admin_item.stewrd_org_id, v_orgs) then
      v_usr_grp_id2 := 2;
  end if;

     if isPartOfOrgList(v_admin_item.submt_org_id, v_orgs) then
      v_usr_grp_id1 := 1;
  end if;

  if (v_stus_typ_id = 1) then  -- Change made for Administrative Status - Mar 3 2008
     open c1(v_admin_item.regstr_stus_id, v_to_stus_id, v_stus_typ_id);
        fetch c1 into v_temp;
        v_found := c1%FOUND;
        close c1;
  else
   open c1(v_admin_item.admin_stus_id, v_to_stus_id, v_stus_typ_id);
      fetch c1 into v_temp;
      v_found := c1%FOUND;
      close c1;
  end if;

     if not v_found then
            hookOutput.message := 'You are not authorized to change status or rule transition is not allowed.';
            v_data_out := ihook.getHookOutput(hookOutput);
   return;
  end if;

  select to_number(substr(stus_msk,4,1)), to_number(substr(stus_msk,5,1)), stus_nm
        into v_apply_cert, v_creat_irdi, v_to_stus_nm
  from stus_mstr
  where stus_id = v_to_stus_id;

  if (v_stus_typ_id = 2) then -- Administrative status - no certification rules apply.. Change made Mar 3 2008.
   v_apply_cert := 0;
   v_creat_irdi := 0;
  end if;

        if v_apply_cert = 1
  and not isStatusCertified(v_to_stus_id, v_admin_item) then
            hookOutput.message := v_err_str;
   v_data_out := ihook.getHookOutput(hookOutput);
   return;
  end if;

     row := t_row();
     ihook.setColumnValue(row, 'ITEM_ID', v_admin_item.item_id);
     ihook.setColumnValue(row, 'VER_NR', v_admin_item.ver_nr);

  if (v_stus_typ_id = 1) then -- Administrative status change - Change Mar 3, 2008
       ihook.setColumnValue(row, 'REGSTR_STUS_ID', v_to_stus_id);
  else
       ihook.setColumnValue(row, 'ADMIN_STUS_ID', v_to_stus_id);
  end if;

        ai_action_rows.extend; ai_action_rows(ai_action_rows.last) := row;

  if v_admin_item.data_id_str is null and v_creat_irdi = 1 and v_admin_item.regstr_auth_id is not null then
/*
            -- standrd logic of generation
      select org_prt_id || ' - ' || v_admin_item.item_id || ' - ' || v_admin_item.ver_nr
   into v_data_id_str
   from regstr_auth where regstr_auth_id=v_admin_item.regstr_auth_id;

      update admin_item
   set data_id_str=v_data_id_str
   where item_id=v_admin_item.item_id and ver_nr=v_admin_item.ver_nr;
      update p_admin_item
   set data_id_str=v_data_id_str
   where item_id=v_admin_item.item_id and ver_nr=v_admin_item.ver_nr;
*/

      -- custom logic for FAA
--            select max(to_number(nvl(data_id_str, 0))) + 1 into v_data_id_str
--   from admin_item;

            select od_seq_data_id_str.nextval into v_data_id_str from dual;

            ihook.setColumnValue(ai_action_rows(ai_action_rows.last), 'DATA_ID_STR', v_data_id_str);

  end if;

     row := t_row();
     ihook.setColumnValue(row, 'LOG_ID', -1); -- sequence column
     ihook.setColumnValue(row, 'ITEM_ID', v_admin_item.item_id);
     ihook.setColumnValue(row, 'VER_NR', v_admin_item.ver_nr);
     ihook.setColumnValue(row, 'CHNG_TYP_ID', case when v_stus_typ_id=1 then 46 when v_stus_typ_id=2 then 47 end);
     ihook.setColumnValue(row, 'CHNG_DESC', 'Status changed to ' || v_to_stus_nm || '.');
     ihook.setColumnValue(row, 'LST_UPD_USR_ID', v_user_id);
        ai_audit_action_rows.extend; ai_audit_action_rows(ai_audit_action_rows.last) := row;

 end loop;

    action := t_actionRowset(ai_action_rows, 'ADMIN_ITEM', 0, 'update');
    actions.extend; actions(actions.last) := action;

    action := t_actionRowset(ai_audit_action_rows, 'ADMIN_ITEM_AUDIT', 0, 'insert');
    actions.extend; actions(actions.last) := action;

 hookOutput.actions := actions;

    hookOutput.message := 'Status changed successfully.';

    v_data_out := ihook.getHookOutput(hookOutput);

end;

/***********************************************/

function spGetNextVer (v_current_ver admin_item.ver_nr%type, v_major_ver boolean) return admin_item.ver_nr%type as

begin
    if v_major_ver then
     return trunc (v_current_ver + 1);
 else
     return v_current_ver + 0.1;
 end if;
end;

/***********************************************/

procedure spCreateSubtypeVer (actions in out t_actions, v_admin_item admin_item%rowtype, v_major_ver boolean) as

/*

creates version for subtype - called from spCreateVer

*/

action           t_actionRowset;
action_rows              t_rows := t_rows();
row          t_row;

v_table_name      varchar2(30);
v_sql        varchar2(4000);

v_cur        number;
v_temp        number;

v_col_val       varchar2(4000);

v_meta_col_cnt      integer;
v_meta_desc_tab      dbms_sql.desc_tab;

begin

    if v_admin_item.admin_item_typ_id = 1 then
     v_table_name := 'CONC_DOM';
    elsif v_admin_item.admin_item_typ_id = 2 then
     v_table_name := 'DE_CONC';
    elsif v_admin_item.admin_item_typ_id = 3 then
     v_table_name := 'VALUE_DOM';
    elsif v_admin_item.admin_item_typ_id = 4 then
     v_table_name := 'DE';
    elsif v_admin_item.admin_item_typ_id = 5 then
     v_table_name := 'OBJ_CLS';
    elsif v_admin_item.admin_item_typ_id = 6 then
     v_table_name := 'PROP';
    elsif v_admin_item.admin_item_typ_id = 7 then
     v_table_name := 'REP_CLS';
    elsif v_admin_item.admin_item_typ_id = 8 then
     v_table_name := 'CNTXT';
    elsif v_admin_item.admin_item_typ_id = 9 then
     v_table_name := 'CLSFCTN_SCHM';
    elsif v_admin_item.admin_item_typ_id = 10 then
     v_table_name := 'DERV_RUL';
    elsif v_admin_item.admin_item_typ_id = 49 then
     v_table_name := 'CNCPT';
    end if;

 v_meta_col_cnt := getColumnCount(v_table_name);

    v_sql := getSelectSql(v_table_name) || ' where item_id=:item_id and ver_nr=:ver_nr';

 v_cur := dbms_sql.open_cursor;
 dbms_sql.parse(v_cur, v_sql, dbms_sql.native);
 dbms_sql.bind_variable(v_cur, ':item_id', v_admin_item.item_id);
 dbms_sql.bind_variable(v_cur, ':ver_nr', v_admin_item.ver_nr);

 for i in 1..v_meta_col_cnt loop
     dbms_sql.define_column(v_cur, i, '', 4000);
 end loop;

    v_temp := dbms_sql.execute_and_fetch(v_cur);
    dbms_sql.describe_columns(v_cur, v_meta_col_cnt, v_meta_desc_tab);

    row := t_row();

 for i in 1..v_meta_col_cnt loop
  dbms_sql.column_value(v_cur, i, v_col_val);
  ihook.setColumnValue(row, v_meta_desc_tab(i).col_name, v_col_val);
 end loop;

 dbms_sql.close_cursor(v_cur);

    ihook.setColumnValue(row, 'VER_NR', spGetNextVer (v_admin_item.ver_nr, v_major_ver));

    action_rows.extend; action_rows(action_rows.last) := row;
    action := t_actionRowset(action_rows, v_table_name, 10, 'insert');
    actions.extend; actions(actions.last) := action;



 if v_admin_item.admin_item_typ_id = 3 then -- Add Perm Val

  action_rows := t_rows();

  v_table_name := 'PERM_VAL';
  v_meta_col_cnt := getColumnCount(v_table_name);

   for pv_cur in
  (select val_id from perm_val where 
  val_dom_item_id = v_admin_item.item_id and val_dom_ver_nr = v_admin_item.ver_nr) loop

      v_sql := getSelectSql(v_table_name) || ' where val_id = :val_id';

      v_cur := dbms_sql.open_cursor;
   dbms_sql.parse(v_cur, v_sql, dbms_sql.native);
   dbms_sql.bind_variable(v_cur, ':val_id', pv_cur.val_id);

   for i in 1..v_meta_col_cnt loop
       dbms_sql.define_column(v_cur, i, '', 4000);
   end loop;

      v_temp := dbms_sql.execute_and_fetch(v_cur);
      dbms_sql.describe_columns(v_cur, v_meta_col_cnt, v_meta_desc_tab);

      row := t_row();

   for i in 1..v_meta_col_cnt loop
    dbms_sql.column_value(v_cur, i, v_col_val);
    ihook.setColumnValue(row, v_meta_desc_tab(i).col_name, v_col_val);
   end loop;

   dbms_sql.close_cursor(v_cur);

      ihook.setColumnValue(row, 'VAL_ID', -1);
      ihook.setColumnValue(row, 'VAL_DOM_VER_NR', spGetNextVer (v_admin_item.ver_nr, v_major_ver));
      action_rows.extend; action_rows(action_rows.last) := row;

  end loop;

  action := t_actionRowset(action_rows, v_table_name, 11, 'insert');
     actions.extend; actions(actions.last) := action;

 end if;

 
 
 if v_admin_item.admin_item_typ_id = 1 then -- Conceptual Domain then add CD-VM relationship

  action_rows := t_rows();

  v_table_name := 'CONC_DOM_VAL_MEAN';
  v_meta_col_cnt := getColumnCount(v_table_name);

   for cdvm_cur in
  (select CONC_DOM_VER_NR, CONC_DOM_ITEM_ID, NCI_VAL_MEAN_ITEM_ID, NCI_VAL_MEAN_VER_NR from conc_dom_val_mean where 
  conc_dom_item_id = v_admin_item.item_id and conc_dom_ver_nr = v_admin_item.ver_nr) loop

      v_sql := getSelectSql(v_table_name) || ' where CONC_DOM_VER_NR = :conc_dom_ver_nr and CONC_DOM_ITEM_ID = :conc_dom_item_id and NCI_VAL_MEAN_ITEM_ID = :nci_val_mean_item_id and NCI_VAL_MEAN_VER_NR = :nci_val_mean_ver_nr';

      v_cur := dbms_sql.open_cursor;
   dbms_sql.parse(v_cur, v_sql, dbms_sql.native);
   dbms_sql.bind_variable(v_cur, ':conc_dom_ver_nr', cdvm_cur.conc_dom_ver_nr);
   dbms_sql.bind_variable(v_cur, ':conc_dom_item_id', cdvm_cur.conc_dom_item_id);
   dbms_sql.bind_variable(v_cur, ':nci_val_mean_ver_nr', cdvm_cur.nci_val_mean_ver_nr);
   dbms_sql.bind_variable(v_cur, ':nci_val_mean_item_id', cdvm_cur.nci_val_mean_item_id);

   for i in 1..v_meta_col_cnt loop
       dbms_sql.define_column(v_cur, i, '', 4000);
   end loop;

      v_temp := dbms_sql.execute_and_fetch(v_cur);
      dbms_sql.describe_columns(v_cur, v_meta_col_cnt, v_meta_desc_tab);

      row := t_row();

   for i in 1..v_meta_col_cnt loop
    dbms_sql.column_value(v_cur, i, v_col_val);
    ihook.setColumnValue(row, v_meta_desc_tab(i).col_name, v_col_val);
   end loop;

   dbms_sql.close_cursor(v_cur);

      ihook.setColumnValue(row, 'CONC_DOM_VER_NR', spGetNextVer (v_admin_item.ver_nr, v_major_ver));
      action_rows.extend; action_rows(action_rows.last) := row;

  end loop;

  action := t_actionRowset(action_rows, v_table_name, 12, 'insert');
     actions.extend; actions(actions.last) := action;

 end if;
 

if v_admin_item.admin_item_typ_id = 4 then -- DE then add Derived DE components

  action_rows := t_rows();

  v_table_name := 'NCI_ADMIN_ITEM_REL';
  v_meta_col_cnt := getColumnCount(v_table_name);

   for de_cur in
  (select P_ITEM_ID, P_ITEM_VER_NR, C_ITEM_ID, C_ITEM_VER_NR, REL_TYP_ID from NCI_ADMIN_ITEM_REL where 
  P_item_id = v_admin_item.item_id and p_ITEM_ver_nr = v_admin_item.ver_nr and rel_typ_id = 65) loop

      v_sql := getSelectSql(v_table_name) || ' where P_ITEM_ID = :P_ITEM_ID and P_ITEM_VER_NR = :P_ITEM_VER_NR and C_ITEM_ID = :C_ITEM_ID and C_ITEM_VER_NR = :C_ITEM_VER_NR and REL_TYP_ID=65';

      v_cur := dbms_sql.open_cursor;
   dbms_sql.parse(v_cur, v_sql, dbms_sql.native);
   dbms_sql.bind_variable(v_cur, ':P_ITEM_ID', de_cur.P_ITEM_ID);
   dbms_sql.bind_variable(v_cur, ':P_ITEM_VER_NR', de_cur.P_ITEM_VER_NR);
   dbms_sql.bind_variable(v_cur, ':C_ITEM_ID', de_cur.C_ITEM_ID);
   dbms_sql.bind_variable(v_cur, ':C_ITEM_VER_NR', de_cur.C_ITEM_VER_NR);

   for i in 1..v_meta_col_cnt loop
       dbms_sql.define_column(v_cur, i, '', 4000);
   end loop;

      v_temp := dbms_sql.execute_and_fetch(v_cur);
      dbms_sql.describe_columns(v_cur, v_meta_col_cnt, v_meta_desc_tab);

      row := t_row();

   for i in 1..v_meta_col_cnt loop
    dbms_sql.column_value(v_cur, i, v_col_val);
    ihook.setColumnValue(row, v_meta_desc_tab(i).col_name, v_col_val);
   end loop;

   dbms_sql.close_cursor(v_cur);

      ihook.setColumnValue(row, 'P_ITEM_VER_NR', spGetNextVer (v_admin_item.ver_nr, v_major_ver));
      action_rows.extend; action_rows(action_rows.last) := row;

  end loop;

  action := t_actionRowset(action_rows, v_table_name, 12, 'insert');
     actions.extend; actions(actions.last) := action;

 end if;
 
end;



procedure spCreateCommonChildren (actions in out t_actions, v_admin_item admin_item%rowtype, v_major_ver boolean) as


action           t_actionRowset;
action_rows              t_rows := t_rows();
action_rows_csi              t_rows := t_rows();
row          t_row;
v_table_name varchar2(30);
v_sql        varchar2(4000);

v_cur        number;
v_temp        number;

v_col_val       varchar2(4000);

v_meta_col_cnt      integer;
v_meta_desc_tab      dbms_sql.desc_tab;

begin


--Alt names

 action_rows := t_rows();
 action_rows_csi := t_rows();
  v_table_name := 'ALT_NMS';
  v_meta_col_cnt := getColumnCount(v_table_name);

  for an_cur in
  (select nm_id from alt_nms where 
  item_id = v_admin_item.item_id and ver_nr = v_admin_item.ver_nr) loop

      v_sql := getSelectSql(v_table_name) || ' where nm_id = :nm_id';

      v_cur := dbms_sql.open_cursor;
   dbms_sql.parse(v_cur, v_sql, dbms_sql.native);
   dbms_sql.bind_variable(v_cur, ':nm_id', an_cur.nm_id);

   for i in 1..v_meta_col_cnt loop
       dbms_sql.define_column(v_cur, i, '', 4000);
   end loop;

      v_temp := dbms_sql.execute_and_fetch(v_cur);
      dbms_sql.describe_columns(v_cur, v_meta_col_cnt, v_meta_desc_tab);

      row := t_row();

   for i in 1..v_meta_col_cnt loop
    dbms_sql.column_value(v_cur, i, v_col_val);
    ihook.setColumnValue(row, v_meta_desc_tab(i).col_name, v_col_val);
   end loop;
   dbms_sql.close_cursor(v_cur);

     select od_seq_ALT_NMS.nextval into v_temp from dual;
      ihook.setColumnValue(row, 'nm_ID',v_temp);
      ihook.setColumnValue(row, 'VER_NR', spGetNextVer (v_admin_item.ver_nr, v_major_ver));
      action_rows.extend; action_rows(action_rows.last) := row;
          for csi_cur in (select nci_pub_id, nci_ver_nr, typ_nm from NCI_CSI_ALT_DEFNMS where nmdef_id = an_cur.nm_id) loop
            row:= t_row();
            ihook.setColumnValue(row, 'nmdef_ID',v_temp);
            ihook.setColumnValue(row, 'NCI_PUB_ID', csi_cur.NCI_PUB_ID);
            ihook.setColumnValue(row, 'NCI_VER_NR', csi_cur.NCI_VER_NR);
           ihook.setColumnValue(row, 'TYP_NM', csi_cur.TYP_NM);
           action_rows_csi.extend; action_rows_csi(action_rows_Csi.last) := row;
         end loop;


  end loop;
  
  action := t_actionRowset(action_rows, v_table_name, 12, 'insert');
     actions.extend; actions(actions.last) := action;

-- Alternate Definitions

 action_rows := t_rows();

  v_table_name := 'ALT_DEF';
  v_meta_col_cnt := getColumnCount(v_table_name);

  for ad_cur in
  (select def_id from alt_def where 
  item_id = v_admin_item.item_id and ver_nr = v_admin_item.ver_nr) loop

      v_sql := getSelectSql(v_table_name) || ' where def_id = :def_id';

      v_cur := dbms_sql.open_cursor;
   dbms_sql.parse(v_cur, v_sql, dbms_sql.native);
   dbms_sql.bind_variable(v_cur, ':def_id', ad_cur.def_id);

   for i in 1..v_meta_col_cnt loop
       dbms_sql.define_column(v_cur, i, '', 4000);
   end loop;

      v_temp := dbms_sql.execute_and_fetch(v_cur);
      dbms_sql.describe_columns(v_cur, v_meta_col_cnt, v_meta_desc_tab);

      row := t_row();

   for i in 1..v_meta_col_cnt loop
    dbms_sql.column_value(v_cur, i, v_col_val);
    ihook.setColumnValue(row, v_meta_desc_tab(i).col_name, v_col_val);
   end loop;

   dbms_sql.close_cursor(v_cur);
   select od_seq_ALT_DEF.nextval into v_temp from dual;
      ihook.setColumnValue(row, 'def_ID', v_temp);
      ihook.setColumnValue(row, 'VER_NR', spGetNextVer (v_admin_item.ver_nr, v_major_ver));
      action_rows.extend; action_rows(action_rows.last) := row;

        for csi_cur in (select nci_pub_id, nci_ver_nr, typ_nm from NCI_CSI_ALT_DEFNMS where nmdef_id = ad_cur.def_id) loop
            row:= t_row();
            ihook.setColumnValue(row, 'nmdef_ID',v_temp);
            ihook.setColumnValue(row, 'NCI_PUB_ID', csi_cur.NCI_PUB_ID);
            ihook.setColumnValue(row, 'NCI_VER_NR', csi_cur.NCI_VER_NR);
           ihook.setColumnValue(row, 'TYP_NM', csi_cur.TYP_NM);
           action_rows_csi.extend; action_rows_csi(action_rows_Csi.last) := row;
         end loop;

  end loop;
  
  action := t_actionRowset(action_rows, v_table_name, 13, 'insert');
     actions.extend; actions(actions.last) := action;


  action := t_actionRowset(action_rows_csi, 'Classification level Name/Definition 2',2, 25, 'insert');
     actions.extend; actions(actions.last) := action;

--- Reference Documents

 action_rows := t_rows();

  v_table_name := 'REF';
  v_meta_col_cnt := getColumnCount(v_table_name);

  for ref_cur in
  (select ref_id from ref where 
  item_id = v_admin_item.item_id and ver_nr = v_admin_item.ver_nr) loop

      v_sql := getSelectSql(v_table_name) || ' where ref_id = :ref_id';

      v_cur := dbms_sql.open_cursor;
   dbms_sql.parse(v_cur, v_sql, dbms_sql.native);
   dbms_sql.bind_variable(v_cur, ':ref_id', ref_cur.ref_id);

   for i in 1..v_meta_col_cnt loop
       dbms_sql.define_column(v_cur, i, '', 4000);
   end loop;

      v_temp := dbms_sql.execute_and_fetch(v_cur);
      dbms_sql.describe_columns(v_cur, v_meta_col_cnt, v_meta_desc_tab);

      row := t_row();

   for i in 1..v_meta_col_cnt loop
    dbms_sql.column_value(v_cur, i, v_col_val);
    ihook.setColumnValue(row, v_meta_desc_tab(i).col_name, v_col_val);
   end loop;

   dbms_sql.close_cursor(v_cur);

      ihook.setColumnValue(row, 'ref_ID', -1);
      ihook.setColumnValue(row, 'VER_NR', spGetNextVer (v_admin_item.ver_nr, v_major_ver));
      action_rows.extend; action_rows(action_rows.last) := row;

  end loop;

  action := t_actionRowset(action_rows, v_table_name, 14, 'insert');
     actions.extend; actions(actions.last) := action;


 action_rows := t_rows();

-- Concepts

  v_table_name := 'CNCPT_ADMIN_ITEM';
  v_meta_col_cnt := getColumnCount(v_table_name);

  for ref_cur in
  (select CNCPT_AI_ID from CNCPT_ADMIN_ITEM where 
  item_id = v_admin_item.item_id and ver_nr = v_admin_item.ver_nr) loop

      v_sql := getSelectSql(v_table_name) || ' where CNCPT_AI_ID = :CNCPT_AI_ID';

      v_cur := dbms_sql.open_cursor;
   dbms_sql.parse(v_cur, v_sql, dbms_sql.native);
   dbms_sql.bind_variable(v_cur, ':CNCPT_AI_ID', ref_cur.CNCPT_AI_ID);

   for i in 1..v_meta_col_cnt loop
       dbms_sql.define_column(v_cur, i, '', 4000);
   end loop;

      v_temp := dbms_sql.execute_and_fetch(v_cur);
      dbms_sql.describe_columns(v_cur, v_meta_col_cnt, v_meta_desc_tab);

      row := t_row();

   for i in 1..v_meta_col_cnt loop
    dbms_sql.column_value(v_cur, i, v_col_val);
    ihook.setColumnValue(row, v_meta_desc_tab(i).col_name, v_col_val);
   end loop;

   dbms_sql.close_cursor(v_cur);

      ihook.setColumnValue(row, 'CNCPT_AI_ID', -1);
      ihook.setColumnValue(row, 'VER_NR', spGetNextVer (v_admin_item.ver_nr, v_major_ver));
      action_rows.extend; action_rows(action_rows.last) := row;

  end loop;

  action := t_actionRowset(action_rows, v_table_name, 14, 'insert');
     actions.extend; actions(actions.last) := action;



--- Classifications

 action_rows := t_rows();

  v_table_name := 'NCI_ALT_KEY_ADMIN_ITEM_REL';
  v_meta_col_cnt := getColumnCount(v_table_name);

  for ref_cur in
  (select NCI_PUB_ID,NCI_VER_NR, REL_TYP_ID from NCI_ALT_KEY_ADMIN_ITEM_REL where 
  c_item_id = v_admin_item.item_id and c_item_ver_nr = v_admin_item.ver_nr) loop

      v_sql := getSelectSql(v_table_name) || ' where NCI_PUB_ID = :NCI_PUB_ID and NCI_VER_NR = :NCI_VER_NR and c_item_id = :c_item_id and c_item_ver_nr = :c_item_ver_nr and rel_typ_id = :rel_typ_id';

      v_cur := dbms_sql.open_cursor;
   dbms_sql.parse(v_cur, v_sql, dbms_sql.native);
   dbms_sql.bind_variable(v_cur, ':nci_pub_id', ref_cur.nci_pub_id);
    dbms_sql.bind_variable(v_cur, ':nci_ver_nr', ref_cur.nci_ver_nr);
    dbms_sql.bind_variable(v_cur, ':c_item_id', v_admin_item.item_id);
    dbms_sql.bind_variable(v_cur, ':c_item_ver_nr', v_admin_item.ver_nr);
    dbms_sql.bind_variable(v_cur, ':rel_typ_id', ref_cur.rel_typ_id);

   for i in 1..v_meta_col_cnt loop
       dbms_sql.define_column(v_cur, i, '', 4000);
   end loop;

      v_temp := dbms_sql.execute_and_fetch(v_cur);
      dbms_sql.describe_columns(v_cur, v_meta_col_cnt, v_meta_desc_tab);

      row := t_row();

   for i in 1..v_meta_col_cnt loop
    dbms_sql.column_value(v_cur, i, v_col_val);
    ihook.setColumnValue(row, v_meta_desc_tab(i).col_name, v_col_val);
   end loop;

   dbms_sql.close_cursor(v_cur);

       ihook.setColumnValue(row, 'c_item_VER_NR', spGetNextVer (v_admin_item.ver_nr, v_major_ver));
      action_rows.extend; action_rows(action_rows.last) := row;

  end loop;

  action := t_actionRowset(action_rows, 'NCI_ALT_KEY_ADMIN_ITEM_REL (Hook)',2, 15, 'insert');
    actions.extend; actions(actions.last) := action;

end;
/***********************************************/



procedure spCreateVer (v_data_in in clob, v_data_out out clob, v_user_id varchar2, v_params in varchar2) as

/*

1. if latest_ver is 0 then "Cannot create version if the Administered Item is not the latest version."
2. if registration is not "Standardized" then "Cannot create version for non-standard Administered Item."
3. create a new admin_item with ver_nr=ver_nr+1, registration status = RECORDED (2), and same values for other columns
4. update current admin_item to latest_version=0 and retire it

testing:

begin
spchangestatus('<ITEM_ID><![CDATA[1]]></ITEM_ID><VER_NR><![CDATA[1]]></VER_NR>');
end;

*/

hookInput           t_hookInput;
hookOutput           t_hookOutput := t_hookOutput();
actions           t_actions := t_actions();
action           t_actionRowset;
ai_insert_action_rows  t_rows := t_rows();
ai_update_action_rows  t_rows := t_rows();
ai_audit_action_rows     t_rows := t_rows();
row          t_row;

v_admin_item     admin_item%rowtype;
v_tab_admin_item   tab_admin_item_pk;

v_creat_ver     number;
v_stus_nm     varchar2(100);

v_major_ver     boolean := upper(v_params)=upper('version=major');

v_table_name      varchar2(30);
v_sql        varchar2(4000);

v_cur        number;
v_temp        number;

v_col_val       varchar2(4000);

v_meta_col_cnt      integer;
v_meta_desc_tab      dbms_sql.desc_tab;

begin

    hookInput := ihook.getHookInput(v_data_in);

 hookOutput.invocationNumber := hookInput.invocationNumber;
 hookOutput.originalRowset := hookInput.originalRowset;


 v_tab_admin_item := getParsedAdminItemsData(hookInput.originalRowset);

 for i in 1..v_tab_admin_item.count loop

        select * into v_admin_item from admin_item
        where item_id=v_tab_admin_item(i).item_id and ver_nr=v_tab_admin_item(i).ver_nr
  for update nowait;

     if v_admin_item.currnt_ver_ind = 0 then
            hookOutput.message := 'Cannot create version if the Administered Item is not the latest version.';
            v_data_out := ihook.getHookOutput(hookOutput);
   return;
     end if;

        if (v_admin_item.regstr_stus_id is null) then
      hookOutput.message := 'Cannot create version for Administered Items with no Registration Status assigned.';
            v_data_out := ihook.getHookOutput(hookOutput);
   return;
     end if;

  select to_number(substr(stus_msk,6,1)), stus_nm
  into v_creat_ver, v_stus_nm
  from stus_mstr
  where stus_id = v_admin_item.regstr_stus_id;

     if v_creat_ver = 0 then
      hookOutput.message := 'Cannot create version for registration status: ' || v_stus_nm;
            v_data_out := ihook.getHookOutput(hookOutput);
   return;
     end if;

  v_table_name := 'ADMIN_ITEM';

  v_meta_col_cnt := getColumnCount(v_table_name);

     v_sql := getSelectSql(v_table_name) || ' where item_id=:item_id and ver_nr=:ver_nr';

  v_cur := dbms_sql.open_cursor;
  dbms_sql.parse(v_cur, v_sql, dbms_sql.native);
  dbms_sql.bind_variable(v_cur, ':item_id', v_admin_item.item_id);
  dbms_sql.bind_variable(v_cur, ':ver_nr', v_admin_item.ver_nr);

  for i in 1..v_meta_col_cnt loop
      dbms_sql.define_column(v_cur, i, '', 4000);
  end loop;

     v_temp := dbms_sql.execute_and_fetch(v_cur);
     dbms_sql.describe_columns(v_cur, v_meta_col_cnt, v_meta_desc_tab);

     row := t_row();

  for i in 1..v_meta_col_cnt loop
   dbms_sql.column_value(v_cur, i, v_col_val);
   ihook.setColumnValue(row, v_meta_desc_tab(i).col_name, v_col_val);
  end loop;

  dbms_sql.close_cursor(v_cur);

     ihook.setColumnValue(row, 'VER_NR', spGetNextVer (v_admin_item.ver_nr, v_major_ver));
  ihook.setColumnValue(row, 'CREAT_USR_ID', hookInput.userId);
  ihook.setColumnValue(row, 'LST_UPD_USR_ID', hookInput.userId);

        ai_insert_action_rows.extend; ai_insert_action_rows(ai_insert_action_rows.last) := row;

     row := t_row();
     ihook.setColumnValue(row, 'ITEM_ID', v_admin_item.item_id);
     ihook.setColumnValue(row, 'VER_NR', v_admin_item.ver_nr);
--     ihook.setColumnValue(row, 'REGSTR_STUS_ID', 5); -- removed for FAA
     ihook.setColumnValue(row, 'CURRNT_VER_IND', 0);
        ai_update_action_rows.extend; ai_update_action_rows(ai_update_action_rows.last) := row;

        row := t_row();
     ihook.setColumnValue(row, 'LOG_ID', -1); -- sequence column
     ihook.setColumnValue(row, 'ITEM_ID', v_admin_item.item_id);
     ihook.setColumnValue(row, 'VER_NR', v_admin_item.ver_nr);
     ihook.setColumnValue(row, 'CHNG_TYP_ID', 48);
     ihook.setColumnValue(row, 'CHNG_DESC', 'Version ' || spGetNextVer (v_admin_item.ver_nr, v_major_ver)
      || ' created.');
     ihook.setColumnValue(row, 'LST_UPD_USR_ID', v_user_id);
        ai_audit_action_rows.extend; ai_audit_action_rows(ai_audit_action_rows.last) := row;

  spCreateSubtypeVer(actions, v_admin_item, v_major_ver);
  spCreateCommonChildren(actions, v_admin_item, v_major_ver);

 end loop;

 action := t_actionRowset(ai_insert_action_rows, 'ADMIN_ITEM', 0, 'insert');
    actions.extend; actions(actions.last) := action;

 action := t_actionRowset(ai_update_action_rows, 'ADMIN_ITEM', 0, 'update');
    actions.extend; actions(actions.last) := action;

    action := t_actionRowset(ai_audit_action_rows, 'ADMIN_ITEM_AUDIT', 0, 'insert');
    actions.extend; actions(actions.last) := action;

 hookOutput.actions := actions;

    hookOutput.message := 'Version created successfully.';

    v_data_out := ihook.getHookOutput(hookOutput);

end;

/***********************************************/

/***********************************************/

procedure spShowValueMeaningDependency (v_data_in in clob, v_data_out out clob)
as

hookInput           t_hookInput;
hookOutput           t_hookOutput := t_hookOutput();
showRowset     t_showableRowset;

rows      t_rows;
row          t_row;

v_admin_item                admin_item%rowtype;
v_tab_admin_item            tab_admin_item_pk;

v_found      boolean;

type      t_tab_val_mean_id is table of perm_val.val_mean_id%type;
v_tab_val_mean_id   t_tab_val_mean_id := t_tab_val_mean_id();

v_tab_val_dom    tab_admin_item_pk := tab_admin_item_pk();

type      t_admin_item_nm is table of admin_item.item_nm%type;
v_tab_admin_item_nm   t_admin_item_nm := t_admin_item_nm();

v_val_mean_desc    val_mean.val_mean_desc%type;
v_perm_val_nm    perm_val.perm_val_nm%type;

begin

    hookInput := ihook.getHookInput(v_data_in);

 hookOutput.invocationNumber := hookInput.invocationNumber;
 hookOutput.originalRowset := hookInput.originalRowset;

 v_tab_admin_item := getParsedAdminItemsData(hookInput.originalRowset);

    -- saving all unique val_mean_ids from submitted admin items into v_tab_val_mean_id
    for i in 1 .. v_tab_admin_item.count loop

        select * into v_admin_item from admin_item
        where item_id=v_tab_admin_item(i).item_id and ver_nr=v_tab_admin_item(i).ver_nr
  for update nowait;

  for rec in (
  select val_mean_id from perm_val
        where val_dom_item_id=v_admin_item.item_id
  and val_dom_ver_nr=v_admin_item.ver_nr and fld_delete=0) loop

         v_found := false;
      for j in 1..v_tab_val_mean_id.count loop
       v_found := v_found or v_tab_val_mean_id(j)=rec.val_mean_id;
         end loop;

   if not v_found then
       v_tab_val_mean_id.extend();
    v_tab_val_mean_id(v_tab_val_mean_id.count) := rec.val_mean_id;
   end if;

  end loop;

 end loop;

 -- extracting all unique val domains and saving them in v_tab_val_dom
    for i in 1 .. v_tab_val_mean_id.count loop

        for rec in
  (select distinct item_id, ver_nr from value_dom
        where (item_id, ver_nr) in
            (select val_dom_item_id, val_dom_ver_nr from perm_val
            where val_mean_id=v_tab_val_mean_id(i))) loop

            v_found := false;
         for j in 1..v_tab_val_dom.count loop
          v_found := v_found or (v_tab_val_dom(j).item_id=rec.item_id and v_tab_val_dom(j).ver_nr=rec.ver_nr);
            end loop;

      if not v_found then
          v_tab_val_dom.extend();
       v_tab_val_dom(v_tab_val_dom.count) := obj_admin_item_pk(rec.item_id, rec.ver_nr);
      end if;

     end loop;

 end loop;

 -- extracting all unique val domains and saving them in v_tab_val_dom
    for i in 1 .. v_tab_val_mean_id.count loop

        for rec in
  (select distinct item_id, ver_nr from value_dom
        where (item_id, ver_nr) in
            (select val_dom_item_id, val_dom_ver_nr from perm_val
            where val_mean_id=v_tab_val_mean_id(i))) loop

            v_found := false;
         for j in 1..v_tab_val_dom.count loop
          v_found := v_found or (v_tab_val_dom(j).item_id=rec.item_id and v_tab_val_dom(j).ver_nr=rec.ver_nr);
            end loop;

      if not v_found then
          v_tab_val_dom.extend();
       v_tab_val_dom(v_tab_val_dom.count) := obj_admin_item_pk(rec.item_id, rec.ver_nr);
      end if;

     end loop;

 end loop;

 -- buidling column headers from val dom names
    for i in 1 .. v_tab_val_dom.count loop

     v_tab_admin_item_nm.extend();

     select item_nm || ' (' || v_tab_val_dom(i).ver_nr || ')' into v_tab_admin_item_nm(v_tab_admin_item_nm.count)
  from admin_item
     where item_id=v_tab_val_dom(i).item_id and ver_nr=v_tab_val_dom(i).ver_nr;

 end loop;

    -- expanding value meanings within value domains
    for i in 1 .. v_tab_val_dom.count loop

        for rec in (
     select val_mean_id from perm_val
        where val_dom_item_id=v_tab_val_dom(i).item_id and val_dom_ver_nr=v_tab_val_dom(i).ver_nr
  and fld_delete=0
        ) loop

         v_found := false;
      for j in 1..v_tab_val_mean_id.count loop
       v_found := v_found or v_tab_val_mean_id(j)=rec.val_mean_id;
         end loop;

   if not v_found then
       v_tab_val_mean_id.extend();
    v_tab_val_mean_id(v_tab_val_mean_id.count) := rec.val_mean_id;
   end if;

     end loop;

 end loop;

    -- populating val means/perm vals
    rows := t_rows();
    for i in 1 .. v_tab_val_mean_id.count loop

     select val_mean_desc into v_val_mean_desc
  from val_mean
  where val_mean_id=v_tab_val_mean_id(i);

        row := t_row();
        ihook.setColumnValue(row, 'Value Meaning', v_val_mean_desc);

        for j in 1 .. v_tab_val_dom.count loop

      v_perm_val_nm := '';
   for rec in
   (select perm_val_nm
   from perm_val a
         where val_mean_id=v_tab_val_mean_id(i)
   and val_dom_item_id=v_tab_val_dom(j).item_id and val_dom_ver_nr=v_tab_val_dom(j).ver_nr
      and fld_delete=0) loop

                v_perm_val_nm := rec.perm_val_nm;

            end loop;

       ihook.setColumnValue(row, v_tab_admin_item_nm(j), v_perm_val_nm);

        end loop;

        rows.extend; rows(rows.last) := row;

 end loop;

    showRowset := t_showableRowset(rows, 'Value Meaning Dependency',4, 'unselectable');
    hookOutput.showRowset := showRowset;

    hookOutput.message := 'The following Value Meaning dependencies found:';

    v_data_out := ihook.getHookOutput(hookOutput);

end;


procedure spShowVMDependencyLimit (v_data_in in clob, v_data_out out clob, v_Mode in number)
as

hookInput           t_hookInput;
hookOutput           t_hookOutput := t_hookOutput();
showRowset     t_showableRowset;

rows      t_rows;
row          t_row;

v_admin_item                admin_item%rowtype;
v_tab_admin_item            tab_admin_item_pk;

v_found      boolean;

type      t_tab_val_mean_id is table of perm_val.val_mean_id%type;
v_tab_val_mean_id   t_tab_val_mean_id := t_tab_val_mean_id();

v_tab_val_dom    tab_admin_item_pk := tab_admin_item_pk();

type      t_admin_item_nm is table of admin_item.item_nm%type;
v_tab_admin_item_nm   t_admin_item_nm := t_admin_item_nm();

v_val_mean_desc    val_mean.val_mean_desc%type;
v_perm_val_nm    perm_val.perm_val_nm%type;
v_item_id		 number;
v_ver_nr		 number;

begin

    hookInput := ihook.getHookInput(v_data_in);

 hookOutput.invocationNumber := hookInput.invocationNumber;
 hookOutput.originalRowset := hookInput.originalRowset;

 v_tab_admin_item := getParsedAdminItemsData(hookInput.originalRowset);

    -- saving all unique val_mean_ids from submitted admin items into v_tab_val_mean_id
if v_Mode = 1 then 
    for i in 1 .. v_tab_admin_item.count loop

        select * into v_admin_item from admin_item
        where item_id=v_tab_admin_item(i).item_id and ver_nr=v_tab_admin_item(i).ver_nr
  for update nowait;

  for rec in (
  select val_mean_id from perm_val
        where val_dom_item_id=v_admin_item.item_id
  and val_dom_ver_nr=v_admin_item.ver_nr and fld_delete=0) loop

         v_found := false;
      for j in 1..v_tab_val_mean_id.count loop
       v_found := v_found or v_tab_val_mean_id(j)=rec.val_mean_id;
         end loop;

   if not v_found then
       v_tab_val_mean_id.extend();
    v_tab_val_mean_id(v_tab_val_mean_id.count) := rec.val_mean_id;
   end if;

  end loop;

 end loop;
 elsif v_mode = 2 then
    for i in 1 .. v_tab_admin_item.count loop

        select val_dom_item_id, val_dom_ver_nr into v_item_id, v_ver_nr from de
        where item_id=v_tab_admin_item(i).item_id and ver_nr=v_tab_admin_item(i).ver_nr
  for update nowait;

  for rec in (
  select val_mean_id from perm_val
        where val_dom_item_id=v_item_id
  and val_dom_ver_nr=v_ver_nr and fld_delete=0) loop

         v_found := false;
      for j in 1..v_tab_val_mean_id.count loop
       v_found := v_found or v_tab_val_mean_id(j)=rec.val_mean_id;
         end loop;

   if not v_found then
       v_tab_val_mean_id.extend();
    v_tab_val_mean_id(v_tab_val_mean_id.count) := rec.val_mean_id;
   end if;

  end loop;

 end loop;

 end if;

 -- buidling column headers from val dom names
    for i in 1 .. v_tab_admin_item.count loop

     v_tab_admin_item_nm.extend();

     select item_nm || ' (' || v_tab_admin_item(i).ver_nr || ')' into v_tab_admin_item_nm(v_tab_admin_item_nm.count)
  from admin_item
     where item_id=v_tab_admin_item(i).item_id and ver_nr=v_tab_admin_item(i).ver_nr;

 end loop;

/*    -- expanding value meanings within value domains
    for i in 1 .. v_tab_val_dom.count loop

        for rec in (
     select val_mean_id from perm_val
        where val_dom_item_id=v_tab_val_dom(i).item_id and val_dom_ver_nr=v_tab_val_dom(i).ver_nr
  and fld_delete=0
        ) loop

         v_found := false;
      for j in 1..v_tab_val_mean_id.count loop
       v_found := v_found or v_tab_val_mean_id(j)=rec.val_mean_id;
         end loop;

   if not v_found then
       v_tab_val_mean_id.extend();
    v_tab_val_mean_id(v_tab_val_mean_id.count) := rec.val_mean_id;
   end if;

     end loop;

 end loop;
*/
    -- populating val means/perm vals
    rows := t_rows();
    for i in 1 .. v_tab_val_mean_id.count loop

     select val_mean_desc into v_val_mean_desc
  from val_mean
  where val_mean_id=v_tab_val_mean_id(i);

        row := t_row();
        ihook.setColumnValue(row, 'Value Meaning', v_val_mean_desc);

        for j in 1 .. v_tab_admin_item.count loop

      v_perm_val_nm := '';
 if (v_Mode = 1) then
   for rec in
   (select perm_val_nm
   from perm_val a
         where val_mean_id=v_tab_val_mean_id(i)
   and val_dom_item_id=v_tab_admin_item(j).item_id and val_dom_ver_nr=v_tab_admin_item(j).ver_nr
      and fld_delete=0) loop

                v_perm_val_nm := rec.perm_val_nm;

            end loop;
 elsif v_Mode= 2 then
   for rec in
   (select perm_val_nm
   from perm_val a, de b
         where val_mean_id=v_tab_val_mean_id(i)
   and a.val_dom_item_id=b.val_dom_item_id and a.val_dom_ver_nr = b.val_dom_ver_nr
   and b.item_id = v_tab_admin_item(j).item_id and b.ver_nr=v_tab_admin_item(j).ver_nr
      and a.fld_delete=0) loop

                v_perm_val_nm := rec.perm_val_nm;

            end loop;

 end if;
       ihook.setColumnValue(row, v_tab_admin_item_nm(j), v_perm_val_nm);

        end loop;

        rows.extend; rows(rows.last) := row;

 end loop;

    showRowset := t_showableRowset(rows, 'Value Meaning Dependency',4, 'unselectable');
    hookOutput.showRowset := showRowset;

    hookOutput.message := 'The following Value Meaning dependencies found:';

    v_data_out := ihook.getHookOutput(hookOutput);

end;

/***********************************************/

-- This hook checks to make sure that the DEC and VD belonging to a DE are from the same CD.
PROCEDURE spPreHookCheckDE
(a_table_name in varchar2, a_transaction_type in varchar2, a_data in raw, a_user in varchar2)
as

v_src_item_id  number;
v_to_map_item_id    number;
v_src_prg_id  number;
v_temp     number;
v_date     date;
v_len     number;
v_row    hook.t_row;

BEGIN

 v_row := hook.getEventHookRow(a_data);

 /*  Decompose DEC and Value Domain */

 select count(distinct CONC_DOM_ITEM_ID || CONC_DOM_VER_NR) into v_temp from
 (select CONC_DOM_ITEM_ID, CONC_DOM_VER_NR from VALUE_DOM where ITEM_ID = v_row('VAL_DOM_ITEM_ID') and
 VER_NR = v_row('VAL_DOM_VER_NR')
 union
    select CONC_DOM_ITEM_ID, CONC_DOM_VER_NR from DE_CONC where ITEM_ID = v_row('DE_CONC_ITEM_ID') and
 VER_NR = v_row('DE_CONC_VER_NR'));

 if v_temp > 1 then
    raise_application_error(-20001,
       '<br><br><b>Conceptual Domain of the Data Element Concept does not match Conceptual Domain of Value Domain. Please check assignment.</b><br><br>');
 end if;

END;

/***********************************************/

END;
/


GRANT EXECUTE ON ONEDATA_WA.NCI_11179 TO ONEDATA_RO;
